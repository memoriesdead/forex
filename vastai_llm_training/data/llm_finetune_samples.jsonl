{"instruction": "What is the source paper for research paper?", "input": "", "output": "The source is: arXiv:1912.09363. ", "source": "core\\features\\academic_deep_learning.py", "category": "risk"}
{"instruction": "What is the source paper for research paper?", "input": "", "output": "The source is: arXiv:2310.06625. ", "source": "core\\features\\academic_deep_learning.py", "category": "risk"}
{"instruction": "What is the source paper for research paper?", "input": "", "output": "The source is: arXiv:2402.19072. ", "source": "core\\features\\academic_deep_learning.py", "category": "risk"}
{"instruction": "What is the source paper for research paper?", "input": "", "output": "The source is: arXiv:1905.10437. ", "source": "core\\features\\academic_deep_learning.py", "category": "risk"}
{"instruction": "What is the source paper for research paper?", "input": "", "output": "The source is: arXiv:2211.14730. ", "source": "core\\features\\academic_deep_learning.py", "category": "risk"}
{"instruction": "Explain the purpose of Academic Deep Learning Models for Time Series Forecasting", "input": "", "output": "Academic Deep Learning Models for Time Series Forecasting\n==========================================================\n\nReferences to state-of-the-art deep learning architectures for\ntime series forecasting from top ML conferences (ICLR, NeurIPS).\n\nThis module provides configuration classes and integration points\nfor models from the Time-Series-Library (https://github.com/thuml/Time-Series-Library).\n\nCITATIONS:\n----------\n\n1. TEMPORAL FUSION TRANSFORMER (TFT)\n   Lim, B., Arık, S.Ö., Loeff, N., & Pfister, T. (2021).\n   \"Temporal Fusion Transformers for Interpretable Multi-horizon Time Series Forecasting\"\n   International Journal of Forecasting, 37(4), 1748-1764.\n   DOI: 10.1016/j.ijforecast.2021.01.012\n   arXiv: https://arxiv.org/abs/1912.09363\n   Google Research: https://research.google/pubs/temporal-fusion-transformers/\n\n2. iTRANSFORMER (ICLR 2024 Spotlight)\n   Liu, Y., Hu, T., Zhang, H., Wu, H., Wang, S., Ma, L., & Long, M. (2024).\n   \"iTransformer: Inverted Transformers Are Effective for Time Series Forecasting\"\n   ICLR 2024.\n   arXiv: https://arxiv.org/abs/2310.06625\n   GitHub: https://github.com/thuml/iTransformer\n\n3. TimeXer (NeurIPS 2024)\n   Wang, S., Wu, H., Shi, X., Hu, T., Luo, H., Ma, L., Zhang, J.Y., & Long, M. (2024).\n   \"TimeXer: Empowering Transformers for Time Series Forecasting with Exogenous Variables\"\n   NeurIPS 2024.\n   arXiv: https://arxiv.org/abs/2402.19072\n   GitHub: https://github.com/thuml/TimeXer\n\n4. N-BEATS (ICLR 2020)\n   Oreshkin, B.N., Carpov, D., Chapados, N., & Bengio, Y. (2020).\n   \"N-BEATS: Neural Basis Expansion Analysis for Interpretable Time Series Forecasting\"\n   ICLR 2020.\n   arXiv: https://arxiv.org/abs/1905.10437\n   GitHub: https://github.com/ServiceNow/N-BEATS\n\n5. TimeMixer (ICLR 2024)\n   Wang, S., Wu, H., Shi, X., Hu, T., Luo, H., Ma, L., & Long, M. (2024).\n   \"TimeMixer: Decomposable Multiscale Mixing for Time Series Forecasting\"\n   ICLR 2024 Spotlight.\n   GitHub: https://github.com/thuml/Time-Series-Library\n\n6. PatchTST (ICLR 2023)\n   Nie, Y., Nguyen, N.H., Sinthong, P., & Kalagnanam, J. (2023).\n   \"A Time Series is Worth 64 Words: Long-term Forecasting with Transformers\"\n   ICLR 2023.\n   arXiv: https://arxiv.org/abs/2211.14730\n\nKEY ARCHITECTURAL INSIGHTS:\n---------------------------\n\nTEMPORAL FUSION TRANSFORMER (TFT):\n    - Variable Selection Network: Learns which features are important\n    - Gated Residual Network: Nonlinear feature processing\n    - Interpretable Multi-Head Attention: Temporal patterns\n    - Quantile Outputs: Probabilistic forecasting\n\n    \"TFT proposes a novel interpretable Multi-Head Attention mechanism,\n    which contrary to the standard implementation, provides feature\n    interpretability.\"\n    - Lim et al. (2021)\n\niTRANSFORMER:\n    - Inverted Tokenization: Embed entire time series per variate as token\n    - Cross-Variate Attention: Captures multivariate correlations\n    - Per-Variate FFN: Learns temporal dynamics\n\n    \"iTransformer simply applies the attention and feed-forward network\n    on the inverted dimensions. Specifically, the time points of individual\n    series are embedded into variate tokens which are utilized by the\n    attention mechanism to capture multivariate correlations.\"\n    - Liu et al. (2024)\n\nN-BEATS:\n    - Neural Basis Expansion: Trend and seasonality decomposition\n    - Doubly Residual Architecture: Forecast and backcast\n    - Interpretable Stacks: Polynomial (trend) + Fourier (seasonality)\n\n    \"N-BEATS demonstrated state-of-the-art performance, improving forecast\n    accuracy by 11% over a statistical benchmark and by 3% over the winner\n    of the M4 competition.\"\n    - Oreshkin et al. (2020)\n\nAPPLICABILITY:\n--------------\nAll models are ADAPTABLE for forex:\n- TFT: Best for multi-horizon forecasting with known future inputs (time features)\n- iTransformer: Best for multivariate (multi-pair) forecasting\n- TimeXer: Best when using exogenous variables (interest rates, sentiment)\n- N-BEATS: Best for univariate, interpretable forecasting", "source": "core\\features\\academic_deep_learning.py", "category": "risk"}
{"instruction": "What is the TFTConfig class and how do I use it?", "input": "", "output": "The TFTConfig class:\n\nTemporal Fusion Transformer Configuration.\n\nReference: Lim et al. (2021), International Journal of Forecasting\n\nThe TFT architecture handles:\n- Static covariates (e.g., currency pair identifier)\n- Known future inputs (e.g., day of week, hour)\n- Unknown future inputs (e.g., price, volume)", "source": "core\\features\\academic_deep_learning.py", "category": "volatility"}
{"instruction": "What is the iTransformerConfig class and how do I use it?", "input": "", "output": "The iTransformerConfig class:\n\niTransformer Configuration.\n\nReference: Liu et al. (2024), ICLR 2024\n\nKey innovation: Invert the standard Transformer to apply attention\nacross variates instead of time points.", "source": "core\\features\\academic_deep_learning.py", "category": "risk"}
{"instruction": "What is the TimeXerConfig class and how do I use it?", "input": "", "output": "The TimeXerConfig class:\n\nTimeXer Configuration.\n\nReference: Wang et al. (2024), NeurIPS 2024\n\nDesigned for forecasting with exogenous variables.", "source": "core\\features\\academic_deep_learning.py", "category": "risk"}
{"instruction": "What is the NBEATSConfig class and how do I use it?", "input": "", "output": "The NBEATSConfig class:\n\nN-BEATS Configuration.\n\nReference: Oreshkin et al. (2020), ICLR 2020\n\nArchitecture:\n- Stack of blocks with trend and seasonality basis functions\n- Doubly residual learning (forecast + backcast)", "source": "core\\features\\academic_deep_learning.py", "category": "time_series"}
{"instruction": "What is the TimeSeriesLibraryModels class and how do I use it?", "input": "", "output": "The TimeSeriesLibraryModels class:\n\nIntegration with Tsinghua Time-Series-Library.\n\nGitHub: https://github.com/thuml/Time-Series-Library\n\nThis class provides utilities to prepare data and configurations\nfor models in the Time-Series-Library.\n\nSupported models:\n- iTransformer\n- TimeXer\n- TimeMixer\n- PatchTST\n- DLinear\n- And many more...", "source": "core\\features\\academic_deep_learning.py", "category": "rl"}
{"instruction": "What is the DeepLearningFeatures class and how do I use it?", "input": "", "output": "The DeepLearningFeatures class:\n\nGenerate features optimized for deep learning models.\n\nThese features are designed to work well with Transformer-based\narchitectures like TFT and iTransformer.", "source": "core\\features\\academic_deep_learning.py", "category": "general"}
{"instruction": "What is the AcademicDeepLearningFeatures class and how do I use it?", "input": "", "output": "The AcademicDeepLearningFeatures class:\n\nGenerate features for academic deep learning models.\n\nThis class prepares data and configurations for state-of-the-art\ntime series forecasting models.", "source": "core\\features\\academic_deep_learning.py", "category": "regime"}
{"instruction": "What is the formula for Generate Deep Learning Features?", "input": "", "output": "Convenience function to generate deep learning features.\n\nCitations:\n- Lim et al. (2021) - Temporal Fusion Transformer\n- Liu et al. (2024) - iTransformer\n- Wang et al. (2024) - TimeXer\n- Oreshkin et al. (2020) - N-BEATS\n\nArgs:\n    df: DataFrame with OHLCV data\n    **kwargs: Additional arguments\n\nReturns:\n    DataFrame with DL-ready features", "source": "core\\features\\academic_deep_learning.py", "category": "general"}
{"instruction": "Explain the Generate Deep Learning Features function", "input": "", "output": "Function: generate_deep_learning_features\n\nConvenience function to generate deep learning features.\n\nCitations:\n- Lim et al. (2021) - Temporal Fusion Transformer\n- Liu et al. (2024) - iTransformer\n- Wang et al. (2024) - TimeXer\n- Oreshkin et al. (2020) - N-BEATS\n\nArgs:\n    df: DataFrame with OHLCV data\n    **kwargs: Additional arguments\n\nReturns:\n    DataFrame with DL-ready features", "source": "core\\features\\academic_deep_learning.py", "category": "general"}
{"instruction": "What is the formula for Prepare Forex Data?", "input": "", "output": "Prepare forex data for Time-Series-Library models.\n\nArgs:\n    df: DataFrame with OHLCV data\n    target_col: Target column name\n    feature_cols: Feature column names\n    seq_len: Lookback length\n    pred_len: Prediction length\n\nReturns:\n    Dictionary with prepared data arrays", "source": "core\\features\\academic_deep_learning.py", "category": "general"}
{"instruction": "Explain the Prepare Forex Data function", "input": "", "output": "Function: prepare_forex_data\n\nPrepare forex data for Time-Series-Library models.\n\nArgs:\n    df: DataFrame with OHLCV data\n    target_col: Target column name\n    feature_cols: Feature column names\n    seq_len: Lookback length\n    pred_len: Prediction length\n\nReturns:\n    Dictionary with prepared data arrays", "source": "core\\features\\academic_deep_learning.py", "category": "general"}
{"instruction": "What is the formula for Get Model Config?", "input": "", "output": "Get default configuration for a Time-Series-Library model.\n\nArgs:\n    model_name: Model name\n    seq_len: Lookback length\n    pred_len: Prediction length\n    enc_in: Number of input variates\n\nReturns:\n    Configuration dictionary", "source": "core\\features\\academic_deep_learning.py", "category": "risk"}
{"instruction": "Explain the Get Model Config function", "input": "", "output": "Function: get_model_config\n\nGet default configuration for a Time-Series-Library model.\n\nArgs:\n    model_name: Model name\n    seq_len: Lookback length\n    pred_len: Prediction length\n    enc_in: Number of input variates\n\nReturns:\n    Configuration dictionary", "source": "core\\features\\academic_deep_learning.py", "category": "risk"}
{"instruction": "What is the formula for Generate Time Features?", "input": "", "output": "Generate time-based features for TFT.\n\nThese are \"known future inputs\" that the model can use\nfor forecasting.\n\nArgs:\n    df: DataFrame with DatetimeIndex\n\nReturns:\n    DataFrame with time features", "source": "core\\features\\academic_deep_learning.py", "category": "time_series"}
{"instruction": "Explain the Generate Time Features function", "input": "", "output": "Function: generate_time_features\n\nGenerate time-based features for TFT.\n\nThese are \"known future inputs\" that the model can use\nfor forecasting.\n\nArgs:\n    df: DataFrame with DatetimeIndex\n\nReturns:\n    DataFrame with time features", "source": "core\\features\\academic_deep_learning.py", "category": "time_series"}
{"instruction": "What is the formula for Normalize For Dl?", "input": "", "output": "Normalize data for deep learning.\n\nArgs:\n    df: DataFrame to normalize\n    method: 'zscore', 'minmax', or 'robust'\n    window: Rolling window (None = global)\n\nReturns:\n    Tuple of (normalized DataFrame, normalization parameters)", "source": "core\\features\\academic_deep_learning.py", "category": "general"}
{"instruction": "Explain the Normalize For Dl function", "input": "", "output": "Function: normalize_for_dl\n\nNormalize data for deep learning.\n\nArgs:\n    df: DataFrame to normalize\n    method: 'zscore', 'minmax', or 'robust'\n    window: Rolling window (None = global)\n\nReturns:\n    Tuple of (normalized DataFrame, normalization parameters)", "source": "core\\features\\academic_deep_learning.py", "category": "general"}
{"instruction": "What is the formula for Generate All?", "input": "", "output": "Generate all features suitable for deep learning.\n\nArgs:\n    df: DataFrame with OHLCV data\n\nReturns:\n    DataFrame with DL-ready features", "source": "core\\features\\academic_deep_learning.py", "category": "general"}
{"instruction": "Explain the Generate All function", "input": "", "output": "Function: generate_all\n\nGenerate all features suitable for deep learning.\n\nArgs:\n    df: DataFrame with OHLCV data\n\nReturns:\n    DataFrame with DL-ready features", "source": "core\\features\\academic_deep_learning.py", "category": "general"}
{"instruction": "Explain the purpose of Academic Market Making Models - Optimal Quoting & Inventory Control", "input": "", "output": "Academic Market Making Models - Optimal Quoting & Inventory Control\n====================================================================\n\nImplementations of optimal market making models from the quantitative\nfinance literature. These models provide optimal bid/ask quotes based\non inventory risk and market conditions.\n\nCITATIONS:\n----------\n\n1. AVELLANEDA-STOIKOV MODEL\n   Avellaneda, M., & Stoikov, S. (2008).\n   \"High-frequency trading in a limit order book\"\n   Quantitative Finance, 8(3), 217-224.\n   DOI: 10.1080/14697680701381228\n   PDF: https://people.orie.cornell.edu/sfs33/LimitOrderBook.pdf\n\n2. GUÉANT-LEHALLE-FERNANDEZ-TAPIA EXTENSION\n   Guéant, O., Lehalle, C.A., & Fernandez-Tapia, J. (2012).\n   \"Dealing with the inventory risk: a solution to the market making problem\"\n   Mathematics and Financial Economics, 4(7), 477-507.\n   DOI: 10.1007/s11579-012-0078-5\n\n3. OPTIMAL EXECUTION WITH LIMIT ORDERS\n   Guéant, O., & Lehalle, C.A. (2015).\n   \"General Intensity Shapes in Optimal Liquidation\"\n   Mathematical Finance, 25(3), 457-495.\n\n4. MARKET MAKING WITH INVENTORY CONSTRAINTS\n   Fodra, P., & Labadie, M. (2012).\n   \"High-frequency market-making with inventory constraints and directional bets\"\n   arXiv:1206.4810\n\nKEY FORMULAS:\n-------------\nReservation Price:\n    r(s, q, t) = s - q·γ·σ²·(T-t)\n\nOptimal Spread:\n    δ^a + δ^b = γ·σ²·(T-t) + (2/γ)·ln(1 + γ/k)\n\nWhere:\n    s = mid price\n    q = inventory (positive = long)\n    γ = risk aversion parameter\n    σ = volatility\n    T = terminal time\n    k = order arrival intensity parameter\n\nAPPLICABILITY: FOREX-NATIVE (especially for market makers, liquidity\nproviders, and understanding bid-ask spread dynamics)", "source": "core\\features\\academic_market_making.py", "category": "volatility"}
{"instruction": "What is the MarketMakingConfig class and how do I use it?", "input": "", "output": "The MarketMakingConfig class:\n\nConfiguration for market making models.", "source": "core\\features\\academic_market_making.py", "category": "general"}
{"instruction": "What is the AvellanedaStoikov class and how do I use it?", "input": "", "output": "The AvellanedaStoikov class:\n\nAvellaneda-Stoikov Optimal Market Making Model.\n\nThe seminal model for optimal bid/ask quote placement with\ninventory risk management.\n\nKey Insight:\n    \"The main result is that the optimal bid and ask quotes are\n    derived in an intuitive two-step procedure. First, the dealer\n    computes a personal indifference valuation for the stock,\n    given his current inventory. Second, he calibrates his bid\n    and ask quotes to the limit order book.\"\n    - Avellaneda & Stoikov (2008)\n\nModel Assumptions:\n    - Mid-price follows arithmetic Brownian motion\n    - Order arrivals are Poisson with intensity λ(δ) = A·exp(-k·δ)\n    - Market maker has CARA utility (exponential)\n    - No transaction costs\n\nCitation:\n    Avellaneda, M., & Stoikov, S. (2008).\n    Quantitative Finance, 8(3), 217-224.", "source": "core\\features\\academic_market_making.py", "category": "risk"}
{"instruction": "What is the MarketMakingFeatures class and how do I use it?", "input": "", "output": "The MarketMakingFeatures class:\n\nGenerate market making features for analysis and trading.\n\nThese features can be used to:\n- Understand market maker behavior\n- Estimate fair spreads\n- Detect inventory pressure", "source": "core\\features\\academic_market_making.py", "category": "microstructure"}
{"instruction": "What is the AcademicMarketMakingFeatures class and how do I use it?", "input": "", "output": "The AcademicMarketMakingFeatures class:\n\nGenerate all academic market making features.\n\nCombines Avellaneda-Stoikov model with spread analysis\nand inventory estimation.", "source": "core\\features\\academic_market_making.py", "category": "microstructure"}
{"instruction": "What is the formula for Generate Market Making Features?", "input": "", "output": "Convenience function to generate market making features.\n\nCitations:\n- Avellaneda & Stoikov (2008) - Optimal market making\n- Guéant et al. (2012) - Inventory risk\n- Lehalle et al. (2013) - Market microstructure\n\nArgs:\n    df: DataFrame with price data\n    **kwargs: Additional arguments\n\nReturns:\n    DataFrame with market making features", "source": "core\\features\\academic_market_making.py", "category": "risk"}
{"instruction": "Explain the Generate Market Making Features function", "input": "", "output": "Function: generate_market_making_features\n\nConvenience function to generate market making features.\n\nCitations:\n- Avellaneda & Stoikov (2008) - Optimal market making\n- Guéant et al. (2012) - Inventory risk\n- Lehalle et al. (2013) - Market microstructure\n\nArgs:\n    df: DataFrame with price data\n    **kwargs: Additional arguments\n\nReturns:\n    DataFrame with market making features", "source": "core\\features\\academic_market_making.py", "category": "risk"}
{"instruction": "What is the formula for Reservation Price?", "input": "", "output": "Compute reservation (indifference) price.\n\nThe reservation price is the market maker's personal valuation\nof the asset given their current inventory position.\n\nFormula:\n    r(s, q, t) = s - q·γ·σ²·(T-t)\n\nInterpretation:\n    - If inventory > 0 (long): reservation < mid (want to sell)\n    - If inventory < 0 (short): reservation > mid (want to buy)\n    - If inventory = 0: reservation = mid\n\n\"First, the dealer computes a personal indifference valuation\nfor the stock, given his current inventory.\"\n- Avellaneda & Stoikov (2008)\n\nArgs:\n    mid_price: Current mid price\n    inventory: Current inventory (positive = long)\n    time_remaining: Time remaining until terminal (default: T)\n\nReturns:\n    Reservation price", "source": "core\\features\\academic_market_making.py", "category": "general"}
{"instruction": "Explain the Reservation Price function", "input": "", "output": "Function: reservation_price\n\nCompute reservation (indifference) price.\n\nThe reservation price is the market maker's personal valuation\nof the asset given their current inventory position.\n\nFormula:\n    r(s, q, t) = s - q·γ·σ²·(T-t)\n\nInterpretation:\n    - If inventory > 0 (long): reservation < mid (want to sell)\n    - If inventory < 0 (short): reservation > mid (want to buy)\n    - If inventory = 0: reservation = mid\n\n\"First, the dealer computes a personal indifference valuation\nfor the stock, given his current inventory.\"\n- Avellaneda & Stoikov (2008)\n\nArgs:\n    mid_price: Current mid price\n    inventory: Current inventory (positive = long)\n    time_remaining: Time remaining until terminal (default: T)\n\nReturns:\n    Reservation price", "source": "core\\features\\academic_market_making.py", "category": "general"}
{"instruction": "What is the formula for Optimal Spread?", "input": "", "output": "Compute optimal total spread.\n\nFormula:\n    δ^a + δ^b = γ·σ²·(T-t) + (2/γ)·ln(1 + γ/k)\n\n\"The bid-ask spread is independent of the inventory.\"\n- Avellaneda & Stoikov (2008)\n\nThe first term depends on time and risk aversion.\nThe second term comes from the order arrival intensity model.\n\nArgs:\n    time_remaining: Time remaining until terminal\n\nReturns:\n    Total spread (ask_delta + bid_delta)", "source": "core\\features\\academic_market_making.py", "category": "risk"}
{"instruction": "Explain the Optimal Spread function", "input": "", "output": "Function: optimal_spread\n\nCompute optimal total spread.\n\nFormula:\n    δ^a + δ^b = γ·σ²·(T-t) + (2/γ)·ln(1 + γ/k)\n\n\"The bid-ask spread is independent of the inventory.\"\n- Avellaneda & Stoikov (2008)\n\nThe first term depends on time and risk aversion.\nThe second term comes from the order arrival intensity model.\n\nArgs:\n    time_remaining: Time remaining until terminal\n\nReturns:\n    Total spread (ask_delta + bid_delta)", "source": "core\\features\\academic_market_making.py", "category": "risk"}
{"instruction": "What is the formula for Optimal Quotes?", "input": "", "output": "Compute optimal bid and ask prices.\n\n\"To minimize inventory risk, prices should be skewed to favor\nthe inventory to come back to its targeted ideal balance point.\nTo maximize trade profitability, spreads should be enlarged such\nthat the expected future value of the account is maximized.\"\n- Avellaneda & Stoikov (2008)\n\nArgs:\n    mid_price: Current mid price\n    inventory: Current inventory (positive = long)\n    time_remaining: Time remaining until terminal\n\nReturns:\n    Tuple of (optimal_bid, optimal_ask)", "source": "core\\features\\academic_market_making.py", "category": "risk"}
{"instruction": "Explain the Optimal Quotes function", "input": "", "output": "Function: optimal_quotes\n\nCompute optimal bid and ask prices.\n\n\"To minimize inventory risk, prices should be skewed to favor\nthe inventory to come back to its targeted ideal balance point.\nTo maximize trade profitability, spreads should be enlarged such\nthat the expected future value of the account is maximized.\"\n- Avellaneda & Stoikov (2008)\n\nArgs:\n    mid_price: Current mid price\n    inventory: Current inventory (positive = long)\n    time_remaining: Time remaining until terminal\n\nReturns:\n    Tuple of (optimal_bid, optimal_ask)", "source": "core\\features\\academic_market_making.py", "category": "risk"}
{"instruction": "What is OFI in quantitative trading?", "input": "", "output": "OFI (Order Flow Imbalance).\n\nImplementation details:\nCompute optimal bid and ask prices.\n\n\"To minimize inventory risk, prices should be skewed to favor\nthe inventory to come back to its targeted ideal balance point.\nTo maximize trade profitability, spreads should be enlarged such\nthat the expected future value of the account is maximized.\"\n- Avellaneda & Stoikov (2008)\n\nArgs:\n    mid_price: Current mid price\n    inventory: Current inventory (positive = long)\n    time_remaining: Time remaining until terminal\n\nReturns:\n    Tuple of (optimal_bid, optimal_ask)", "source": "core\\features\\academic_market_making.py", "category": "risk"}
{"instruction": "What is the formula for Expected Fill Rate?", "input": "", "output": "Expected order fill rate at distance delta from mid.\n\n\"Avellaneda and Stoikov showed that, given the empirical evidence,\nwe can assume that λ(δ) = A·exp(-k·δ) for order arrival rates.\"\n\nArgs:\n    delta: Distance from mid price\n\nReturns:\n    Expected fill rate (arrivals per unit time)", "source": "core\\features\\academic_market_making.py", "category": "general"}
{"instruction": "Explain the Expected Fill Rate function", "input": "", "output": "Function: expected_fill_rate\n\nExpected order fill rate at distance delta from mid.\n\n\"Avellaneda and Stoikov showed that, given the empirical evidence,\nwe can assume that λ(δ) = A·exp(-k·δ) for order arrival rates.\"\n\nArgs:\n    delta: Distance from mid price\n\nReturns:\n    Expected fill rate (arrivals per unit time)", "source": "core\\features\\academic_market_making.py", "category": "general"}
{"instruction": "What is the formula for Inventory Limits Adjustment?", "input": "", "output": "Adjust quotes based on inventory limits.\n\n\"When inventory approaches the maximum limit, quotes are\nadjusted more aggressively to reduce position.\"\n- Guéant, Lehalle, Fernandez-Tapia (2012)\n\nArgs:\n    bid: Current optimal bid\n    ask: Current optimal ask\n    inventory: Current inventory\n\nReturns:\n    Adjusted (bid, ask)", "source": "core\\features\\academic_market_making.py", "category": "microstructure"}
{"instruction": "Explain the Inventory Limits Adjustment function", "input": "", "output": "Function: inventory_limits_adjustment\n\nAdjust quotes based on inventory limits.\n\n\"When inventory approaches the maximum limit, quotes are\nadjusted more aggressively to reduce position.\"\n- Guéant, Lehalle, Fernandez-Tapia (2012)\n\nArgs:\n    bid: Current optimal bid\n    ask: Current optimal ask\n    inventory: Current inventory\n\nReturns:\n    Adjusted (bid, ask)", "source": "core\\features\\academic_market_making.py", "category": "microstructure"}
{"instruction": "What is the formula for Estimate Market Maker Inventory?", "input": "", "output": "Estimate market maker inventory from quote asymmetry.\n\nIf market maker is long, they quote lower bids (discourage buying)\nand lower asks (encourage selling), creating negative skew.\n\nArgs:\n    bid: Bid price series\n    ask: Ask price series\n    mid: Mid price (if None, computed from bid/ask)\n\nReturns:\n    Estimated inventory signal (positive = MM is long)", "source": "core\\features\\academic_market_making.py", "category": "alpha"}
{"instruction": "Explain the Estimate Market Maker Inventory function", "input": "", "output": "Function: estimate_market_maker_inventory\n\nEstimate market maker inventory from quote asymmetry.\n\nIf market maker is long, they quote lower bids (discourage buying)\nand lower asks (encourage selling), creating negative skew.\n\nArgs:\n    bid: Bid price series\n    ask: Ask price series\n    mid: Mid price (if None, computed from bid/ask)\n\nReturns:\n    Estimated inventory signal (positive = MM is long)", "source": "core\\features\\academic_market_making.py", "category": "alpha"}
{"instruction": "What is the formula for Generate Features?", "input": "", "output": "Generate market making features.\n\nArgs:\n    df: DataFrame with bid/ask/close data\n\nReturns:\n    DataFrame with market making features", "source": "core\\features\\academic_market_making.py", "category": "microstructure"}
{"instruction": "Explain the Generate Features function", "input": "", "output": "Function: generate_features\n\nGenerate market making features.\n\nArgs:\n    df: DataFrame with bid/ask/close data\n\nReturns:\n    DataFrame with market making features", "source": "core\\features\\academic_market_making.py", "category": "microstructure"}
{"instruction": "What is the formula for Generate All?", "input": "", "output": "Generate all market making features.\n\nArgs:\n    df: DataFrame with OHLCV + bid/ask data\n\nReturns:\n    DataFrame with market making features", "source": "core\\features\\academic_market_making.py", "category": "microstructure"}
{"instruction": "Explain the Generate All function", "input": "", "output": "Function: generate_all\n\nGenerate all market making features.\n\nArgs:\n    df: DataFrame with OHLCV + bid/ask data\n\nReturns:\n    DataFrame with market making features", "source": "core\\features\\academic_market_making.py", "category": "microstructure"}
{"instruction": "What is the source paper for research paper?", "input": "", "output": "The source is: arXiv:1011.6402. ", "source": "core\\features\\academic_microstructure.py", "category": "volatility"}
{"instruction": "Explain the purpose of Academic Microstructure Features - Order Flow & Market Impact", "input": "", "output": "Academic Microstructure Features - Order Flow & Market Impact\n=============================================================\n\nPeer-reviewed implementations of market microstructure measures from\ntop finance journals. These features capture informed trading, toxicity,\nand market impact.\n\nCITATIONS:\n----------\n\n1. ORDER FLOW IMBALANCE (OFI)\n   Cont, R., Kukanov, A., & Stoikov, S. (2014).\n   \"The Price Impact of Order Book Events\"\n   Journal of Financial Econometrics, 12(1), 47-88.\n   DOI: 10.1093/jjfinec/nbt003\n   arXiv: https://arxiv.org/abs/1011.6402\n\n2. VPIN (Volume-Synchronized Probability of Informed Trading)\n   Easley, D., López de Prado, M., & O'Hara, M. (2012).\n   \"Flow Toxicity and Liquidity in a High-Frequency World\"\n   Review of Financial Studies, 25(5), 1457-1493.\n   DOI: 10.1093/rfs/hhs053\n\n3. KYLE'S LAMBDA (Market Impact Coefficient)\n   Kyle, A. S. (1985).\n   \"Continuous Auctions and Insider Trading\"\n   Econometrica, 53(6), 1315-1335.\n   DOI: 10.2307/1913210\n\n4. AMIHUD ILLIQUIDITY\n   Amihud, Y. (2002).\n   \"Illiquidity and Stock Returns: Cross-Section and Time-Series Effects\"\n   Journal of Financial Markets, 5(1), 31-56.\n   DOI: 10.1016/S1386-4181(01)00024-6\n\n5. ROLL SPREAD ESTIMATOR\n   Roll, R. (1984).\n   \"A Simple Implicit Measure of the Effective Bid-Ask Spread in an Efficient Market\"\n   Journal of Finance, 39(4), 1127-1139.\n   DOI: 10.1111/j.1540-6261.1984.tb03897.x\n\nAPPLICABILITY:\n--------------\n- OFI: ADAPTABLE (equity-based, methodology applies to forex with order book data)\n- VPIN: ADAPTABLE (widely used in forex for toxicity measurement)\n- Kyle Lambda: FOREX-NATIVE (foundational model for all markets)\n- Amihud: FOREX-NATIVE (liquidity measurement)\n- Roll: FOREX-NATIVE (spread estimation)", "source": "core\\features\\academic_microstructure.py", "category": "volatility"}
{"instruction": "What is the MicrostructureConfig class and how do I use it?", "input": "", "output": "The MicrostructureConfig class:\n\nConfiguration for microstructure calculations.", "source": "core\\features\\academic_microstructure.py", "category": "microstructure"}
{"instruction": "What is the OrderFlowImbalance class and how do I use it?", "input": "", "output": "The OrderFlowImbalance class:\n\nOrder Flow Imbalance (OFI) per Cont, Kukanov & Stoikov (2014).\n\nThe key finding from Cont et al. (2014):\n\"Over short time intervals, price changes are mainly driven by\norder flow imbalance, defined as the imbalance between supply\nand demand at the best bid and ask prices.\"\n\nFormula:\n    OFI_t = (V^B_t - V^B_{t-1}) * I{P^B_t >= P^B_{t-1}}\n          - (V^A_t - V^A_{t-1}) * I{P^A_t <= P^A_{t-1}}\n\nWhere:\n    V^B, V^A = bid/ask volume at best prices\n    P^B, P^A = best bid/ask prices\n    I{} = indicator function\n\nPrice Impact Model:\n    ΔP_t = λ * OFI_t + ε_t\n\nWhere λ = 1/market_depth (inverse of liquidity)\n\nCitation:\n    Cont, R., Kukanov, A., & Stoikov, S. (2014).\n    Journal of Financial Econometrics, 12(1), 47-88.", "source": "core\\features\\academic_microstructure.py", "category": "volatility"}
{"instruction": "What is the VPIN class and how do I use it?", "input": "", "output": "The VPIN class:\n\nVolume-Synchronized Probability of Informed Trading (VPIN).\n\nVPIN measures order flow toxicity - the probability that order flow\nadversely selects market makers. High VPIN indicates increased\ninformed trading activity.\n\nFormula:\n    VPIN = Σ|V^B_τ - V^S_τ| / (n * V_bucket)\n\nWhere:\n    τ = volume bucket index\n    V^B_τ, V^S_τ = buy/sell volume in bucket τ\n    n = number of buckets in rolling window\n    V_bucket = fixed volume per bucket\n\nKey Findings:\n    \"VPIN reached historically high levels in the hours and days\n    prior to the Flash Crash of May 6, 2010.\"\n    - Easley, López de Prado, O'Hara (2012)\n\nBulk Volume Classification (BVC):\n    V^B = V * Φ((P_close - P_open) / σ)\n    V^S = V - V^B\n\nWhere Φ(·) = standard normal CDF\n\nCitation:\n    Easley, D., López de Prado, M., & O'Hara, M. (2012).\n    Review of Financial Studies, 25(5), 1457-1493.", "source": "core\\features\\academic_microstructure.py", "category": "volatility"}
{"instruction": "What is the KyleLambda class and how do I use it?", "input": "", "output": "The KyleLambda class:\n\nKyle's Lambda - Market Impact Coefficient.\n\nThe foundational model of market microstructure. Kyle (1985) shows\nthat informed traders optimally trade to minimize price impact,\nleading to a linear price impact function.\n\nModel:\n    P_n = P_{n-1} + λ * (x_n + u_n) + ε_n\n\nWhere:\n    λ = σ_v / (2σ_u)  # Price impact coefficient\n    σ_v = volatility of fundamental value\n    σ_u = noise trader volatility\n    x_n = informed trader order\n    u_n = noise trader order\n\nInterpretation:\n    \"Kyle's lambda measures the dollar change in price due to\n    a dollar change in order flow.\"\n\n    Higher λ = less liquid market, higher price impact\n\nCitation:\n    Kyle, A. S. (1985).\n    Econometrica, 53(6), 1315-1335.", "source": "core\\features\\academic_microstructure.py", "category": "volatility"}
{"instruction": "What is the AmihudIlliquidity class and how do I use it?", "input": "", "output": "The AmihudIlliquidity class:\n\nAmihud Illiquidity Measure.\n\nA simple and widely-used measure of price impact per unit volume.\n\nFormula:\n    ILLIQ_t = (1/D) * Σ |r_d| / DVOL_d\n\nWhere:\n    r_d = daily return\n    DVOL_d = daily dollar volume\n    D = number of days\n\nInterpretation:\n    Higher ILLIQ = less liquid, higher price impact\n\nCitation:\n    Amihud, Y. (2002).\n    Journal of Financial Markets, 5(1), 31-56.", "source": "core\\features\\academic_microstructure.py", "category": "volatility"}
{"instruction": "What is the RollSpread class and how do I use it?", "input": "", "output": "The RollSpread class:\n\nRoll Spread Estimator - Implicit Bid-Ask Spread.\n\nEstimates effective spread from price autocovariance, based on\nthe idea that bid-ask bounce creates negative serial correlation.\n\nFormula:\n    Spread = 2 * sqrt(-Cov(ΔP_t, ΔP_{t-1}))  if Cov < 0\n           = 0                                otherwise\n\nIntuition:\n    \"The bid-ask spread induces negative serial correlation in\n    transaction price changes.\"\n    - Roll (1984)\n\nCitation:\n    Roll, R. (1984).\n    Journal of Finance, 39(4), 1127-1139.", "source": "core\\features\\academic_microstructure.py", "category": "risk"}
{"instruction": "What is the AcademicMicrostructureFeatures class and how do I use it?", "input": "", "output": "The AcademicMicrostructureFeatures class:\n\nGenerate all academic microstructure features.\n\nCombines OFI, VPIN, Kyle Lambda, Amihud, and Roll spread\ninto a unified feature generator.", "source": "core\\features\\academic_microstructure.py", "category": "microstructure"}
{"instruction": "What is the formula for Generate Microstructure Features?", "input": "", "output": "Convenience function to generate microstructure features.\n\nCitations:\n- Cont et al. (2014) - Order Flow Imbalance\n- Easley et al. (2012) - VPIN\n- Kyle (1985) - Market Impact\n- Amihud (2002) - Illiquidity\n- Roll (1984) - Spread Estimation\n\nArgs:\n    df: DataFrame with price/volume data\n    **kwargs: Additional arguments\n\nReturns:\n    DataFrame with microstructure features", "source": "core\\features\\academic_microstructure.py", "category": "volatility"}
{"instruction": "Explain the Generate Microstructure Features function", "input": "", "output": "Function: generate_microstructure_features\n\nConvenience function to generate microstructure features.\n\nCitations:\n- Cont et al. (2014) - Order Flow Imbalance\n- Easley et al. (2012) - VPIN\n- Kyle (1985) - Market Impact\n- Amihud (2002) - Illiquidity\n- Roll (1984) - Spread Estimation\n\nArgs:\n    df: DataFrame with price/volume data\n    **kwargs: Additional arguments\n\nReturns:\n    DataFrame with microstructure features", "source": "core\\features\\academic_microstructure.py", "category": "volatility"}
{"instruction": "What is VPIN in quantitative trading?", "input": "", "output": "VPIN (Volume-Synchronized Probability of Informed Trading).\n\nImplementation details:\nConvenience function to generate microstructure features.\n\nCitations:\n- Cont et al. (2014) - Order Flow Imbalance\n- Easley et al. (2012) - VPIN\n- Kyle (1985) - Market Impact\n- Amihud (2002) - Illiquidity\n- Roll (1984) - Spread Estimation\n\nArgs:\n    df: DataFrame with price/volume data\n    **kwargs: Additional arguments\n\nReturns:\n    DataFrame with microstructure features", "source": "core\\features\\academic_microstructure.py", "category": "volatility"}
{"instruction": "Explain the Compute Ofi function", "input": "", "output": "Function: compute_ofi\n\nCompute Order Flow Imbalance per Cont et al. (2014).\n\nArgs:\n    bid_price: Best bid price series\n    ask_price: Best ask price series\n    bid_volume: Volume at best bid\n    ask_volume: Volume at best ask\n\nReturns:\n    OFI series", "source": "core\\features\\academic_microstructure.py", "category": "volatility"}
{"instruction": "What is OFI in quantitative trading?", "input": "", "output": "OFI (Order Flow Imbalance).\n\nImplementation details:\nCompute Order Flow Imbalance per Cont et al. (2014).\n\nArgs:\n    bid_price: Best bid price series\n    ask_price: Best ask price series\n    bid_volume: Volume at best bid\n    ask_volume: Volume at best ask\n\nReturns:\n    OFI series", "source": "core\\features\\academic_microstructure.py", "category": "volatility"}
{"instruction": "What is the formula for Compute Ofi From Trades?", "input": "", "output": "Compute OFI from trade data using Lee-Ready classification.\n\nLee, C.M.C., & Ready, M.J. (1991).\n\"Inferring Trade Direction from Intraday Data\"\nJournal of Finance, 46(2), 733-746.\n\nArgs:\n    price: Trade prices\n    volume: Trade volumes\n    bid: Best bid at trade time\n    ask: Best ask at trade time\n\nReturns:\n    OFI series (positive = buying pressure)", "source": "core\\features\\academic_microstructure.py", "category": "volatility"}
{"instruction": "Explain the Compute Ofi From Trades function", "input": "", "output": "Function: compute_ofi_from_trades\n\nCompute OFI from trade data using Lee-Ready classification.\n\nLee, C.M.C., & Ready, M.J. (1991).\n\"Inferring Trade Direction from Intraday Data\"\nJournal of Finance, 46(2), 733-746.\n\nArgs:\n    price: Trade prices\n    volume: Trade volumes\n    bid: Best bid at trade time\n    ask: Best ask at trade time\n\nReturns:\n    OFI series (positive = buying pressure)", "source": "core\\features\\academic_microstructure.py", "category": "volatility"}
{"instruction": "What is OFI in quantitative trading?", "input": "", "output": "OFI (Order Flow Imbalance).\n\nImplementation details:\nCompute OFI from trade data using Lee-Ready classification.\n\nLee, C.M.C., & Ready, M.J. (1991).\n\"Inferring Trade Direction from Intraday Data\"\nJournal of Finance, 46(2), 733-746.\n\nArgs:\n    price: Trade prices\n    volume: Trade volumes\n    bid: Best bid at trade time\n    ask: Best ask at trade time\n\nReturns:\n    OFI series (positive = buying pressure)", "source": "core\\features\\academic_microstructure.py", "category": "volatility"}
{"instruction": "What is the formula for Estimate Lambda?", "input": "", "output": "Estimate Kyle's lambda using OFI regression.\n\nΔP_t = λ * OFI_t + ε_t\n\nCont et al. (2014) show λ is inversely proportional to market depth:\n\"slope inversely proportional to the market depth\"\n\nArgs:\n    price_changes: Price change series\n    ofi: Order flow imbalance series\n    window: Rolling window for estimation\n\nReturns:\n    Rolling lambda estimates (price impact per unit OFI)", "source": "core\\features\\academic_microstructure.py", "category": "execution"}
{"instruction": "Explain the Estimate Lambda function", "input": "", "output": "Function: estimate_lambda\n\nEstimate Kyle's lambda using OFI regression.\n\nΔP_t = λ * OFI_t + ε_t\n\nCont et al. (2014) show λ is inversely proportional to market depth:\n\"slope inversely proportional to the market depth\"\n\nArgs:\n    price_changes: Price change series\n    ofi: Order flow imbalance series\n    window: Rolling window for estimation\n\nReturns:\n    Rolling lambda estimates (price impact per unit OFI)", "source": "core\\features\\academic_microstructure.py", "category": "execution"}
{"instruction": "What is OFI in quantitative trading?", "input": "", "output": "OFI (Order Flow Imbalance).\n\nImplementation details:\nEstimate Kyle's lambda using OFI regression.\n\nΔP_t = λ * OFI_t + ε_t\n\nCont et al. (2014) show λ is inversely proportional to market depth:\n\"slope inversely proportional to the market depth\"\n\nArgs:\n    price_changes: Price change series\n    ofi: Order flow imbalance series\n    window: Rolling window for estimation\n\nReturns:\n    Rolling lambda estimates (price impact per unit OFI)", "source": "core\\features\\academic_microstructure.py", "category": "execution"}
{"instruction": "What is the formula for Bulk Volume Classification?", "input": "", "output": "Bulk Volume Classification (BVC) per Easley et al. (2012a).\n\n\"They advocate a 'bulk volume' classification strategy,\nreferred to as BV-VPIN.\"\n\nArgs:\n    open_price: Opening prices\n    close_price: Closing prices\n    volume: Total volume\n    sigma: Volatility (if None, computed from returns)\n\nReturns:\n    Tuple of (buy_volume, sell_volume)", "source": "core\\features\\academic_microstructure.py", "category": "volatility"}
{"instruction": "Explain the Bulk Volume Classification function", "input": "", "output": "Function: bulk_volume_classification\n\nBulk Volume Classification (BVC) per Easley et al. (2012a).\n\n\"They advocate a 'bulk volume' classification strategy,\nreferred to as BV-VPIN.\"\n\nArgs:\n    open_price: Opening prices\n    close_price: Closing prices\n    volume: Total volume\n    sigma: Volatility (if None, computed from returns)\n\nReturns:\n    Tuple of (buy_volume, sell_volume)", "source": "core\\features\\academic_microstructure.py", "category": "volatility"}
{"instruction": "What is VPIN in quantitative trading?", "input": "", "output": "VPIN (Volume-Synchronized Probability of Informed Trading).\n\nImplementation details:\nBulk Volume Classification (BVC) per Easley et al. (2012a).\n\n\"They advocate a 'bulk volume' classification strategy,\nreferred to as BV-VPIN.\"\n\nArgs:\n    open_price: Opening prices\n    close_price: Closing prices\n    volume: Total volume\n    sigma: Volatility (if None, computed from returns)\n\nReturns:\n    Tuple of (buy_volume, sell_volume)", "source": "core\\features\\academic_microstructure.py", "category": "volatility"}
{"instruction": "What is the formula for Compute Vpin?", "input": "", "output": "Compute VPIN metric.\n\n\"VPIN captures the market dynamics in event time, i.e., equal\nincrements of trading volume rather than calendar time.\"\n- Easley et al. (2012)\n\nArgs:\n    buy_volume: Classified buy volume\n    sell_volume: Classified sell volume\n    bucket_size: Volume per bucket\n    n_buckets: Number of buckets in rolling window\n\nReturns:\n    VPIN series (0-1, higher = more toxic)", "source": "core\\features\\academic_microstructure.py", "category": "volatility"}
{"instruction": "Explain the Compute Vpin function", "input": "", "output": "Function: compute_vpin\n\nCompute VPIN metric.\n\n\"VPIN captures the market dynamics in event time, i.e., equal\nincrements of trading volume rather than calendar time.\"\n- Easley et al. (2012)\n\nArgs:\n    buy_volume: Classified buy volume\n    sell_volume: Classified sell volume\n    bucket_size: Volume per bucket\n    n_buckets: Number of buckets in rolling window\n\nReturns:\n    VPIN series (0-1, higher = more toxic)", "source": "core\\features\\academic_microstructure.py", "category": "volatility"}
{"instruction": "What is VPIN in quantitative trading?", "input": "", "output": "VPIN (Volume-Synchronized Probability of Informed Trading).\n\nImplementation details:\nCompute VPIN metric.\n\n\"VPIN captures the market dynamics in event time, i.e., equal\nincrements of trading volume rather than calendar time.\"\n- Easley et al. (2012)\n\nArgs:\n    buy_volume: Classified buy volume\n    sell_volume: Classified sell volume\n    bucket_size: Volume per bucket\n    n_buckets: Number of buckets in rolling window\n\nReturns:\n    VPIN series (0-1, higher = more toxic)", "source": "core\\features\\academic_microstructure.py", "category": "volatility"}
{"instruction": "Explain the Compute Vpin Fast function", "input": "", "output": "Function: compute_vpin_fast\n\nFast VPIN approximation for tick data without OHLC.\n\nUses tick rule for trade classification.\n\nArgs:\n    close: Price series\n    volume: Volume series\n    window: Rolling window\n\nReturns:\n    VPIN approximation", "source": "core\\features\\academic_microstructure.py", "category": "volatility"}
{"instruction": "What is VPIN in quantitative trading?", "input": "", "output": "VPIN (Volume-Synchronized Probability of Informed Trading).\n\nImplementation details:\nFast VPIN approximation for tick data without OHLC.\n\nUses tick rule for trade classification.\n\nArgs:\n    close: Price series\n    volume: Volume series\n    window: Rolling window\n\nReturns:\n    VPIN approximation", "source": "core\\features\\academic_microstructure.py", "category": "volatility"}
{"instruction": "What is the formula for Estimate Lambda Roll?", "input": "", "output": "Rolling estimation of Kyle's lambda.\n\nArgs:\n    price: Price series\n    order_flow: Signed order flow (positive = buying)\n    window: Rolling window\n\nReturns:\n    Rolling lambda estimates", "source": "core\\features\\academic_microstructure.py", "category": "general"}
{"instruction": "Explain the Estimate Lambda Roll function", "input": "", "output": "Function: estimate_lambda_roll\n\nRolling estimation of Kyle's lambda.\n\nArgs:\n    price: Price series\n    order_flow: Signed order flow (positive = buying)\n    window: Rolling window\n\nReturns:\n    Rolling lambda estimates", "source": "core\\features\\academic_microstructure.py", "category": "general"}
{"instruction": "What is the formula for Compute Market Depth?", "input": "", "output": "Market depth = 1 / λ (inverse of price impact).\n\n\"Market depth reflects the informativeness of the order flow\nand the size of trades by noise traders.\"\n- Kyle (1985)\n\nArgs:\n    lambda_: Kyle's lambda series\n\nReturns:\n    Market depth series", "source": "core\\features\\academic_microstructure.py", "category": "execution"}
{"instruction": "Explain the Compute Market Depth function", "input": "", "output": "Function: compute_market_depth\n\nMarket depth = 1 / λ (inverse of price impact).\n\n\"Market depth reflects the informativeness of the order flow\nand the size of trades by noise traders.\"\n- Kyle (1985)\n\nArgs:\n    lambda_: Kyle's lambda series\n\nReturns:\n    Market depth series", "source": "core\\features\\academic_microstructure.py", "category": "execution"}
{"instruction": "What is the formula for Compute Illiquidity?", "input": "", "output": "Compute Amihud illiquidity ratio.\n\nArgs:\n    returns: Return series\n    dollar_volume: Dollar volume (price * volume)\n    window: Rolling window\n\nReturns:\n    Illiquidity series (higher = less liquid)", "source": "core\\features\\academic_microstructure.py", "category": "volatility"}
{"instruction": "Explain the Compute Illiquidity function", "input": "", "output": "Function: compute_illiquidity\n\nCompute Amihud illiquidity ratio.\n\nArgs:\n    returns: Return series\n    dollar_volume: Dollar volume (price * volume)\n    window: Rolling window\n\nReturns:\n    Illiquidity series (higher = less liquid)", "source": "core\\features\\academic_microstructure.py", "category": "volatility"}
{"instruction": "Explain the Compute Spread function", "input": "", "output": "Function: compute_spread\n\nCompute Roll spread estimator.\n\nArgs:\n    price: Price series\n    window: Rolling window for covariance\n\nReturns:\n    Estimated spread series", "source": "core\\features\\academic_microstructure.py", "category": "risk"}
{"instruction": "Explain the Generate All function", "input": "", "output": "Function: generate_all\n\nGenerate all microstructure features.\n\nArgs:\n    df: DataFrame with OHLCV data\n    has_orderbook: Whether L2 orderbook data is available\n\nReturns:\n    DataFrame with microstructure features", "source": "core\\features\\academic_microstructure.py", "category": "microstructure"}
{"instruction": "Explain the purpose of Academic Regime Detection - Hidden Markov Models & Markov-Switching", "input": "", "output": "Academic Regime Detection - Hidden Markov Models & Markov-Switching\n====================================================================\n\nImplementations of market regime detection methods from econometrics\nand machine learning literature. These methods identify bull, bear,\nand neutral market states for adaptive trading.\n\nCITATIONS:\n----------\n\n1. MARKOV-SWITCHING MODELS\n   Hamilton, J.D. (1989).\n   \"A New Approach to the Economic Analysis of Nonstationary Time Series\n   and the Business Cycle\"\n   Econometrica, 57(2), 357-384.\n   DOI: 10.2307/1912559\n\n2. HIDDEN MARKOV MODELS FOR FINANCIAL DATA\n   Rydén, T., Teräsvirta, T., & Åsbrink, S. (1998).\n   \"Stylized Facts of Daily Return Series and the Hidden Markov Model\"\n   Journal of Applied Econometrics, 13(3), 217-244.\n\n3. REGIME-SWITCHING FACTOR INVESTING\n   Nystrup, P., Hansen, B.W., Madsen, H., & Lindström, E. (2016).\n   \"Detecting Change Points in VIX and S&P 500: A New Approach\n   to Dynamic Asset Allocation\"\n   Journal of Asset Management, 17(5), 361-374.\n\n4. HMM FOR FOREX TRENDS\n   Hassan, M.R., & Nath, B. (2005).\n   \"Stock Market Forecasting Using Hidden Markov Model: A New Approach\"\n   5th International Conference on Intelligent Systems Design and Applications.\n\n5. REGIME-BASED ASSET ALLOCATION\n   Ang, A., & Bekaert, G. (2002).\n   \"International Asset Allocation With Regime Shifts\"\n   Review of Financial Studies, 15(4), 1137-1187.\n   DOI: 10.1093/rfs/15.4.1137\n\n6. GAUSSIAN MIXTURE MODELS FOR REGIMES\n   Guidolin, M., & Timmermann, A. (2007).\n   \"Asset Allocation Under Multivariate Regime Switching\"\n   Journal of Economic Dynamics and Control, 31(11), 3503-3544.\n\nKEY CONCEPTS:\n-------------\n- Hidden States: Unobserved market regimes (Bull, Bear, Neutral)\n- Transition Matrix: Probability of switching between regimes\n- Emission Distribution: Return distribution in each regime\n- Viterbi Algorithm: Most likely state sequence\n- Forward-Backward: State probability estimation\n\nAPPLICABILITY: All methods are FOREX-NATIVE (regime detection is\nparticularly valuable in forex due to central bank interventions\nand macroeconomic regime shifts)", "source": "core\\features\\academic_regime.py", "category": "alpha"}
{"instruction": "What is the RegimeConfig class and how do I use it?", "input": "", "output": "The RegimeConfig class:\n\nConfiguration for regime detection.", "source": "core\\features\\academic_regime.py", "category": "regime"}
{"instruction": "What is the GaussianHMM class and how do I use it?", "input": "", "output": "The GaussianHMM class:\n\nGaussian Hidden Markov Model for Market Regime Detection.\n\nBased on Hamilton (1989) and subsequent applications to financial\nmarkets. The model assumes:\n- Hidden states represent market regimes (Bull, Bear, Neutral)\n- Each regime has a Gaussian return distribution\n- Regime transitions follow a Markov process\n\nModel:\n    P(S_t = j | S_{t-1} = i) = A_{ij}  # Transition probability\n    P(r_t | S_t = k) = N(μ_k, σ²_k)   # Emission distribution\n\nForward Algorithm:\n    α_t(j) = P(r_1,...,r_t, S_t=j)\n           = [Σ_i α_{t-1}(i) * A_{ij}] * P(r_t | S_t=j)\n\nKey Finding from Hamilton (1989):\n    \"The regime-switching model captures the business cycle dynamics\n    that are not captured by linear models.\"\n\nCitations:\n    Hamilton, J.D. (1989). Econometrica, 57(2), 357-384.\n    Rydén et al. (1998). Journal of Applied Econometrics, 13(3), 217-244.", "source": "core\\features\\academic_regime.py", "category": "regime"}
{"instruction": "What is the RegimeFeatures class and how do I use it?", "input": "", "output": "The RegimeFeatures class:\n\nGenerate regime-based features for trading.\n\nThese features can be used for:\n- Position sizing adjustment\n- Strategy selection\n- Risk management", "source": "core\\features\\academic_regime.py", "category": "risk"}
{"instruction": "What is the RollingRegimeDetector class and how do I use it?", "input": "", "output": "The RollingRegimeDetector class:\n\nRolling regime detection for real-time applications.\n\nRefits HMM on a rolling window to adapt to changing market dynamics.", "source": "core\\features\\academic_regime.py", "category": "regime"}
{"instruction": "What is the AcademicRegimeFeatures class and how do I use it?", "input": "", "output": "The AcademicRegimeFeatures class:\n\nGenerate all academic regime detection features.\n\nCombines HMM-based regime detection with derived features\nfor trading applications.", "source": "core\\features\\academic_regime.py", "category": "regime"}
{"instruction": "What is the formula for Generate Regime Features?", "input": "", "output": "Convenience function to generate regime detection features.\n\nCitations:\n- Hamilton (1989) - Markov-switching models\n- Rydén et al. (1998) - HMM for financial data\n- Ang & Bekaert (2002) - Regime-based asset allocation\n\nArgs:\n    df: DataFrame with price data\n    **kwargs: Additional arguments\n\nReturns:\n    DataFrame with regime features", "source": "core\\features\\academic_regime.py", "category": "regime"}
{"instruction": "Explain the Generate Regime Features function", "input": "", "output": "Function: generate_regime_features\n\nConvenience function to generate regime detection features.\n\nCitations:\n- Hamilton (1989) - Markov-switching models\n- Rydén et al. (1998) - HMM for financial data\n- Ang & Bekaert (2002) - Regime-based asset allocation\n\nArgs:\n    df: DataFrame with price data\n    **kwargs: Additional arguments\n\nReturns:\n    DataFrame with regime features", "source": "core\\features\\academic_regime.py", "category": "regime"}
{"instruction": "What is HMM in quantitative trading?", "input": "", "output": "HMM (Hidden Markov Model for regime detection).\n\nImplementation details:\nConvenience function to generate regime detection features.\n\nCitations:\n- Hamilton (1989) - Markov-switching models\n- Rydén et al. (1998) - HMM for financial data\n- Ang & Bekaert (2002) - Regime-based asset allocation\n\nArgs:\n    df: DataFrame with price data\n    **kwargs: Additional arguments\n\nReturns:\n    DataFrame with regime features", "source": "core\\features\\academic_regime.py", "category": "regime"}
{"instruction": "What is the formula for Fit?", "input": "", "output": "Fit HMM to return series using EM algorithm.\n\nThe EM algorithm alternates between:\n- E-step: Compute expected state occupancies\n- M-step: Update parameters (means, variances, transitions)\n\nArgs:\n    returns: Return series\n\nReturns:\n    self", "source": "core\\features\\academic_regime.py", "category": "risk"}
{"instruction": "Explain the Fit function", "input": "", "output": "Function: fit\n\nFit HMM to return series using EM algorithm.\n\nThe EM algorithm alternates between:\n- E-step: Compute expected state occupancies\n- M-step: Update parameters (means, variances, transitions)\n\nArgs:\n    returns: Return series\n\nReturns:\n    self", "source": "core\\features\\academic_regime.py", "category": "risk"}
{"instruction": "What is HMM in quantitative trading?", "input": "", "output": "HMM (Hidden Markov Model for regime detection).\n\nImplementation details:\nFit HMM to return series using EM algorithm.\n\nThe EM algorithm alternates between:\n- E-step: Compute expected state occupancies\n- M-step: Update parameters (means, variances, transitions)\n\nArgs:\n    returns: Return series\n\nReturns:\n    self", "source": "core\\features\\academic_regime.py", "category": "risk"}
{"instruction": "What is the formula for Predict?", "input": "", "output": "Predict most likely regime sequence (Viterbi algorithm).\n\nThe Viterbi algorithm finds the most likely state sequence:\nS* = argmax_S P(S | r_1, ..., r_T)\n\nArgs:\n    returns: Return series\n\nReturns:\n    Series of regime labels", "source": "core\\features\\academic_regime.py", "category": "regime"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nPredict most likely regime sequence (Viterbi algorithm).\n\nThe Viterbi algorithm finds the most likely state sequence:\nS* = argmax_S P(S | r_1, ..., r_T)\n\nArgs:\n    returns: Return series\n\nReturns:\n    Series of regime labels", "source": "core\\features\\academic_regime.py", "category": "regime"}
{"instruction": "What is the formula for Predict Proba?", "input": "", "output": "Compute probability of each regime (Forward-Backward algorithm).\n\nReturns P(S_t = k | r_1, ..., r_T) for each state k.\n\nArgs:\n    returns: Return series\n\nReturns:\n    DataFrame with regime probabilities", "source": "core\\features\\academic_regime.py", "category": "regime"}
{"instruction": "Explain the Predict Proba function", "input": "", "output": "Function: predict_proba\n\nCompute probability of each regime (Forward-Backward algorithm).\n\nReturns P(S_t = k | r_1, ..., r_T) for each state k.\n\nArgs:\n    returns: Return series\n\nReturns:\n    DataFrame with regime probabilities", "source": "core\\features\\academic_regime.py", "category": "regime"}
{"instruction": "Explain the Get Regime Statistics function", "input": "", "output": "Function: get_regime_statistics\n\nGet statistics for each regime.\n\nReturns:\n    Dictionary with mean, std, and label for each regime", "source": "core\\features\\academic_regime.py", "category": "regime"}
{"instruction": "Explain the Fit function", "input": "", "output": "Function: fit\n\nFit regime model to historical returns.\n\nArgs:\n    returns: Historical return series\n\nReturns:\n    self", "source": "core\\features\\academic_regime.py", "category": "regime"}
{"instruction": "What is the formula for Generate Features?", "input": "", "output": "Generate regime-based features.\n\nArgs:\n    returns: Return series\n\nReturns:\n    DataFrame with regime features", "source": "core\\features\\academic_regime.py", "category": "regime"}
{"instruction": "Explain the Generate Features function", "input": "", "output": "Function: generate_features\n\nGenerate regime-based features.\n\nArgs:\n    returns: Return series\n\nReturns:\n    DataFrame with regime features", "source": "core\\features\\academic_regime.py", "category": "regime"}
{"instruction": "Explain the Fit Predict function", "input": "", "output": "Function: fit_predict\n\nPerform rolling regime detection.\n\nArgs:\n    returns: Return series\n\nReturns:\n    DataFrame with regime predictions and features", "source": "core\\features\\academic_regime.py", "category": "regime"}
{"instruction": "Explain the Generate All function", "input": "", "output": "Function: generate_all\n\nGenerate all regime detection features.\n\nArgs:\n    df: DataFrame with price data\n    fit: Whether to fit the model (True) or use existing (False)\n\nReturns:\n    DataFrame with regime features", "source": "core\\features\\academic_regime.py", "category": "regime"}
{"instruction": "Explain the purpose of Academic Volatility Estimators - Peer-Reviewed Methods", "input": "", "output": "Academic Volatility Estimators - Peer-Reviewed Methods\n=======================================================\n\nImplementations of state-of-the-art volatility estimation and forecasting\nmethods from top finance and econometrics journals.\n\nCITATIONS:\n----------\n\n1. HAR-RV (Heterogeneous Autoregressive Realized Volatility)\n   Corsi, F. (2009).\n   \"A Simple Approximate Long-Memory Model of Realized Volatility\"\n   Journal of Financial Econometrics, 7(2), 174-196.\n   DOI: 10.1093/jjfinec/nbp001\n   SSRN: https://papers.ssrn.com/sol3/papers.cfm?abstract_id=1365738\n\n2. PARKINSON VOLATILITY\n   Parkinson, M. (1980).\n   \"The Extreme Value Method for Estimating the Variance of the Rate of Return\"\n   Journal of Business, 53(1), 61-65.\n   DOI: 10.1086/296071\n\n3. GARMAN-KLASS VOLATILITY\n   Garman, M.B., & Klass, M.J. (1980).\n   \"On the Estimation of Security Price Volatilities from Historical Data\"\n   Journal of Business, 53(1), 67-78.\n   DOI: 10.1086/296072\n\n4. ROGERS-SATCHELL VOLATILITY\n   Rogers, L.C.G., & Satchell, S.E. (1991).\n   \"Estimating Variance from High, Low and Closing Prices\"\n   Annals of Applied Probability, 1(4), 504-512.\n\n5. YANG-ZHANG VOLATILITY\n   Yang, D., & Zhang, Q. (2000).\n   \"Drift-Independent Volatility Estimation Based on High, Low, Open, and Close Prices\"\n   Journal of Business, 73(3), 477-492.\n   DOI: 10.1086/209650\n\n6. REALIZED VOLATILITY\n   Andersen, T.G., & Bollerslev, T. (1998).\n   \"Answering the Skeptics: Yes, Standard Volatility Models Do Provide Accurate Forecasts\"\n   International Economic Review, 39(4), 885-905.\n\n7. GARCH\n   Bollerslev, T. (1986).\n   \"Generalized Autoregressive Conditional Heteroskedasticity\"\n   Journal of Econometrics, 31(3), 307-327.\n   DOI: 10.1016/0304-4076(86)90063-1\n\n8. EGARCH (Exponential GARCH)\n   Nelson, D.B. (1991).\n   \"Conditional Heteroskedasticity in Asset Returns: A New Approach\"\n   Econometrica, 59(2), 347-370.\n\nEFFICIENCY COMPARISON (Parkinson 1980, Garman-Klass 1980):\n----------------------------------------------------------\n- Parkinson: 5.2x more efficient than close-to-close\n- Garman-Klass: 7.4x more efficient than close-to-close\n- Rogers-Satchell: Handles drift\n- Yang-Zhang: Handles overnight jumps + drift\n\nAPPLICABILITY: All methods are FOREX-NATIVE (24-hour market makes range-based\nestimators particularly valuable)", "source": "core\\features\\academic_volatility.py", "category": "volatility"}
{"instruction": "What is the VolatilityConfig class and how do I use it?", "input": "", "output": "The VolatilityConfig class:\n\nConfiguration for volatility calculations.", "source": "core\\features\\academic_volatility.py", "category": "volatility"}
{"instruction": "What is the RealizedVolatility class and how do I use it?", "input": "", "output": "The RealizedVolatility class:\n\nRealized Volatility Estimators.\n\nBased on Andersen & Bollerslev (1998):\n\"Standard volatility models do provide accurate forecasts\"\n\nFormula:\n    RV_t = sqrt(Σ r²_{t,i})\n\nWhere r_{t,i} are intraday returns.\n\nCitation:\n    Andersen, T.G., & Bollerslev, T. (1998).\n    International Economic Review, 39(4), 885-905.", "source": "core\\features\\academic_volatility.py", "category": "volatility"}
{"instruction": "What is the HARRV class and how do I use it?", "input": "", "output": "The HARRV class:\n\nHeterogeneous Autoregressive Realized Volatility (HAR-RV).\n\nThe HAR model captures multi-horizon volatility components through\ndaily, weekly, and monthly aggregations, reflecting heterogeneous\nmarket participants with different time horizons.\n\nFormula:\n    RV_{t+1}^{(d)} = β_0 + β_d·RV_t^{(d)} + β_w·RV_t^{(w)} + β_m·RV_t^{(m)} + ε\n\nWhere:\n    RV^{(d)} = daily realized volatility\n    RV^{(w)} = weekly average (5-day)\n    RV^{(m)} = monthly average (22-day)\n\nKey Finding:\n    \"The HAR model successfully achieves the purpose of reproducing\n    the main empirical features of financial returns (long memory,\n    fat tails, and self-similarity) in a very tractable and\n    parsimonious way.\"\n    - Corsi (2009)\n\nCitation:\n    Corsi, F. (2009).\n    Journal of Financial Econometrics, 7(2), 174-196.", "source": "core\\features\\academic_volatility.py", "category": "volatility"}
{"instruction": "What is the RangeBasedVolatility class and how do I use it?", "input": "", "output": "The RangeBasedVolatility class:\n\nRange-Based Volatility Estimators.\n\nThese estimators use OHLC prices and are theoretically 5-7x more\nefficient than close-to-close estimators.\n\nComparison (from Parkinson 1980, Garman-Klass 1980):\n- Close-to-close: efficiency = 1.0\n- Parkinson: efficiency = 5.2\n- Garman-Klass: efficiency = 7.4\n- Rogers-Satchell: handles drift\n- Yang-Zhang: handles overnight jumps\n\nCitations:\n    Parkinson (1980), Garman & Klass (1980),\n    Rogers & Satchell (1991), Yang & Zhang (2000)", "source": "core\\features\\academic_volatility.py", "category": "volatility"}
{"instruction": "What is the AcademicVolatilityFeatures class and how do I use it?", "input": "", "output": "The AcademicVolatilityFeatures class:\n\nGenerate all academic volatility features.\n\nCombines HAR-RV, range-based estimators, and derived features\ninto a unified feature generator.", "source": "core\\features\\academic_volatility.py", "category": "volatility"}
{"instruction": "What is the formula for Generate Volatility Features?", "input": "", "output": "Convenience function to generate volatility features.\n\nCitations:\n- Corsi (2009) - HAR-RV\n- Parkinson (1980) - Range volatility\n- Garman & Klass (1980) - OHLC volatility\n- Rogers & Satchell (1991) - Drift-independent\n- Yang & Zhang (2000) - Overnight jumps\n\nArgs:\n    df: DataFrame with OHLCV data\n    **kwargs: Additional arguments\n\nReturns:\n    DataFrame with volatility features", "source": "core\\features\\academic_volatility.py", "category": "volatility"}
{"instruction": "Explain the Generate Volatility Features function", "input": "", "output": "Function: generate_volatility_features\n\nConvenience function to generate volatility features.\n\nCitations:\n- Corsi (2009) - HAR-RV\n- Parkinson (1980) - Range volatility\n- Garman & Klass (1980) - OHLC volatility\n- Rogers & Satchell (1991) - Drift-independent\n- Yang & Zhang (2000) - Overnight jumps\n\nArgs:\n    df: DataFrame with OHLCV data\n    **kwargs: Additional arguments\n\nReturns:\n    DataFrame with volatility features", "source": "core\\features\\academic_volatility.py", "category": "volatility"}
{"instruction": "Explain the Compute Realized Vol function", "input": "", "output": "Function: compute_realized_vol\n\nCompute realized volatility from returns.\n\nArgs:\n    returns: Return series\n    window: Rolling window\n    annualize: Whether to annualize\n\nReturns:\n    Realized volatility series", "source": "core\\features\\academic_volatility.py", "category": "volatility"}
{"instruction": "What is the formula for Compute Har Components?", "input": "", "output": "Compute HAR components (daily, weekly, monthly).\n\n\"Three primary volatility components can be identified: the\nshort-term traders with daily or higher trading frequency,\nthe medium-term investors who typically rebalance their\npositions weekly, and the long-term agents with a\ncharacteristic time of one or more months.\"\n- Corsi (2009)\n\nArgs:\n    rv_daily: Daily realized volatility series\n\nReturns:\n    DataFrame with RV_d, RV_w, RV_m columns", "source": "core\\features\\academic_volatility.py", "category": "volatility"}
{"instruction": "Explain the Compute Har Components function", "input": "", "output": "Function: compute_har_components\n\nCompute HAR components (daily, weekly, monthly).\n\n\"Three primary volatility components can be identified: the\nshort-term traders with daily or higher trading frequency,\nthe medium-term investors who typically rebalance their\npositions weekly, and the long-term agents with a\ncharacteristic time of one or more months.\"\n- Corsi (2009)\n\nArgs:\n    rv_daily: Daily realized volatility series\n\nReturns:\n    DataFrame with RV_d, RV_w, RV_m columns", "source": "core\\features\\academic_volatility.py", "category": "volatility"}
{"instruction": "What is the formula for Fit?", "input": "", "output": "Fit HAR-RV model using OLS.\n\nArgs:\n    rv_daily: Daily realized volatility\n    forecast_horizon: Forecast horizon (default: 1 day)\n\nReturns:\n    Dictionary of fitted coefficients", "source": "core\\features\\academic_volatility.py", "category": "volatility"}
{"instruction": "Explain the Fit function", "input": "", "output": "Function: fit\n\nFit HAR-RV model using OLS.\n\nArgs:\n    rv_daily: Daily realized volatility\n    forecast_horizon: Forecast horizon (default: 1 day)\n\nReturns:\n    Dictionary of fitted coefficients", "source": "core\\features\\academic_volatility.py", "category": "volatility"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nForecast volatility using fitted HAR model.\n\nArgs:\n    rv_daily: Daily realized volatility\n\nReturns:\n    Volatility forecast series", "source": "core\\features\\academic_volatility.py", "category": "volatility"}
{"instruction": "What is the formula for Parkinson?", "input": "", "output": "Parkinson (1980) Range Volatility Estimator.\n\nFormula:\n    σ²_P = (1/4ln(2)) * (H - L)²\n\nWhere H, L are log high/low prices.\n\n\"The extreme value method for estimating the variance of the\nrate of return of a common stock.\"\n- Parkinson (1980)\n\nEfficiency: 5.2x more efficient than close-to-close\n\nCitation:\n    Parkinson, M. (1980).\n    Journal of Business, 53(1), 61-65.\n\nArgs:\n    high: High prices\n    low: Low prices\n    window: Rolling window\n    annualize: Whether to annualize\n\nReturns:\n    Volatility series", "source": "core\\features\\academic_volatility.py", "category": "volatility"}
{"instruction": "Explain the Parkinson function", "input": "", "output": "Function: parkinson\n\nParkinson (1980) Range Volatility Estimator.\n\nFormula:\n    σ²_P = (1/4ln(2)) * (H - L)²\n\nWhere H, L are log high/low prices.\n\n\"The extreme value method for estimating the variance of the\nrate of return of a common stock.\"\n- Parkinson (1980)\n\nEfficiency: 5.2x more efficient than close-to-close\n\nCitation:\n    Parkinson, M. (1980).\n    Journal of Business, 53(1), 61-65.\n\nArgs:\n    high: High prices\n    low: Low prices\n    window: Rolling window\n    annualize: Whether to annualize\n\nReturns:\n    Volatility series", "source": "core\\features\\academic_volatility.py", "category": "volatility"}
{"instruction": "What is the formula for Garman Klass?", "input": "", "output": "Garman-Klass (1980) Volatility Estimator.\n\nFormula:\n    σ²_GK = 0.5*(H-L)² - (2ln(2)-1)*(C-O)²\n\nWhere H, L, O, C are log prices.\n\n\"On the estimation of security price volatilities from\nhistorical data.\"\n- Garman & Klass (1980)\n\nEfficiency: 7.4x more efficient than close-to-close\nAssumption: No drift, continuous prices\n\nCitation:\n    Garman, M.B., & Klass, M.J. (1980).\n    Journal of Business, 53(1), 67-78.\n\nArgs:\n    open_: Open prices\n    high: High prices\n    low: Low prices\n    close: Close prices\n    window: Rolling window\n    annualize: Whether to annualize\n\nReturns:\n    Volatility series", "source": "core\\features\\academic_volatility.py", "category": "volatility"}
{"instruction": "Explain the Garman Klass function", "input": "", "output": "Function: garman_klass\n\nGarman-Klass (1980) Volatility Estimator.\n\nFormula:\n    σ²_GK = 0.5*(H-L)² - (2ln(2)-1)*(C-O)²\n\nWhere H, L, O, C are log prices.\n\n\"On the estimation of security price volatilities from\nhistorical data.\"\n- Garman & Klass (1980)\n\nEfficiency: 7.4x more efficient than close-to-close\nAssumption: No drift, continuous prices\n\nCitation:\n    Garman, M.B., & Klass, M.J. (1980).\n    Journal of Business, 53(1), 67-78.\n\nArgs:\n    open_: Open prices\n    high: High prices\n    low: Low prices\n    close: Close prices\n    window: Rolling window\n    annualize: Whether to annualize\n\nReturns:\n    Volatility series", "source": "core\\features\\academic_volatility.py", "category": "volatility"}
{"instruction": "What is the formula for Rogers Satchell?", "input": "", "output": "Rogers-Satchell (1991) Volatility Estimator.\n\nFormula:\n    σ²_RS = (H-C)*(H-O) + (L-C)*(L-O)\n\nWhere H, L, O, C are log prices.\n\nKey Advantage: Handles drift (non-zero mean returns)\n\n\"Rogers and Satchell (1991) proposed a formula that allows\nfor drifts.\"\n- Yang & Zhang (2000)\n\nCitation:\n    Rogers, L.C.G., & Satchell, S.E. (1991).\n    Annals of Applied Probability, 1(4), 504-512.\n\nArgs:\n    open_: Open prices\n    high: High prices\n    low: Low prices\n    close: Close prices\n    window: Rolling window\n    annualize: Whether to annualize\n\nReturns:\n    Volatility series", "source": "core\\features\\academic_volatility.py", "category": "volatility"}
{"instruction": "Explain the Rogers Satchell function", "input": "", "output": "Function: rogers_satchell\n\nRogers-Satchell (1991) Volatility Estimator.\n\nFormula:\n    σ²_RS = (H-C)*(H-O) + (L-C)*(L-O)\n\nWhere H, L, O, C are log prices.\n\nKey Advantage: Handles drift (non-zero mean returns)\n\n\"Rogers and Satchell (1991) proposed a formula that allows\nfor drifts.\"\n- Yang & Zhang (2000)\n\nCitation:\n    Rogers, L.C.G., & Satchell, S.E. (1991).\n    Annals of Applied Probability, 1(4), 504-512.\n\nArgs:\n    open_: Open prices\n    high: High prices\n    low: Low prices\n    close: Close prices\n    window: Rolling window\n    annualize: Whether to annualize\n\nReturns:\n    Volatility series", "source": "core\\features\\academic_volatility.py", "category": "volatility"}
{"instruction": "What is the formula for Yang Zhang?", "input": "", "output": "Yang-Zhang (2000) Volatility Estimator.\n\nFormula:\n    σ²_YZ = σ²_overnight + k*σ²_open + (1-k)*σ²_RS\n\nWhere:\n    k = 0.34 / (1.34 + (n+1)/(n-1))\n    σ²_overnight = Var(log(O_t/C_{t-1}))\n    σ²_open = Var(log(C_t/O_t))\n    σ²_RS = Rogers-Satchell variance\n\nKey Advantage: Handles overnight jumps AND drift\n\n\"Yang and Zhang (2000) published a formula that is unbiased,\ndrift independent, and consistent in dealing with opening\njumps; this latter feature is unique among the formulas examined.\"\n- Bali & Weinbaum (2005)\n\nCitation:\n    Yang, D., & Zhang, Q. (2000).\n    Journal of Business, 73(3), 477-492.\n\nArgs:\n    open_: Open prices\n    high: High prices\n    low: Low prices\n    close: Close prices\n    window: Rolling window\n    annualize: Whether to annualize\n\nReturns:\n    Volatility series", "source": "core\\features\\academic_volatility.py", "category": "volatility"}
{"instruction": "Explain the Yang Zhang function", "input": "", "output": "Function: yang_zhang\n\nYang-Zhang (2000) Volatility Estimator.\n\nFormula:\n    σ²_YZ = σ²_overnight + k*σ²_open + (1-k)*σ²_RS\n\nWhere:\n    k = 0.34 / (1.34 + (n+1)/(n-1))\n    σ²_overnight = Var(log(O_t/C_{t-1}))\n    σ²_open = Var(log(C_t/O_t))\n    σ²_RS = Rogers-Satchell variance\n\nKey Advantage: Handles overnight jumps AND drift\n\n\"Yang and Zhang (2000) published a formula that is unbiased,\ndrift independent, and consistent in dealing with opening\njumps; this latter feature is unique among the formulas examined.\"\n- Bali & Weinbaum (2005)\n\nCitation:\n    Yang, D., & Zhang, Q. (2000).\n    Journal of Business, 73(3), 477-492.\n\nArgs:\n    open_: Open prices\n    high: High prices\n    low: Low prices\n    close: Close prices\n    window: Rolling window\n    annualize: Whether to annualize\n\nReturns:\n    Volatility series", "source": "core\\features\\academic_volatility.py", "category": "volatility"}
{"instruction": "What is the formula for Close To Close?", "input": "", "output": "Simple close-to-close volatility (baseline).\n\nFormula:\n    σ = std(log(C_t/C_{t-1}))\n\nUsed as baseline for efficiency comparison.\n\nArgs:\n    close: Close prices\n    window: Rolling window\n    annualize: Whether to annualize\n\nReturns:\n    Volatility series", "source": "core\\features\\academic_volatility.py", "category": "volatility"}
{"instruction": "Explain the Close To Close function", "input": "", "output": "Function: close_to_close\n\nSimple close-to-close volatility (baseline).\n\nFormula:\n    σ = std(log(C_t/C_{t-1}))\n\nUsed as baseline for efficiency comparison.\n\nArgs:\n    close: Close prices\n    window: Rolling window\n    annualize: Whether to annualize\n\nReturns:\n    Volatility series", "source": "core\\features\\academic_volatility.py", "category": "volatility"}
{"instruction": "Explain the Generate All function", "input": "", "output": "Function: generate_all\n\nGenerate all volatility features.\n\nArgs:\n    df: DataFrame with OHLCV data\n\nReturns:\n    DataFrame with volatility features", "source": "core\\features\\academic_volatility.py", "category": "volatility"}
{"instruction": "What is the source paper for this technique?", "input": "", "output": "The source is: 101 Formulaic Alphas. ", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the source paper for this technique?", "input": "", "output": "The source is: https://arxiv.org/abs/1601.00991. ", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the source paper for research paper?", "input": "", "output": "The source is: arXiv:1601.00991. ", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the purpose of WorldQuant Alpha101 - Complete Implementation", "input": "", "output": "WorldQuant Alpha101 - Complete Implementation\n==============================================\nAll 101 formulaic alphas from the WorldQuant paper.\n\nPaper: \"101 Formulaic Alphas\" by Zura Kakushadze (2016)\nSource: https://arxiv.org/abs/1601.00991\n\nOriginal designed for equities, adapted here for forex.\nFor forex: volume = tick count or spread changes.", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the Alpha101Complete class and how do I use it?", "input": "", "output": "The Alpha101Complete class:\n\nComplete implementation of all 101 WorldQuant alphas.\n\nUsage:\n    alpha = Alpha101Complete()\n    df = alpha.generate_all_alphas(ohlcv_data)", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Show me a code example for Alpha101Complete", "input": "", "output": "alpha = Alpha101Complete()\n    df = alpha.generate_all_alphas(ohlcv_data)", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Rank?", "input": "", "output": "Cross-sectional rank (percentile).", "source": "core\\features\\alpha101.py", "category": "general"}
{"instruction": "Explain the Rank function", "input": "", "output": "Function: rank\n\nCross-sectional rank (percentile).", "source": "core\\features\\alpha101.py", "category": "general"}
{"instruction": "Explain the Delta function", "input": "", "output": "Function: delta\n\nDifference from d periods ago.", "source": "core\\features\\alpha101.py", "category": "general"}
{"instruction": "Explain the Delay function", "input": "", "output": "Function: delay\n\nLag by d periods.", "source": "core\\features\\alpha101.py", "category": "general"}
{"instruction": "Explain the Correlation function", "input": "", "output": "Function: correlation\n\nRolling correlation.", "source": "core\\features\\alpha101.py", "category": "general"}
{"instruction": "Explain the Covariance function", "input": "", "output": "Function: covariance\n\nRolling covariance.", "source": "core\\features\\alpha101.py", "category": "risk"}
{"instruction": "Explain the Scale function", "input": "", "output": "Function: scale\n\nScale to sum to a.", "source": "core\\features\\alpha101.py", "category": "general"}
{"instruction": "What is the formula for Ts Rank?", "input": "", "output": "Time-series rank over d periods.", "source": "core\\features\\alpha101.py", "category": "general"}
{"instruction": "Explain the Ts Rank function", "input": "", "output": "Function: ts_rank\n\nTime-series rank over d periods.", "source": "core\\features\\alpha101.py", "category": "general"}
{"instruction": "Explain the Ts Max function", "input": "", "output": "Function: ts_max\n\nRolling maximum.", "source": "core\\features\\alpha101.py", "category": "general"}
{"instruction": "Explain the Ts Min function", "input": "", "output": "Function: ts_min\n\nRolling minimum.", "source": "core\\features\\alpha101.py", "category": "general"}
{"instruction": "Explain the Ts Argmax function", "input": "", "output": "Function: ts_argmax\n\nDays since maximum.", "source": "core\\features\\alpha101.py", "category": "general"}
{"instruction": "Explain the Ts Argmin function", "input": "", "output": "Function: ts_argmin\n\nDays since minimum.", "source": "core\\features\\alpha101.py", "category": "general"}
{"instruction": "Explain the Ts Sum function", "input": "", "output": "Function: ts_sum\n\nRolling sum.", "source": "core\\features\\alpha101.py", "category": "general"}
{"instruction": "Explain the Ts Product function", "input": "", "output": "Function: ts_product\n\nRolling product.", "source": "core\\features\\alpha101.py", "category": "general"}
{"instruction": "Explain the Stddev function", "input": "", "output": "Function: stddev\n\nRolling standard deviation.", "source": "core\\features\\alpha101.py", "category": "general"}
{"instruction": "Explain the Decay Linear function", "input": "", "output": "Function: decay_linear\n\nLinear decay weighted average.", "source": "core\\features\\alpha101.py", "category": "general"}
{"instruction": "Explain the Sign function", "input": "", "output": "Function: sign\n\nSign function.", "source": "core\\features\\alpha101.py", "category": "general"}
{"instruction": "Explain the Log function", "input": "", "output": "Function: log\n\nNatural log.", "source": "core\\features\\alpha101.py", "category": "general"}
{"instruction": "Explain the Abs  function", "input": "", "output": "Function: abs_\n\nAbsolute value.", "source": "core\\features\\alpha101.py", "category": "general"}
{"instruction": "Explain the Adv function", "input": "", "output": "Function: adv\n\nAverage daily volume.", "source": "core\\features\\alpha101.py", "category": "volatility"}
{"instruction": "What is the formula for Alpha 1?", "input": "", "output": "(rank(Ts_ArgMax(SignedPower(((returns < 0) ? stddev(returns, 20) : close), 2.), 5)) - 0.5)", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 1 function", "input": "", "output": "Function: alpha001\n\n(rank(Ts_ArgMax(SignedPower(((returns < 0) ? stddev(returns, 20) : close), 2.), 5)) - 0.5)", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 2?", "input": "", "output": "(-1 * correlation(rank(delta(log(volume), 2)), rank(((close - open) / open)), 6))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 2 function", "input": "", "output": "Function: alpha002\n\n(-1 * correlation(rank(delta(log(volume), 2)), rank(((close - open) / open)), 6))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 3?", "input": "", "output": "(-1 * correlation(rank(open), rank(volume), 10))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 3 function", "input": "", "output": "Function: alpha003\n\n(-1 * correlation(rank(open), rank(volume), 10))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 4?", "input": "", "output": "(-1 * Ts_Rank(rank(low), 9))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 4 function", "input": "", "output": "Function: alpha004\n\n(-1 * Ts_Rank(rank(low), 9))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 5?", "input": "", "output": "(rank((open - (sum(vwap, 10) / 10))) * (-1 * abs(rank((close - vwap)))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 5 function", "input": "", "output": "Function: alpha005\n\n(rank((open - (sum(vwap, 10) / 10))) * (-1 * abs(rank((close - vwap)))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is VWAP in quantitative trading?", "input": "", "output": "VWAP (Volume-Weighted Average Price execution).\n\nImplementation details:\n(rank((open - (sum(vwap, 10) / 10))) * (-1 * abs(rank((close - vwap)))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 6?", "input": "", "output": "(-1 * correlation(open, volume, 10))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 6 function", "input": "", "output": "Function: alpha006\n\n(-1 * correlation(open, volume, 10))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 7?", "input": "", "output": "((adv20 < volume) ? ((-1 * ts_rank(abs(delta(close, 7)), 60)) * sign(delta(close, 7))) : (-1 * 1))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 7 function", "input": "", "output": "Function: alpha007\n\n((adv20 < volume) ? ((-1 * ts_rank(abs(delta(close, 7)), 60)) * sign(delta(close, 7))) : (-1 * 1))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 8?", "input": "", "output": "(-1 * rank(((sum(open, 5) * sum(returns, 5)) - delay((sum(open, 5) * sum(returns, 5)), 10))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 8 function", "input": "", "output": "Function: alpha008\n\n(-1 * rank(((sum(open, 5) * sum(returns, 5)) - delay((sum(open, 5) * sum(returns, 5)), 10))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 9?", "input": "", "output": "((0 < ts_min(delta(close, 1), 5)) ? delta(close, 1) : ((ts_max(delta(close, 1), 5) < 0) ? delta(close, 1) : (-1 * delta(close, 1))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 9 function", "input": "", "output": "Function: alpha009\n\n((0 < ts_min(delta(close, 1), 5)) ? delta(close, 1) : ((ts_max(delta(close, 1), 5) < 0) ? delta(close, 1) : (-1 * delta(close, 1))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 10?", "input": "", "output": "rank(((0 < ts_min(delta(close, 1), 4)) ? delta(close, 1) : ((ts_max(delta(close, 1), 4) < 0) ? delta(close, 1) : (-1 * delta(close, 1)))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 10 function", "input": "", "output": "Function: alpha010\n\nrank(((0 < ts_min(delta(close, 1), 4)) ? delta(close, 1) : ((ts_max(delta(close, 1), 4) < 0) ? delta(close, 1) : (-1 * delta(close, 1)))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 11?", "input": "", "output": "((rank(ts_max((vwap - close), 3)) + rank(ts_min((vwap - close), 3))) * rank(delta(volume, 3)))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 11 function", "input": "", "output": "Function: alpha011\n\n((rank(ts_max((vwap - close), 3)) + rank(ts_min((vwap - close), 3))) * rank(delta(volume, 3)))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is VWAP in quantitative trading?", "input": "", "output": "VWAP (Volume-Weighted Average Price execution).\n\nImplementation details:\n((rank(ts_max((vwap - close), 3)) + rank(ts_min((vwap - close), 3))) * rank(delta(volume, 3)))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 12?", "input": "", "output": "(sign(delta(volume, 1)) * (-1 * delta(close, 1)))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 12 function", "input": "", "output": "Function: alpha012\n\n(sign(delta(volume, 1)) * (-1 * delta(close, 1)))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 13?", "input": "", "output": "(-1 * rank(covariance(rank(close), rank(volume), 5)))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 13 function", "input": "", "output": "Function: alpha013\n\n(-1 * rank(covariance(rank(close), rank(volume), 5)))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 14?", "input": "", "output": "((-1 * rank(delta(returns, 3))) * correlation(open, volume, 10))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 14 function", "input": "", "output": "Function: alpha014\n\n((-1 * rank(delta(returns, 3))) * correlation(open, volume, 10))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 15?", "input": "", "output": "(-1 * sum(rank(correlation(rank(high), rank(volume), 3)), 3))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 15 function", "input": "", "output": "Function: alpha015\n\n(-1 * sum(rank(correlation(rank(high), rank(volume), 3)), 3))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 16?", "input": "", "output": "(-1 * rank(covariance(rank(high), rank(volume), 5)))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 16 function", "input": "", "output": "Function: alpha016\n\n(-1 * rank(covariance(rank(high), rank(volume), 5)))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 17?", "input": "", "output": "(((-1 * rank(ts_rank(close, 10))) * rank(delta(delta(close, 1), 1))) * rank(ts_rank((volume / adv20), 5)))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 17 function", "input": "", "output": "Function: alpha017\n\n(((-1 * rank(ts_rank(close, 10))) * rank(delta(delta(close, 1), 1))) * rank(ts_rank((volume / adv20), 5)))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 18?", "input": "", "output": "(-1 * rank(((stddev(abs((close - open)), 5) + (close - open)) + correlation(close, open, 10))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 18 function", "input": "", "output": "Function: alpha018\n\n(-1 * rank(((stddev(abs((close - open)), 5) + (close - open)) + correlation(close, open, 10))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 19?", "input": "", "output": "((-1 * sign(((close - delay(close, 7)) + delta(close, 7)))) * (1 + rank((1 + sum(returns, 250)))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 19 function", "input": "", "output": "Function: alpha019\n\n((-1 * sign(((close - delay(close, 7)) + delta(close, 7)))) * (1 + rank((1 + sum(returns, 250)))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 20?", "input": "", "output": "(((-1 * rank((open - delay(high, 1)))) * rank((open - delay(close, 1)))) * rank((open - delay(low, 1))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 20 function", "input": "", "output": "Function: alpha020\n\n(((-1 * rank((open - delay(high, 1)))) * rank((open - delay(close, 1)))) * rank((open - delay(low, 1))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 21?", "input": "", "output": "((((sum(close, 8) / 8) + stddev(close, 8)) < (sum(close, 2) / 2)) ? (-1 * 1) : (((sum(close, 2) / 2) < ((sum(close, 8) / 8) - stddev(close, 8))) ? 1 : (((1 < (volume / adv20)) | ((volume / adv20) == 1)) ? 1 : (-1 * 1))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 21 function", "input": "", "output": "Function: alpha021\n\n((((sum(close, 8) / 8) + stddev(close, 8)) < (sum(close, 2) / 2)) ? (-1 * 1) : (((sum(close, 2) / 2) < ((sum(close, 8) / 8) - stddev(close, 8))) ? 1 : (((1 < (volume / adv20)) | ((volume / adv20) == 1)) ? 1 : (-1 * 1))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 22?", "input": "", "output": "(-1 * (delta(correlation(high, volume, 5), 5) * rank(stddev(close, 20))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 22 function", "input": "", "output": "Function: alpha022\n\n(-1 * (delta(correlation(high, volume, 5), 5) * rank(stddev(close, 20))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 23?", "input": "", "output": "(((sum(high, 20) / 20) < high) ? (-1 * delta(high, 2)) : 0)", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 23 function", "input": "", "output": "Function: alpha023\n\n(((sum(high, 20) / 20) < high) ? (-1 * delta(high, 2)) : 0)", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 24?", "input": "", "output": "((((delta((sum(close, 100) / 100), 100) / delay(close, 100)) < 0.05) | ((delta((sum(close, 100) / 100), 100) / delay(close, 100)) == 0.05)) ? (-1 * (close - ts_min(close, 100))) : (-1 * delta(close, 3)))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 24 function", "input": "", "output": "Function: alpha024\n\n((((delta((sum(close, 100) / 100), 100) / delay(close, 100)) < 0.05) | ((delta((sum(close, 100) / 100), 100) / delay(close, 100)) == 0.05)) ? (-1 * (close - ts_min(close, 100))) : (-1 * delta(close, 3)))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 25?", "input": "", "output": "rank(((((-1 * returns) * adv20) * vwap) * (high - close)))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 25 function", "input": "", "output": "Function: alpha025\n\nrank(((((-1 * returns) * adv20) * vwap) * (high - close)))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is VWAP in quantitative trading?", "input": "", "output": "VWAP (Volume-Weighted Average Price execution).\n\nImplementation details:\nrank(((((-1 * returns) * adv20) * vwap) * (high - close)))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 26?", "input": "", "output": "(-1 * ts_max(correlation(ts_rank(volume, 5), ts_rank(high, 5), 5), 3))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 26 function", "input": "", "output": "Function: alpha026\n\n(-1 * ts_max(correlation(ts_rank(volume, 5), ts_rank(high, 5), 5), 3))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 27?", "input": "", "output": "((0.5 < rank((sum(correlation(rank(volume), rank(vwap), 6), 2) / 2.0))) ? (-1 * 1) : 1)", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 27 function", "input": "", "output": "Function: alpha027\n\n((0.5 < rank((sum(correlation(rank(volume), rank(vwap), 6), 2) / 2.0))) ? (-1 * 1) : 1)", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is VWAP in quantitative trading?", "input": "", "output": "VWAP (Volume-Weighted Average Price execution).\n\nImplementation details:\n((0.5 < rank((sum(correlation(rank(volume), rank(vwap), 6), 2) / 2.0))) ? (-1 * 1) : 1)", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 28?", "input": "", "output": "scale(((correlation(adv20, low, 5) + ((high + low) / 2)) - close))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 28 function", "input": "", "output": "Function: alpha028\n\nscale(((correlation(adv20, low, 5) + ((high + low) / 2)) - close))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 29?", "input": "", "output": "(min(product(rank(rank(scale(log(sum(ts_min(rank(rank((-1 * rank(delta((close - 1), 5))))), 2), 1))))), 1), 5) + ts_rank(delay((-1 * returns), 6), 5))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 29 function", "input": "", "output": "Function: alpha029\n\n(min(product(rank(rank(scale(log(sum(ts_min(rank(rank((-1 * rank(delta((close - 1), 5))))), 2), 1))))), 1), 5) + ts_rank(delay((-1 * returns), 6), 5))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 30?", "input": "", "output": "(((1.0 - rank(((sign((close - delay(close, 1))) + sign((delay(close, 1) - delay(close, 2)))) + sign((delay(close, 2) - delay(close, 3)))))) * sum(volume, 5)) / sum(volume, 20))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 30 function", "input": "", "output": "Function: alpha030\n\n(((1.0 - rank(((sign((close - delay(close, 1))) + sign((delay(close, 1) - delay(close, 2)))) + sign((delay(close, 2) - delay(close, 3)))))) * sum(volume, 5)) / sum(volume, 20))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 31?", "input": "", "output": "((rank(rank(rank(decay_linear((-1 * rank(rank(delta(close, 10)))), 10)))) + rank((-1 * delta(close, 3)))) + sign(scale(correlation(adv20, low, 12))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 31 function", "input": "", "output": "Function: alpha031\n\n((rank(rank(rank(decay_linear((-1 * rank(rank(delta(close, 10)))), 10)))) + rank((-1 * delta(close, 3)))) + sign(scale(correlation(adv20, low, 12))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 32?", "input": "", "output": "(scale(((sum(close, 7) / 7) - close)) + (20 * scale(correlation(vwap, delay(close, 5), 230))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 32 function", "input": "", "output": "Function: alpha032\n\n(scale(((sum(close, 7) / 7) - close)) + (20 * scale(correlation(vwap, delay(close, 5), 230))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is VWAP in quantitative trading?", "input": "", "output": "VWAP (Volume-Weighted Average Price execution).\n\nImplementation details:\n(scale(((sum(close, 7) / 7) - close)) + (20 * scale(correlation(vwap, delay(close, 5), 230))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 33?", "input": "", "output": "rank((-1 * ((1 - (open / close))^1)))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 33 function", "input": "", "output": "Function: alpha033\n\nrank((-1 * ((1 - (open / close))^1)))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 34?", "input": "", "output": "rank(((1 - rank((stddev(returns, 2) / stddev(returns, 5)))) + (1 - rank(delta(close, 1)))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 34 function", "input": "", "output": "Function: alpha034\n\nrank(((1 - rank((stddev(returns, 2) / stddev(returns, 5)))) + (1 - rank(delta(close, 1)))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 35?", "input": "", "output": "((Ts_Rank(volume, 32) * (1 - Ts_Rank(((close + high) - low), 16))) * (1 - Ts_Rank(returns, 32)))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 35 function", "input": "", "output": "Function: alpha035\n\n((Ts_Rank(volume, 32) * (1 - Ts_Rank(((close + high) - low), 16))) * (1 - Ts_Rank(returns, 32)))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 36?", "input": "", "output": "Long formula - simplified correlation-based signal", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 36 function", "input": "", "output": "Function: alpha036\n\nLong formula - simplified correlation-based signal", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 37?", "input": "", "output": "(rank(correlation(delay((open - close), 1), close, 200)) + rank((open - close)))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 37 function", "input": "", "output": "Function: alpha037\n\n(rank(correlation(delay((open - close), 1), close, 200)) + rank((open - close)))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 38?", "input": "", "output": "((-1 * rank(Ts_Rank(close, 10))) * rank((close / open)))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 38 function", "input": "", "output": "Function: alpha038\n\n((-1 * rank(Ts_Rank(close, 10))) * rank((close / open)))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 39?", "input": "", "output": "((-1 * rank((delta(close, 7) * (1 - rank(decay_linear((volume / adv20), 9)))))) * (1 + rank(sum(returns, 250))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 39 function", "input": "", "output": "Function: alpha039\n\n((-1 * rank((delta(close, 7) * (1 - rank(decay_linear((volume / adv20), 9)))))) * (1 + rank(sum(returns, 250))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 40?", "input": "", "output": "((-1 * rank(stddev(high, 10))) * correlation(high, volume, 10))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 40 function", "input": "", "output": "Function: alpha040\n\n((-1 * rank(stddev(high, 10))) * correlation(high, volume, 10))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 41?", "input": "", "output": "(((high * low)^0.5) - vwap)", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 41 function", "input": "", "output": "Function: alpha041\n\n(((high * low)^0.5) - vwap)", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is VWAP in quantitative trading?", "input": "", "output": "VWAP (Volume-Weighted Average Price execution).\n\nImplementation details:\n(((high * low)^0.5) - vwap)", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 42?", "input": "", "output": "(rank((vwap - close)) / rank((vwap + close)))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 42 function", "input": "", "output": "Function: alpha042\n\n(rank((vwap - close)) / rank((vwap + close)))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is VWAP in quantitative trading?", "input": "", "output": "VWAP (Volume-Weighted Average Price execution).\n\nImplementation details:\n(rank((vwap - close)) / rank((vwap + close)))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 43?", "input": "", "output": "(ts_rank((volume / adv20), 20) * ts_rank((-1 * delta(close, 7)), 8))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 43 function", "input": "", "output": "Function: alpha043\n\n(ts_rank((volume / adv20), 20) * ts_rank((-1 * delta(close, 7)), 8))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 44?", "input": "", "output": "(-1 * correlation(high, rank(volume), 5))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 44 function", "input": "", "output": "Function: alpha044\n\n(-1 * correlation(high, rank(volume), 5))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 45?", "input": "", "output": "(-1 * ((rank((sum(delay(close, 5), 20) / 20)) * correlation(close, volume, 2)) * rank(correlation(sum(close, 5), sum(close, 20), 2))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 45 function", "input": "", "output": "Function: alpha045\n\n(-1 * ((rank((sum(delay(close, 5), 20) / 20)) * correlation(close, volume, 2)) * rank(correlation(sum(close, 5), sum(close, 20), 2))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 46?", "input": "", "output": "((0.25 < (((delay(close, 20) - delay(close, 10)) / 10) - ((delay(close, 10) - close) / 10))) ? (-1 * 1) : (((((delay(close, 20) - delay(close, 10)) / 10) - ((delay(close, 10) - close) / 10)) < 0) ? 1 : ((-1 * 1) * (close - delay(close, 1)))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 46 function", "input": "", "output": "Function: alpha046\n\n((0.25 < (((delay(close, 20) - delay(close, 10)) / 10) - ((delay(close, 10) - close) / 10))) ? (-1 * 1) : (((((delay(close, 20) - delay(close, 10)) / 10) - ((delay(close, 10) - close) / 10)) < 0) ? 1 : ((-1 * 1) * (close - delay(close, 1)))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 47?", "input": "", "output": "((((rank((1 / close)) * volume) / adv20) * ((high * rank((high - close))) / (sum(high, 5) / 5))) - rank((vwap - delay(vwap, 5))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 47 function", "input": "", "output": "Function: alpha047\n\n((((rank((1 / close)) * volume) / adv20) * ((high * rank((high - close))) / (sum(high, 5) / 5))) - rank((vwap - delay(vwap, 5))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is VWAP in quantitative trading?", "input": "", "output": "VWAP (Volume-Weighted Average Price execution).\n\nImplementation details:\n((((rank((1 / close)) * volume) / adv20) * ((high * rank((high - close))) / (sum(high, 5) / 5))) - rank((vwap - delay(vwap, 5))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 48?", "input": "", "output": "(indneutralize(((correlation(delta(close, 1), delta(delay(close, 1), 1), 250) * delta(close, 1)) / close), IndClass.subindustry) / sum(((delta(close, 1) / delay(close, 1))^2), 250))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 48 function", "input": "", "output": "Function: alpha048\n\n(indneutralize(((correlation(delta(close, 1), delta(delay(close, 1), 1), 250) * delta(close, 1)) / close), IndClass.subindustry) / sum(((delta(close, 1) / delay(close, 1))^2), 250))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 49 function", "input": "", "output": "Function: alpha049\n\nTrend strength", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 50?", "input": "", "output": "(-1 * ts_max(rank(correlation(rank(volume), rank(vwap), 5)), 5))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 50 function", "input": "", "output": "Function: alpha050\n\n(-1 * ts_max(rank(correlation(rank(volume), rank(vwap), 5)), 5))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is VWAP in quantitative trading?", "input": "", "output": "VWAP (Volume-Weighted Average Price execution).\n\nImplementation details:\n(-1 * ts_max(rank(correlation(rank(volume), rank(vwap), 5)), 5))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 51 function", "input": "", "output": "Function: alpha051\n\nSimilar to alpha049 with different threshold", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 52?", "input": "", "output": "((((-1 * ts_min(low, 5)) + delay(ts_min(low, 5), 5)) * rank(((sum(returns, 240) - sum(returns, 20)) / 220))) * ts_rank(volume, 5))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 52 function", "input": "", "output": "Function: alpha052\n\n((((-1 * ts_min(low, 5)) + delay(ts_min(low, 5), 5)) * rank(((sum(returns, 240) - sum(returns, 20)) / 220))) * ts_rank(volume, 5))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 53?", "input": "", "output": "((-1 * delta((((close - low) - (high - close)) / (close - low)), 9)))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 53 function", "input": "", "output": "Function: alpha053\n\n((-1 * delta((((close - low) - (high - close)) / (close - low)), 9)))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 54?", "input": "", "output": "((-1 * ((low - close) * (open^5))) / ((low - high) * (close^5)))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 54 function", "input": "", "output": "Function: alpha054\n\n((-1 * ((low - close) * (open^5))) / ((low - high) * (close^5)))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 55?", "input": "", "output": "(-1 * correlation(rank(((close - ts_min(low, 12)) / (ts_max(high, 12) - ts_min(low, 12)))), rank(volume), 6))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 55 function", "input": "", "output": "Function: alpha055\n\n(-1 * correlation(rank(((close - ts_min(low, 12)) / (ts_max(high, 12) - ts_min(low, 12)))), rank(volume), 6))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 56?", "input": "", "output": "(0 - (1 * (rank((sum(returns, 10) / sum(sum(returns, 2), 3))) * rank((returns * cap)))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 56 function", "input": "", "output": "Function: alpha056\n\n(0 - (1 * (rank((sum(returns, 10) / sum(sum(returns, 2), 3))) * rank((returns * cap)))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 57?", "input": "", "output": "(0 - (1 * ((close - vwap) / decay_linear(rank(ts_argmax(close, 30)), 2))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 57 function", "input": "", "output": "Function: alpha057\n\n(0 - (1 * ((close - vwap) / decay_linear(rank(ts_argmax(close, 30)), 2))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is VWAP in quantitative trading?", "input": "", "output": "VWAP (Volume-Weighted Average Price execution).\n\nImplementation details:\n(0 - (1 * ((close - vwap) / decay_linear(rank(ts_argmax(close, 30)), 2))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 58?", "input": "", "output": "Sector neutralized - simplified", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 58 function", "input": "", "output": "Function: alpha058\n\nSector neutralized - simplified", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 59 function", "input": "", "output": "Function: alpha059\n\nSimilar to alpha058 with different parameters", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 60?", "input": "", "output": "(0 - (1 * ((2 * scale(rank(((((close - low) - (high - close)) / (high - low)) * volume)))) - scale(rank(ts_argmax(close, 10))))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 60 function", "input": "", "output": "Function: alpha060\n\n(0 - (1 * ((2 * scale(rank(((((close - low) - (high - close)) / (high - low)) * volume)))) - scale(rank(ts_argmax(close, 10))))))", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 61?", "input": "", "output": "Volume-VWAP relationship", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 61 function", "input": "", "output": "Function: alpha061\n\nVolume-VWAP relationship", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is VWAP in quantitative trading?", "input": "", "output": "VWAP (Volume-Weighted Average Price execution).\n\nImplementation details:\nVolume-VWAP relationship", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 62?", "input": "", "output": "Volume-high correlation", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Alpha 62 function", "input": "", "output": "Function: alpha062\n\nVolume-high correlation", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "Explain the Generate All Alphas function", "input": "", "output": "Function: generate_all_alphas\n\nGenerate all 101 Alpha signals.\n\nArgs:\n    df: DataFrame with OHLCV columns\n\nReturns:\n    DataFrame with alpha signals added", "source": "core\\features\\alpha101.py", "category": "alpha"}
{"instruction": "What is the source paper for this technique?", "input": "", "output": "The source is: Microsoft Research Asia - Qlib. ", "source": "core\\features\\alpha158.py", "category": "alpha"}
{"instruction": "Explain the purpose of Alpha158 - Microsoft Qlib 158 Technical Factors", "input": "", "output": "Alpha158 - Microsoft Qlib 158 Technical Factors\n================================================\nSource: Microsoft Research Asia - Qlib\nOfficial: https://github.com/microsoft/qlib/blob/main/qlib/contrib/data/handler.py\n\n158 handcrafted technical indicators organized into:\n- KBAR features (9 factors)\n- Price features (20 factors)\n- Volume features (5 factors)\n- Rolling statistics (124 factors across 5 windows)\n\nWindows: [5, 10, 20, 30, 60] days", "source": "core\\features\\alpha158.py", "category": "alpha"}
{"instruction": "What is the Alpha158 class and how do I use it?", "input": "", "output": "The Alpha158 class:\n\nMicrosoft Qlib Alpha158 - 158 Technical Factors.\n\nUsage:\n    alpha158 = Alpha158()\n    features = alpha158.generate_all(ohlcv_df)", "source": "core\\features\\alpha158.py", "category": "alpha"}
{"instruction": "Show me a code example for Alpha158", "input": "", "output": "alpha158 = Alpha158()\n    features = alpha158.generate_all(ohlcv_df)", "source": "core\\features\\alpha158.py", "category": "alpha"}
{"instruction": "Explain the Generate Alpha158 function", "input": "", "output": "Function: generate_alpha158\n\nGenerate Alpha158 factors.\n\nArgs:\n    df: OHLCV DataFrame\n    windows: Rolling windows (default: [5, 10, 20, 30, 60])\n\nReturns:\n    DataFrame with 158 factors", "source": "core\\features\\alpha158.py", "category": "alpha"}
{"instruction": "Explain the Generate All function", "input": "", "output": "Function: generate_all\n\nGenerate all 158 Alpha158 factors.\n\nArgs:\n    df: DataFrame with columns: open, high, low, close, volume\n\nReturns:\n    DataFrame with 158 factor columns", "source": "core\\features\\alpha158.py", "category": "alpha"}
{"instruction": "Explain the Get Feature Names function", "input": "", "output": "Function: get_feature_names\n\nGet list of all feature names.", "source": "core\\features\\alpha158.py", "category": "general"}
{"instruction": "What is the source paper for this technique?", "input": "", "output": "The source is: Microsoft Research Asia - Qlib. ", "source": "core\\features\\alpha360.py", "category": "alpha"}
{"instruction": "Explain the purpose of Alpha360 - Microsoft Qlib 360 Raw Price Features", "input": "", "output": "Alpha360 - Microsoft Qlib 360 Raw Price Features\n=================================================\nSource: Microsoft Research Asia - Qlib\nOfficial: https://github.com/microsoft/qlib/blob/main/qlib/contrib/data/loader.py\n\n360 features from 60-day normalized OHLCV lookback:\n- CLOSE0-CLOSE59 (60 factors)\n- OPEN0-OPEN59 (60 factors)\n- HIGH0-HIGH59 (60 factors)\n- LOW0-LOW59 (60 factors)\n- VWAP0-VWAP59 (60 factors)\n- VOLUME0-VOLUME59 (60 factors)\n\nAll prices normalized by current close.\nAll volumes normalized by current volume.", "source": "core\\features\\alpha360.py", "category": "alpha"}
{"instruction": "What is the Alpha360 class and how do I use it?", "input": "", "output": "The Alpha360 class:\n\nMicrosoft Qlib Alpha360 - 360 Raw Price Features.\n\n60-day lookback of normalized OHLCV data.\nNo feature engineering - raw temporal patterns for deep learning.\n\nUsage:\n    alpha360 = Alpha360()\n    features = alpha360.generate_all(ohlcv_df)", "source": "core\\features\\alpha360.py", "category": "alpha"}
{"instruction": "Show me a code example for Alpha360", "input": "", "output": "alpha360 = Alpha360()\n    features = alpha360.generate_all(ohlcv_df)", "source": "core\\features\\alpha360.py", "category": "alpha"}
{"instruction": "What is the Alpha360Compact class and how do I use it?", "input": "", "output": "The Alpha360Compact class:\n\nCompact version of Alpha360 for HFT with shorter lookback.\n\nDefault: 20-day lookback = 120 features (vs 360 for 60-day)", "source": "core\\features\\alpha360.py", "category": "alpha"}
{"instruction": "Explain the Generate Alpha360 function", "input": "", "output": "Function: generate_alpha360\n\nGenerate Alpha360 factors.\n\nArgs:\n    df: OHLCV DataFrame\n    lookback: Days to look back (default: 60)\n\nReturns:\n    DataFrame with 360 factors (6 fields x 60 days)", "source": "core\\features\\alpha360.py", "category": "alpha"}
{"instruction": "Explain the Generate Alpha360 Compact function", "input": "", "output": "Function: generate_alpha360_compact\n\nGenerate compact Alpha360 for HFT.\n\nArgs:\n    df: OHLCV DataFrame\n    lookback: Periods to look back (default: 20)\n\nReturns:\n    DataFrame with 120 factors (6 fields x 20 periods)", "source": "core\\features\\alpha360.py", "category": "alpha"}
{"instruction": "Explain the Generate All function", "input": "", "output": "Function: generate_all\n\nGenerate all 360 Alpha360 factors.\n\nArgs:\n    df: DataFrame with columns: open, high, low, close, volume\n        Optional: vwap (will be calculated if missing)\n\nReturns:\n    DataFrame with 360 factor columns", "source": "core\\features\\alpha360.py", "category": "alpha"}
{"instruction": "What is VWAP in quantitative trading?", "input": "", "output": "VWAP (Volume-Weighted Average Price execution).\n\nImplementation details:\nGenerate all 360 Alpha360 factors.\n\nArgs:\n    df: DataFrame with columns: open, high, low, close, volume\n        Optional: vwap (will be calculated if missing)\n\nReturns:\n    DataFrame with 360 factor columns", "source": "core\\features\\alpha360.py", "category": "alpha"}
{"instruction": "Explain the Get Feature Names function", "input": "", "output": "Function: get_feature_names\n\nGet list of all feature names.", "source": "core\\features\\alpha360.py", "category": "general"}
{"instruction": "Explain the Generate All function", "input": "", "output": "Function: generate_all\n\nGenerate compact Alpha360 features.", "source": "core\\features\\alpha360.py", "category": "alpha"}
{"instruction": "Explain the Get Feature Names function", "input": "", "output": "Function: get_feature_names\n\nGet feature names.", "source": "core\\features\\alpha360.py", "category": "general"}
{"instruction": "Explain the purpose of Asian FX Spread Trading Features", "input": "", "output": "Asian FX Spread Trading Features\n================================\nSingapore/Hong Kong FX market features for spread trading and peg exploitation.\n\nSources:\n1. CNH-CNY Spread Trading (Hong Kong)\n   - Offshore vs onshore yuan arbitrage\n   - PBOC intervention detection\n\n2. HKD Peg Band (Hong Kong Monetary Authority)\n   - 7.75-7.85 band exploitation\n   - Intervention probability\n\n3. Asian Session Microstructure (Singapore)\n   - Point72 Singapore research patterns\n   - Session-specific liquidity\n\n4. Taiwan/SGD Regional Dynamics\n   - VeighNa/vnpy quant framework insights\n   - Regional correlation structures\n\nCitations:\n[1] Cheung, Y.W. et al. (2019). \"A Decade of RMB Internationalisation\"\n    Economic Policy.\n    Key finding: CNH-CNY spread mean-reverts with 2-3 day half-life.\n\n[2] Hui, C.H. et al. (2017). \"The Sustainability of Hong Kong's Currency\n    Board\" Journal of Banking & Finance.\n    Analysis of HKD peg credibility and intervention patterns.\n\n[3] Rime, D. & Schrimpf, A. (2013). \"The Anatomy of the Global FX Market\n    Through the Lens of the 2013 Triennial Survey\" BIS Quarterly Review.\n    Asian session microstructure analysis.\n\nTotal: 15 factors organized into:\n- CNH-CNY Spread (4): Offshore/onshore yuan dynamics\n- HKD Peg Band (4): Hong Kong dollar peg exploitation\n- Asian Session (4): Session microstructure patterns\n- Regional Dynamics (3): Cross-Asian currency correlations", "source": "core\\features\\asia_fx_spread.py", "category": "alpha"}
{"instruction": "What is the AsiaFXSpreadFeatures class and how do I use it?", "input": "", "output": "The AsiaFXSpreadFeatures class:\n\nAsian FX Spread Trading Features.\n\nBased on research from:\n- Hong Kong academia (CNH-CNY spread)\n- HKMA research papers (HKD peg)\n- Singapore trading desks (session microstructure)\n- Taiwan VeighNa/vnpy community\n\nSpecialized for Asian session FX trading.\n\nUsage:\n    features = AsiaFXSpreadFeatures()\n    df_features = features.generate_all(ohlcv_df)", "source": "core\\features\\asia_fx_spread.py", "category": "microstructure"}
{"instruction": "Show me a code example for AsiaFXSpreadFeatures", "input": "", "output": "features = AsiaFXSpreadFeatures()\n    df_features = features.generate_all(ohlcv_df)", "source": "core\\features\\asia_fx_spread.py", "category": "microstructure"}
{"instruction": "Explain the Generate Asia Fx Features function", "input": "", "output": "Function: generate_asia_fx_features\n\nGenerate Asia FX Spread features.\n\nArgs:\n    df: OHLCV DataFrame\n\nReturns:\n    DataFrame with 15 Asian FX market factors", "source": "core\\features\\asia_fx_spread.py", "category": "alpha"}
{"instruction": "Explain the Generate All function", "input": "", "output": "Function: generate_all\n\nGenerate all Asia FX Spread features.\n\nArgs:\n    df: DataFrame with columns: open, high, low, close, volume\n\nReturns:\n    DataFrame with 15 factor columns", "source": "core\\features\\asia_fx_spread.py", "category": "alpha"}
{"instruction": "Explain the Get Feature Names function", "input": "", "output": "Function: get_feature_names\n\nGet list of all feature names.", "source": "core\\features\\asia_fx_spread.py", "category": "general"}
{"instruction": "Explain the Get Citations function", "input": "", "output": "Function: get_citations\n\nGet academic citations for Asian FX spread trading.", "source": "core\\features\\asia_fx_spread.py", "category": "microstructure"}
{"instruction": "What is the source paper for this technique?", "input": "", "output": "The source is: MSCI Barra CNE6 Model (China A-shares, 2019). ", "source": "core\\features\\barra_cne6.py", "category": "alpha"}
{"instruction": "What is the source paper for this technique?", "input": "", "output": "The source is: 清华大学 Barra白皮书, MSCI Factor Models. ", "source": "core\\features\\barra_cne6.py", "category": "alpha"}
{"instruction": "Explain the purpose of Barra CNE6 - MSCI Risk Factor Model (Adapted for Forex)", "input": "", "output": "Barra CNE6 - MSCI Risk Factor Model (Adapted for Forex)\n========================================================\nSource: MSCI Barra CNE6 Model (China A-shares, 2019)\nReference: 清华大学 Barra白皮书, MSCI Factor Models\n\nOriginal CNE6 has 46 risk factors for equities:\n- 9 Style factors (SIZE, BETA, MOMENTUM, etc.)\n- 1 Market factor\n- 36 Industry factors\n\nForex Adaptation:\nSince forex doesn't have market cap, book value, or industries,\nwe adapt the concepts using analogous price/volume metrics:\n\n- SIZE → Volatility magnitude (proxy for \"size\" of moves)\n- BETA → Correlation to USD index (DXY proxy)\n- MOMENTUM → Multi-period price momentum\n- VOLATILITY → Realized and implied volatility\n- LIQUIDITY → Volume-based metrics\n- VALUE → Mean reversion signals\n- GROWTH → Trend strength\n- QUALITY → Signal consistency\n- LEVERAGE → Position concentration\n- SENTIMENT → Order flow imbalance\n- DIVIDEND → Carry (interest rate differential proxy)\n\nTotal: 46 factors maintaining the spirit of Barra CNE6", "source": "core\\features\\barra_cne6.py", "category": "alpha"}
{"instruction": "What is the BarraCNE6Forex class and how do I use it?", "input": "", "output": "The BarraCNE6Forex class:\n\nBarra CNE6 Risk Factors Adapted for Forex.\n\n46 factors organized into:\n- Size factors (5)\n- Beta factors (4)\n- Momentum factors (6)\n- Volatility factors (6)\n- Liquidity factors (5)\n- Value factors (5)\n- Growth factors (4)\n- Quality factors (4)\n- Leverage factors (3)\n- Sentiment factors (4)\n\nUsage:\n    barra = BarraCNE6Forex()\n    features = barra.generate_all(ohlcv_df)", "source": "core\\features\\barra_cne6.py", "category": "alpha"}
{"instruction": "Show me a code example for BarraCNE6Forex", "input": "", "output": "barra = BarraCNE6Forex()\n    features = barra.generate_all(ohlcv_df)", "source": "core\\features\\barra_cne6.py", "category": "alpha"}
{"instruction": "Explain the Generate Barra Cne6 function", "input": "", "output": "Function: generate_barra_cne6\n\nGenerate Barra CNE6 factors for forex.\n\nArgs:\n    df: OHLCV DataFrame\n\nReturns:\n    DataFrame with 46 Barra factors", "source": "core\\features\\barra_cne6.py", "category": "alpha"}
{"instruction": "Explain the Generate All function", "input": "", "output": "Function: generate_all\n\nGenerate all 46 Barra CNE6 factors.\n\nArgs:\n    df: DataFrame with columns: open, high, low, close, volume\n\nReturns:\n    DataFrame with 46 factor columns", "source": "core\\features\\barra_cne6.py", "category": "alpha"}
{"instruction": "Explain the Get Feature Names function", "input": "", "output": "Function: get_feature_names\n\nGet list of all feature names.", "source": "core\\features\\barra_cne6.py", "category": "general"}
{"instruction": "Explain the Get Factor Category function", "input": "", "output": "Function: get_factor_category\n\nGet the category of a factor by name.", "source": "core\\features\\barra_cne6.py", "category": "alpha"}
{"instruction": "What is the source paper for this technique?", "input": "", "output": "The source is: 招商证券. ", "source": "core\\features\\chinese_gold_standard.py", "category": "alpha"}
{"instruction": "What is the source paper for this technique?", "input": "", "output": "The source is: 兴业证券 高频研究系列五：市场微观结构剖析. ", "source": "core\\features\\chinese_gold_standard.py", "category": "alpha"}
{"instruction": "What is the source paper for Labeling and Triple Barrier?", "input": "", "output": "The source is: Lopez de Prado, M. (2018).. ", "source": "core\\features\\chinese_gold_standard.py", "category": "alpha"}
{"instruction": "What is the source paper for HMM Regime Detection?", "input": "", "output": "The source is: 国泰君安 市场状态识别研究. ", "source": "core\\features\\chinese_gold_standard.py", "category": "alpha"}
{"instruction": "What is the source paper for Kalman Filter for Finance?", "input": "", "output": "The source is: 知乎 Kalman滤波金融应用. ", "source": "core\\features\\chinese_gold_standard.py", "category": "alpha"}
{"instruction": "What is the source paper for Stoikov Market Making?", "input": "", "output": "The source is: Avellaneda, M., & Stoikov, S. (2008).. ", "source": "core\\features\\chinese_gold_standard.py", "category": "alpha"}
{"instruction": "What is the source paper for this technique?", "input": "", "output": "The source is: ScienceDirect (2025). ", "source": "core\\features\\chinese_gold_standard.py", "category": "alpha"}
{"instruction": "What is the source paper for this technique?", "input": "", "output": "The source is: 数据分析与知识发现 (2023). ", "source": "core\\features\\chinese_gold_standard.py", "category": "alpha"}
{"instruction": "What is the source paper for TimeXer?", "input": "", "output": "The source is: Tsinghua University Time-Series-Library. ", "source": "core\\features\\chinese_gold_standard.py", "category": "alpha"}
{"instruction": "What is the source paper for Alpha191 Guotai Junan?", "input": "", "output": "The source is: 国泰君安. ", "source": "core\\features\\chinese_gold_standard.py", "category": "alpha"}
{"instruction": "Explain the purpose of Chinese Gold Standard Quantitative Factors for Forex", "input": "", "output": "Chinese Gold Standard Quantitative Factors for Forex\n=====================================================\nPeer-reviewed and institutional research implementations.\n\nCITATIONS:\n----------\n[1] VPIN (Volume-Synchronized Probability of Informed Trading)\n    Source: 招商证券 \"琢璞\"系列报告之十七：高频数据中的知情交易\n    URL: https://asset.quant-wiki.com/pdf/20200630-招商证券-\"琢璞\"系列报告之十七：高频数据中的知情交易（二）.pdf\n    Original: Easley, D., López de Prado, M., & O'Hara, M. (2012).\n              \"Flow Toxicity and Liquidity in a High-frequency World\"\n              Review of Financial Studies, 25(5), 1457-1493.\n\n[2] Order Flow Imbalance (OFI)\n    Source: 兴业证券 高频研究系列五：市场微观结构剖析\n    URL: https://asset.quant-wiki.com/pdf/20221109-兴业证券-高频研究系列五：市场微观结构剖析.pdf\n    Original: Cont, R., Kukanov, A., & Stoikov, S. (2014).\n              \"The Price Impact of Order Book Events\"\n              Journal of Financial Econometrics, 12(1), 47-88.\n\n[3] Meta-Labeling and Triple Barrier\n    Source: Lopez de Prado, M. (2018).\n            \"Advances in Financial Machine Learning\"\n            Wiley. Chapter 3: Meta-Labeling.\n    Implementation: mlfinlab library\n\n[4] HMM Regime Detection\n    Source: 国泰君安 市场状态识别研究\n    Original: Hamilton, J. D. (1989).\n              \"A New Approach to the Economic Analysis of Nonstationary\n              Time Series and the Business Cycle\"\n              Econometrica, 57(2), 357-384.\n\n[5] Kalman Filter for Finance\n    Source: 知乎 Kalman滤波金融应用\n    URL: https://zhuanlan.zhihu.com/p/101630539\n    Original: Kalman, R. E. (1960).\n              \"A New Approach to Linear Filtering and Prediction Problems\"\n              Journal of Basic Engineering, 82(1), 35-45.\n\n[6] Avellaneda-Stoikov Market Making\n    Source: Avellaneda, M., & Stoikov, S. (2008).\n            \"High-frequency trading in a limit order book\"\n            Quantitative Finance, 8(3), 217-224.\n    Chinese: 订单流交易实战应用 https://zhuanlan.zhihu.com/p/133214828\n\n[7] LSTM+Attention for Forex (ALFA Model)\n    Source: ScienceDirect (2025)\n    URL: https://www.sciencedirect.com/science/article/pii/S2666827025000313\n\n[8] Cross-Market Sentiment (CCSA-DL)\n    Source: 数据分析与知识发现 (2023)\n    URL: https://manu44.magtech.com.cn/Jwk_infotech_wk3/EN/10.11925/infotech.2096-3467.2022.1147\n    Innovation: BERT-TextCNN sentiment + LSTM (16.77% improvement)\n\n[9] iTransformer / TimeMixer / TimeXer\n    Source: Tsinghua University Time-Series-Library\n    GitHub: https://github.com/thuml/Time-Series-Library\n    Papers: ICLR 2024 (iTransformer, TimeMixer), NeurIPS 2024 (TimeXer)\n\n[10] Alpha191 Guotai Junan\n     Source: 国泰君安 \"基于短周期价量特征的多因子选股体系\" (2017)\n     URL: https://zhuanlan.zhihu.com/p/30195354\n     Platform: JoinQuant https://joinquant.com/data/dict/alpha191", "source": "core\\features\\chinese_gold_standard.py", "category": "alpha"}
{"instruction": "What is the VPIN class and how do I use it?", "input": "", "output": "The VPIN class:\n\nVolume-Synchronized Probability of Informed Trading.\n\nPredicts volatility spikes 30-60 minutes ahead by measuring\norder flow toxicity through volume-time sampling.\n\nCitation:\n    招商证券 \"琢璞\"系列报告之十七：高频数据中的知情交易（二）\n    Easley, D., López de Prado, M., & O'Hara, M. (2012).\n    \"Flow Toxicity and Liquidity in a High-frequency World\"\n    Review of Financial Studies, 25(5), 1457-1493.", "source": "core\\features\\chinese_gold_standard.py", "category": "volatility"}
{"instruction": "What is the MultiLevelOFI class and how do I use it?", "input": "", "output": "The MultiLevelOFI class:\n\nMulti-Level Order Flow Imbalance.\n\nExtends single-level OFI to capture depth across multiple\nprice levels of the order book.\n\nCitation:\n    兴业证券 高频研究系列五：市场微观结构剖析\n    Cont, R., Kukanov, A., & Stoikov, S. (2014).\n    \"The Price Impact of Order Book Events\"\n    Journal of Financial Econometrics, 12(1), 47-88.", "source": "core\\features\\chinese_gold_standard.py", "category": "execution"}
{"instruction": "What is the TripleBarrierLabeling class and how do I use it?", "input": "", "output": "The TripleBarrierLabeling class:\n\nTriple Barrier Method for labeling financial time series.\n\nCreates labels based on which barrier is hit first:\n- Upper barrier (profit target)\n- Lower barrier (stop-loss)\n- Vertical barrier (max holding time)\n\nCitation:\n    Lopez de Prado, M. (2018).\n    \"Advances in Financial Machine Learning\"\n    Wiley. Chapter 3.", "source": "core\\features\\chinese_gold_standard.py", "category": "rl"}
{"instruction": "What is the MetaLabeling class and how do I use it?", "input": "", "output": "The MetaLabeling class:\n\nMeta-Labeling for bet sizing.\n\nSecondary model that learns when to trade (or not)\ngiven a primary model's directional prediction.\n\nCitation:\n    Lopez de Prado, M. (2018).\n    \"Advances in Financial Machine Learning\"\n    Wiley. Chapter 3.3.", "source": "core\\features\\chinese_gold_standard.py", "category": "ensemble"}
{"instruction": "What is the HMMRegimeDetector class and how do I use it?", "input": "", "output": "The HMMRegimeDetector class:\n\nHidden Markov Model for market regime detection.\n\nIdentifies market states (trending, mean-reverting, volatile)\nusing Gaussian HMM on return features.\n\nCitation:\n    国泰君安 市场状态识别研究\n    Hamilton, J. D. (1989).\n    \"A New Approach to the Economic Analysis of Nonstationary\n    Time Series and the Business Cycle\"\n    Econometrica, 57(2), 357-384.", "source": "core\\features\\chinese_gold_standard.py", "category": "volatility"}
{"instruction": "What is the KalmanFilterForex class and how do I use it?", "input": "", "output": "The KalmanFilterForex class:\n\nKalman Filter for forex signal smoothing and prediction.\n\nApplications:\n1. Price denoising\n2. Dynamic hedge ratio estimation\n3. Spread mean estimation for pairs trading\n\nCitation:\n    知乎 Kalman滤波金融应用 https://zhuanlan.zhihu.com/p/101630539\n    Kalman, R. E. (1960).\n    \"A New Approach to Linear Filtering and Prediction Problems\"\n    Journal of Basic Engineering, 82(1), 35-45.", "source": "core\\features\\chinese_gold_standard.py", "category": "alpha"}
{"instruction": "What is the AvellanedaStoikov class and how do I use it?", "input": "", "output": "The AvellanedaStoikov class:\n\nAvellaneda-Stoikov market making model.\n\nOptimal bid/ask quotes considering inventory risk.\n\nCitation:\n    Avellaneda, M., & Stoikov, S. (2008).\n    \"High-frequency trading in a limit order book\"\n    Quantitative Finance, 8(3), 217-224.\n\n    Chinese: 订单流交易实战应用 https://zhuanlan.zhihu.com/p/133214828", "source": "core\\features\\chinese_gold_standard.py", "category": "risk"}
{"instruction": "What is the DeepLearningFeatures class and how do I use it?", "input": "", "output": "The DeepLearningFeatures class:\n\nFeature engineering inspired by deep learning research.\n\nCitations:\n    [7] ALFA Model (LSTM+Attention): ScienceDirect 2025\n    [8] CCSA-DL: 数据分析与知识发现 2023\n    [9] iTransformer/TimeMixer: Tsinghua ICLR 2024", "source": "core\\features\\chinese_gold_standard.py", "category": "general"}
{"instruction": "What is the ChineseGoldStandardFeatures class and how do I use it?", "input": "", "output": "The ChineseGoldStandardFeatures class:\n\nUnified generator for all Chinese gold standard features.\n\nCombines:\n- VPIN (招商证券)\n- Multi-level OFI (兴业证券/Cont 2014)\n- Triple Barrier signals (Lopez de Prado)\n- HMM Regime (Hamilton/国泰君安)\n- Kalman Filter signals\n- Avellaneda-Stoikov features\n- Deep Learning proxies (Tsinghua)", "source": "core\\features\\chinese_gold_standard.py", "category": "alpha"}
{"instruction": "Explain the Generate Chinese Gold Standard Features function", "input": "", "output": "Function: generate_chinese_gold_standard_features\n\nGenerate all Chinese gold standard features in one call.\n\nCitations: See module docstring for full list.", "source": "core\\features\\chinese_gold_standard.py", "category": "general"}
{"instruction": "What is the formula for Bulk Volume Classification?", "input": "", "output": "Bulk Volume Classification (BVC) method.\n\nClassifies volume as buy/sell using price changes and\nnormal distribution CDF.\n\nFormula:\n    V_buy = V * CDF(Z)\n    V_sell = V * (1 - CDF(Z))\n    where Z = (P_close - P_open) / sigma", "source": "core\\features\\chinese_gold_standard.py", "category": "volatility"}
{"instruction": "Explain the Bulk Volume Classification function", "input": "", "output": "Function: bulk_volume_classification\n\nBulk Volume Classification (BVC) method.\n\nClassifies volume as buy/sell using price changes and\nnormal distribution CDF.\n\nFormula:\n    V_buy = V * CDF(Z)\n    V_sell = V * (1 - CDF(Z))\n    where Z = (P_close - P_open) / sigma", "source": "core\\features\\chinese_gold_standard.py", "category": "volatility"}
{"instruction": "What is the formula for Calculate Vpin?", "input": "", "output": "Calculate VPIN time series.\n\nFormula:\n    OI_bucket = |V_buy - V_sell| / (V_buy + V_sell)\n    VPIN = mean(OI_buckets[-n:])\n\nReturns:\n    Series of VPIN values (0 to 1, higher = more toxic flow)", "source": "core\\features\\chinese_gold_standard.py", "category": "general"}
{"instruction": "Explain the Calculate Vpin function", "input": "", "output": "Function: calculate_vpin\n\nCalculate VPIN time series.\n\nFormula:\n    OI_bucket = |V_buy - V_sell| / (V_buy + V_sell)\n    VPIN = mean(OI_buckets[-n:])\n\nReturns:\n    Series of VPIN values (0 to 1, higher = more toxic flow)", "source": "core\\features\\chinese_gold_standard.py", "category": "general"}
{"instruction": "What is VPIN in quantitative trading?", "input": "", "output": "VPIN (Volume-Synchronized Probability of Informed Trading).\n\nImplementation details:\nCalculate VPIN time series.\n\nFormula:\n    OI_bucket = |V_buy - V_sell| / (V_buy + V_sell)\n    VPIN = mean(OI_buckets[-n:])\n\nReturns:\n    Series of VPIN values (0 to 1, higher = more toxic flow)", "source": "core\\features\\chinese_gold_standard.py", "category": "general"}
{"instruction": "Explain the Calculate Toxicity Signal function", "input": "", "output": "Function: calculate_toxicity_signal\n\nGenerate trading signal from VPIN.\n\nHigh VPIN (>0.7) indicates toxic flow, expect volatility.", "source": "core\\features\\chinese_gold_standard.py", "category": "alpha"}
{"instruction": "What is VPIN in quantitative trading?", "input": "", "output": "VPIN (Volume-Synchronized Probability of Informed Trading).\n\nImplementation details:\nGenerate trading signal from VPIN.\n\nHigh VPIN (>0.7) indicates toxic flow, expect volatility.", "source": "core\\features\\chinese_gold_standard.py", "category": "alpha"}
{"instruction": "What is the formula for Calculate Level Ofi?", "input": "", "output": "Calculate OFI for a single level.\n\nFormula (Cont et al. 2014):\n    OFI = ΔQ_bid * I(P_bid >= P_bid_prev) - ΔQ_ask * I(P_ask <= P_ask_prev)\n\nWhere:\n    ΔQ = change in quantity\n    I() = indicator function", "source": "core\\features\\chinese_gold_standard.py", "category": "microstructure"}
{"instruction": "Explain the Calculate Level Ofi function", "input": "", "output": "Function: calculate_level_ofi\n\nCalculate OFI for a single level.\n\nFormula (Cont et al. 2014):\n    OFI = ΔQ_bid * I(P_bid >= P_bid_prev) - ΔQ_ask * I(P_ask <= P_ask_prev)\n\nWhere:\n    ΔQ = change in quantity\n    I() = indicator function", "source": "core\\features\\chinese_gold_standard.py", "category": "microstructure"}
{"instruction": "What is OFI in quantitative trading?", "input": "", "output": "OFI (Order Flow Imbalance).\n\nImplementation details:\nCalculate OFI for a single level.\n\nFormula (Cont et al. 2014):\n    OFI = ΔQ_bid * I(P_bid >= P_bid_prev) - ΔQ_ask * I(P_ask <= P_ask_prev)\n\nWhere:\n    ΔQ = change in quantity\n    I() = indicator function", "source": "core\\features\\chinese_gold_standard.py", "category": "microstructure"}
{"instruction": "What is the formula for Calculate Integrated Ofi?", "input": "", "output": "Calculate integrated OFI for single-level data (tick data).\n\nApproximates multi-level OFI using price momentum and volume.", "source": "core\\features\\chinese_gold_standard.py", "category": "volatility"}
{"instruction": "Explain the Calculate Integrated Ofi function", "input": "", "output": "Function: calculate_integrated_ofi\n\nCalculate integrated OFI for single-level data (tick data).\n\nApproximates multi-level OFI using price momentum and volume.", "source": "core\\features\\chinese_gold_standard.py", "category": "volatility"}
{"instruction": "What is OFI in quantitative trading?", "input": "", "output": "OFI (Order Flow Imbalance).\n\nImplementation details:\nCalculate integrated OFI for single-level data (tick data).\n\nApproximates multi-level OFI using price momentum and volume.", "source": "core\\features\\chinese_gold_standard.py", "category": "volatility"}
{"instruction": "What is the formula for Calculate Ofi Momentum?", "input": "", "output": "OFI momentum signal (short-term vs long-term).\n\nPositive = increasing buy pressure\nNegative = increasing sell pressure", "source": "core\\features\\chinese_gold_standard.py", "category": "alpha"}
{"instruction": "Explain the Calculate Ofi Momentum function", "input": "", "output": "Function: calculate_ofi_momentum\n\nOFI momentum signal (short-term vs long-term).\n\nPositive = increasing buy pressure\nNegative = increasing sell pressure", "source": "core\\features\\chinese_gold_standard.py", "category": "alpha"}
{"instruction": "What is OFI in quantitative trading?", "input": "", "output": "OFI (Order Flow Imbalance).\n\nImplementation details:\nOFI momentum signal (short-term vs long-term).\n\nPositive = increasing buy pressure\nNegative = increasing sell pressure", "source": "core\\features\\chinese_gold_standard.py", "category": "alpha"}
{"instruction": "Explain the Get Daily Volatility function", "input": "", "output": "Function: get_daily_volatility\n\nEstimate daily volatility using exponential moving std.", "source": "core\\features\\chinese_gold_standard.py", "category": "volatility"}
{"instruction": "What is the formula for Apply Triple Barrier?", "input": "", "output": "Apply triple barrier labeling.\n\nReturns:\n    Series with labels:\n     1 = hit upper barrier (profit)\n    -1 = hit lower barrier (loss)\n     0 = hit vertical barrier (timeout)", "source": "core\\features\\chinese_gold_standard.py", "category": "general"}
{"instruction": "Explain the Apply Triple Barrier function", "input": "", "output": "Function: apply_triple_barrier\n\nApply triple barrier labeling.\n\nReturns:\n    Series with labels:\n     1 = hit upper barrier (profit)\n    -1 = hit lower barrier (loss)\n     0 = hit vertical barrier (timeout)", "source": "core\\features\\chinese_gold_standard.py", "category": "general"}
{"instruction": "What is OFI in quantitative trading?", "input": "", "output": "OFI (Order Flow Imbalance).\n\nImplementation details:\nApply triple barrier labeling.\n\nReturns:\n    Series with labels:\n     1 = hit upper barrier (profit)\n    -1 = hit lower barrier (loss)\n     0 = hit vertical barrier (timeout)", "source": "core\\features\\chinese_gold_standard.py", "category": "general"}
{"instruction": "What is the formula for Create Meta Labels?", "input": "", "output": "Create meta-labels for training the meta-labeling model.\n\nMeta-label = 1 if primary prediction was correct\nMeta-label = 0 if primary prediction was wrong\n\nThis teaches the model WHEN to trust the primary model.", "source": "core\\features\\chinese_gold_standard.py", "category": "ensemble"}
{"instruction": "Explain the Create Meta Labels function", "input": "", "output": "Function: create_meta_labels\n\nCreate meta-labels for training the meta-labeling model.\n\nMeta-label = 1 if primary prediction was correct\nMeta-label = 0 if primary prediction was wrong\n\nThis teaches the model WHEN to trust the primary model.", "source": "core\\features\\chinese_gold_standard.py", "category": "ensemble"}
{"instruction": "What is the formula for Calculate Bet Size?", "input": "", "output": "Calculate position size using meta-labeling probabilities.\n\nFormula:\n    bet_size = primary_signal * meta_probability * max_leverage", "source": "core\\features\\chinese_gold_standard.py", "category": "alpha"}
{"instruction": "Explain the Calculate Bet Size function", "input": "", "output": "Function: calculate_bet_size\n\nCalculate position size using meta-labeling probabilities.\n\nFormula:\n    bet_size = primary_signal * meta_probability * max_leverage", "source": "core\\features\\chinese_gold_standard.py", "category": "alpha"}
{"instruction": "Explain the Prepare Features function", "input": "", "output": "Function: prepare_features\n\nPrepare features for HMM training.\n\nFeatures: [returns, volatility, momentum]", "source": "core\\features\\chinese_gold_standard.py", "category": "volatility"}
{"instruction": "What is HMM in quantitative trading?", "input": "", "output": "HMM (Hidden Markov Model for regime detection).\n\nImplementation details:\nPrepare features for HMM training.\n\nFeatures: [returns, volatility, momentum]", "source": "core\\features\\chinese_gold_standard.py", "category": "volatility"}
{"instruction": "What is the formula for Fit Predict?", "input": "", "output": "Fit HMM and predict regimes.\n\nReturns:\n    Series with regime labels (0, 1, 2)\n\nInterpretation (typically):\n    0: Low volatility / trending\n    1: High volatility / mean-reverting\n    2: Transitional / uncertain", "source": "core\\features\\chinese_gold_standard.py", "category": "volatility"}
{"instruction": "Explain the Fit Predict function", "input": "", "output": "Function: fit_predict\n\nFit HMM and predict regimes.\n\nReturns:\n    Series with regime labels (0, 1, 2)\n\nInterpretation (typically):\n    0: Low volatility / trending\n    1: High volatility / mean-reverting\n    2: Transitional / uncertain", "source": "core\\features\\chinese_gold_standard.py", "category": "volatility"}
{"instruction": "What is HMM in quantitative trading?", "input": "", "output": "HMM (Hidden Markov Model for regime detection).\n\nImplementation details:\nFit HMM and predict regimes.\n\nReturns:\n    Series with regime labels (0, 1, 2)\n\nInterpretation (typically):\n    0: Low volatility / trending\n    1: High volatility / mean-reverting\n    2: Transitional / uncertain", "source": "core\\features\\chinese_gold_standard.py", "category": "volatility"}
{"instruction": "What is the formula for Filter?", "input": "", "output": "Apply Kalman filter to observations.\n\nState equation: x_t = x_{t-1} + w_t  (random walk)\nObservation equation: z_t = x_t + v_t\n\nReturns:\n    (filtered_state, kalman_gain)", "source": "core\\features\\chinese_gold_standard.py", "category": "regime"}
{"instruction": "Explain the Filter function", "input": "", "output": "Function: filter\n\nApply Kalman filter to observations.\n\nState equation: x_t = x_{t-1} + w_t  (random walk)\nObservation equation: z_t = x_t + v_t\n\nReturns:\n    (filtered_state, kalman_gain)", "source": "core\\features\\chinese_gold_standard.py", "category": "regime"}
{"instruction": "What is Kalman Filter in quantitative trading?", "input": "", "output": "Kalman Filter (state estimation and signal filtering).\n\nImplementation details:\nApply Kalman filter to observations.\n\nState equation: x_t = x_{t-1} + w_t  (random walk)\nObservation equation: z_t = x_t + v_t\n\nReturns:\n    (filtered_state, kalman_gain)", "source": "core\\features\\chinese_gold_standard.py", "category": "regime"}
{"instruction": "What is the formula for Calculate Spread Zscore?", "input": "", "output": "Calculate z-score of spread using Kalman-filtered mean.\n\nFor pairs/spread trading.", "source": "core\\features\\chinese_gold_standard.py", "category": "microstructure"}
{"instruction": "Explain the Calculate Spread Zscore function", "input": "", "output": "Function: calculate_spread_zscore\n\nCalculate z-score of spread using Kalman-filtered mean.\n\nFor pairs/spread trading.", "source": "core\\features\\chinese_gold_standard.py", "category": "microstructure"}
{"instruction": "What is Kalman Filter in quantitative trading?", "input": "", "output": "Kalman Filter (state estimation and signal filtering).\n\nImplementation details:\nCalculate z-score of spread using Kalman-filtered mean.\n\nFor pairs/spread trading.", "source": "core\\features\\chinese_gold_standard.py", "category": "microstructure"}
{"instruction": "What is the formula for Reservation Price?", "input": "", "output": "Calculate reservation price (market maker's internal valuation).\n\nFormula:\n    r = s - q * gamma * sigma^2 * (T - t)\n\nWhere:\n    s = mid price\n    q = current inventory\n    gamma = risk aversion\n    sigma = volatility\n    T - t = time remaining", "source": "core\\features\\chinese_gold_standard.py", "category": "volatility"}
{"instruction": "Explain the Reservation Price function", "input": "", "output": "Function: reservation_price\n\nCalculate reservation price (market maker's internal valuation).\n\nFormula:\n    r = s - q * gamma * sigma^2 * (T - t)\n\nWhere:\n    s = mid price\n    q = current inventory\n    gamma = risk aversion\n    sigma = volatility\n    T - t = time remaining", "source": "core\\features\\chinese_gold_standard.py", "category": "volatility"}
{"instruction": "What is the formula for Optimal Spread?", "input": "", "output": "Calculate optimal bid-ask spread.\n\nFormula:\n    delta = gamma * sigma^2 * (T-t) + (2/gamma) * log(1 + gamma/k)", "source": "core\\features\\chinese_gold_standard.py", "category": "microstructure"}
{"instruction": "Explain the Optimal Spread function", "input": "", "output": "Function: optimal_spread\n\nCalculate optimal bid-ask spread.\n\nFormula:\n    delta = gamma * sigma^2 * (T-t) + (2/gamma) * log(1 + gamma/k)", "source": "core\\features\\chinese_gold_standard.py", "category": "microstructure"}
{"instruction": "Explain the Optimal Quotes function", "input": "", "output": "Function: optimal_quotes\n\nCalculate optimal bid and ask prices.\n\nReturns:\n    (bid_price, ask_price)", "source": "core\\features\\chinese_gold_standard.py", "category": "microstructure"}
{"instruction": "What is the formula for Inventory Signal?", "input": "", "output": "Generate trading signal based on inventory-adjusted fair value.\n\nReturns signal:\n    Positive = price above fair value (sell)\n    Negative = price below fair value (buy)", "source": "core\\features\\chinese_gold_standard.py", "category": "alpha"}
{"instruction": "Explain the Inventory Signal function", "input": "", "output": "Function: inventory_signal\n\nGenerate trading signal based on inventory-adjusted fair value.\n\nReturns signal:\n    Positive = price above fair value (sell)\n    Negative = price below fair value (buy)", "source": "core\\features\\chinese_gold_standard.py", "category": "alpha"}
{"instruction": "What is the formula for Attention Weights Proxy?", "input": "", "output": "Proxy for attention weights using price importance.\n\nHigher weight = more important time step for prediction.\nBased on price volatility contribution.", "source": "core\\features\\chinese_gold_standard.py", "category": "volatility"}
{"instruction": "Explain the Attention Weights Proxy function", "input": "", "output": "Function: attention_weights_proxy\n\nProxy for attention weights using price importance.\n\nHigher weight = more important time step for prediction.\nBased on price volatility contribution.", "source": "core\\features\\chinese_gold_standard.py", "category": "volatility"}
{"instruction": "What is the formula for Temporal Attention Context?", "input": "", "output": "Attention-weighted context vector (simplified).\n\nFormula:\n    context = sum(attention_weights * features)", "source": "core\\features\\chinese_gold_standard.py", "category": "general"}
{"instruction": "Explain the Temporal Attention Context function", "input": "", "output": "Function: temporal_attention_context\n\nAttention-weighted context vector (simplified).\n\nFormula:\n    context = sum(attention_weights * features)", "source": "core\\features\\chinese_gold_standard.py", "category": "general"}
{"instruction": "Explain the Multiscale Decomposition function", "input": "", "output": "Function: multiscale_decomposition\n\nMultiscale trend decomposition (TimeMixer inspired).\n\nDecomposes price into multiple time scales.\n\nCitation: TimeMixer (ICLR 2024)", "source": "core\\features\\chinese_gold_standard.py", "category": "general"}
{"instruction": "Explain the Exogenous Features function", "input": "", "output": "Function: exogenous_features\n\nPrepare exogenous variable features (TimeXer inspired).\n\nCitation: TimeXer (NeurIPS 2024)\n\nArgs:\n    exog_dict: Dictionary of exogenous series (e.g., DXY, VIX)", "source": "core\\features\\chinese_gold_standard.py", "category": "risk"}
{"instruction": "Explain the Generate All function", "input": "", "output": "Function: generate_all\n\nGenerate all gold standard features.\n\nArgs:\n    df: DataFrame with 'close', 'volume' columns\n\nReturns:\n    DataFrame with all features", "source": "core\\features\\chinese_gold_standard.py", "category": "volatility"}
{"instruction": "Explain the purpose of Cross-Asset Signals for Forex Trading", "input": "", "output": "Cross-Asset Signals for Forex Trading\n======================================\nSignals derived from related markets that affect forex.\n\nKey Cross-Asset Relationships:\n1. DXY (Dollar Index) - Inverse to EUR/USD, GBP/USD\n2. VIX - Risk-off = USD strength\n3. SPX - Risk-on = USD weakness\n4. Gold - Safe haven, correlates with JPY/CHF\n5. Oil - CAD, NOK correlation\n6. Bonds - Yield differentials drive rates\n\nThese are what institutional traders actually use.", "source": "core\\features\\cross_asset.py", "category": "alpha"}
{"instruction": "What is the CrossAssetSignal class and how do I use it?", "input": "", "output": "The CrossAssetSignal class:\n\nSingle cross-asset signal.", "source": "core\\features\\cross_asset.py", "category": "alpha"}
{"instruction": "What is the CrossAssetSignalGenerator class and how do I use it?", "input": "", "output": "The CrossAssetSignalGenerator class:\n\nGenerate forex signals from cross-asset relationships.\n\nUsage:\n    generator = CrossAssetSignalGenerator()\n    signals = generator.generate_all_signals(forex_data, cross_asset_data)", "source": "core\\features\\cross_asset.py", "category": "alpha"}
{"instruction": "Show me a code example for CrossAssetSignalGenerator", "input": "", "output": "generator = CrossAssetSignalGenerator()\n    signals = generator.generate_all_signals(forex_data, cross_asset_data)", "source": "core\\features\\cross_asset.py", "category": "alpha"}
{"instruction": "What is the formula for Create Cross Asset Features?", "input": "", "output": "Quick function to create cross-asset features for a forex pair.\n\nArgs:\n    forex_pair: Target pair (e.g., 'EURUSD')\n    forex_data: Target pair data\n    related_pairs: Dict of related pair data\n\nReturns:\n    DataFrame with cross-asset features", "source": "core\\features\\cross_asset.py", "category": "general"}
{"instruction": "Explain the Create Cross Asset Features function", "input": "", "output": "Function: create_cross_asset_features\n\nQuick function to create cross-asset features for a forex pair.\n\nArgs:\n    forex_pair: Target pair (e.g., 'EURUSD')\n    forex_data: Target pair data\n    related_pairs: Dict of related pair data\n\nReturns:\n    DataFrame with cross-asset features", "source": "core\\features\\cross_asset.py", "category": "general"}
{"instruction": "What is the formula for Generate All Signals?", "input": "", "output": "Generate all cross-asset signals.\n\nArgs:\n    forex_data: Forex OHLCV data with pair column or pair-named columns\n    cross_asset_data: Dict of DataFrames for DXY, VIX, SPX, etc.\n\nReturns:\n    DataFrame with cross-asset signals added", "source": "core\\features\\cross_asset.py", "category": "alpha"}
{"instruction": "Explain the Generate All Signals function", "input": "", "output": "Function: generate_all_signals\n\nGenerate all cross-asset signals.\n\nArgs:\n    forex_data: Forex OHLCV data with pair column or pair-named columns\n    cross_asset_data: Dict of DataFrames for DXY, VIX, SPX, etc.\n\nReturns:\n    DataFrame with cross-asset signals added", "source": "core\\features\\cross_asset.py", "category": "alpha"}
{"instruction": "Explain the Get Signal Weights function", "input": "", "output": "Function: get_signal_weights\n\nGet optimal signal weights for a pair based on correlations.", "source": "core\\features\\cross_asset.py", "category": "alpha"}
{"instruction": "What is the source paper for research paper?", "input": "", "output": "The source is: arXiv:1802.09477. ", "source": "core\\features\\deep_rl_trading.py", "category": "volatility"}
{"instruction": "What is the source paper for research paper?", "input": "", "output": "The source is: arXiv:1801.01290. ", "source": "core\\features\\deep_rl_trading.py", "category": "volatility"}
{"instruction": "What is the source paper for research paper?", "input": "", "output": "The source is: arXiv:2201.09058. ", "source": "core\\features\\deep_rl_trading.py", "category": "volatility"}
{"instruction": "What is the source paper for research paper?", "input": "", "output": "The source is: arXiv:2011.09607. ", "source": "core\\features\\deep_rl_trading.py", "category": "volatility"}
{"instruction": "Explain the purpose of Deep Reinforcement Learning for Forex Trading - Gold Standard Implementations", "input": "", "output": "Deep Reinforcement Learning for Forex Trading - Gold Standard Implementations\n==============================================================================\n\nState-of-the-art deep RL algorithms for algorithmic trading with full\nacademic citations. Implements the BEST of the BEST from 2020-2024 research.\n\nCITATIONS:\n----------\n\n1. TD3 (Twin Delayed DDPG)\n   Fujimoto, S., Hoof, H., & Meger, D. (2018).\n   \"Addressing Function Approximation Error in Actor-Critic Methods\"\n   ICML 2018.\n   arXiv: https://arxiv.org/abs/1802.09477\n\n2. SAC (Soft Actor-Critic)\n   Haarnoja, T., Zhou, A., Abbeel, P., & Levine, S. (2018).\n   \"Soft Actor-Critic: Off-Policy Maximum Entropy Deep Reinforcement Learning\n   with a Stochastic Actor\"\n   ICML 2018.\n   arXiv: https://arxiv.org/abs/1801.01290\n\n3. EarnHFT (Hierarchical RL for HFT)\n   Qin, M., Sun, S., Zhang, W., Xia, H., Wang, X., & An, B. (2024).\n   \"EarnHFT: Efficient Hierarchical Reinforcement Learning for High Frequency Trading\"\n   AAAI 2024, 38(13), 14669-14676.\n   DOI: https://doi.org/10.1609/aaai.v38i13.29384\n\n4. MacroHFT (Memory-Augmented Context-Aware RL)\n   Zong, Y., et al. (2024).\n   \"MacroHFT: Memory Augmented Context-aware Reinforcement Learning On\n   High Frequency Trading\"\n   KDD 2024.\n   DOI: https://doi.org/10.1145/3637528.3672064\n\n5. DeepScalper (Risk-Aware RL)\n   Sun, S., et al. (2022).\n   \"DeepScalper: A Risk-Aware Reinforcement Learning Framework to Capture\n   Fleeting Intraday Trading Opportunities\"\n   CIKM 2022.\n   arXiv: https://arxiv.org/abs/2201.09058\n\n6. FinRL Framework\n   Liu, X., et al. (2020).\n   \"FinRL: A Deep Reinforcement Learning Library for Automated Stock Trading\n   in Quantitative Finance\"\n   NeurIPS 2020 Deep RL Workshop.\n   arXiv: https://arxiv.org/abs/2011.09607\n\nAPPLICABILITY: FOREX-NATIVE\nAll algorithms adapted for continuous forex trading with:\n- Multi-currency support\n- Transaction cost handling\n- Regime-aware execution\n- Risk-adjusted rewards", "source": "core\\features\\deep_rl_trading.py", "category": "volatility"}
{"instruction": "What is the ReplayBuffer class and how do I use it?", "input": "", "output": "The ReplayBuffer class:\n\nStandard experience replay buffer for off-policy algorithms.\n\nUsed by: TD3, SAC, DDPG", "source": "core\\features\\deep_rl_trading.py", "category": "general"}
{"instruction": "What is the PrioritizedReplayBuffer class and how do I use it?", "input": "", "output": "The PrioritizedReplayBuffer class:\n\nPrioritized Experience Replay (PER).\n\nCitation:\n    Schaul, T., Quan, J., Antonoglou, I., & Silver, D. (2015).\n    \"Prioritized Experience Replay\"\n    arXiv:1511.05952", "source": "core\\features\\deep_rl_trading.py", "category": "general"}
{"instruction": "What is the TD3Config class and how do I use it?", "input": "", "output": "The TD3Config class:\n\nTD3 Configuration.\n\nKey innovations from Fujimoto et al. (2018):\n1. Twin critics (two Q-networks) - reduces overestimation\n2. Delayed policy updates - improves stability\n3. Target policy smoothing - regularizes learning", "source": "core\\features\\deep_rl_trading.py", "category": "general"}
{"instruction": "What is the TD3Actor class and how do I use it?", "input": "", "output": "The TD3Actor class:\n\nTD3 Actor Network (Deterministic Policy).\n\nArchitecture follows Fujimoto et al. (2018):\n- Two hidden layers with ReLU\n- Tanh output for bounded actions", "source": "core\\features\\deep_rl_trading.py", "category": "general"}
{"instruction": "What is the TD3Critic class and how do I use it?", "input": "", "output": "The TD3Critic class:\n\nTD3 Twin Critics (Two Q-Networks).\n\n\"We propose to address this by taking the minimum value between\na pair of critics to limit overestimation.\"\n- Fujimoto et al. (2018)", "source": "core\\features\\deep_rl_trading.py", "category": "general"}
{"instruction": "What is the TD3Trader class and how do I use it?", "input": "", "output": "The TD3Trader class:\n\nTD3 (Twin Delayed DDPG) for Forex Trading.\n\nCitation:\n    Fujimoto, S., Hoof, H., & Meger, D. (2018).\n    \"Addressing Function Approximation Error in Actor-Critic Methods\"\n    ICML 2018.\n\nKey Features:\n    1. Twin critics reduce overestimation bias\n    2. Delayed policy updates improve stability\n    3. Target policy smoothing acts as regularizer\n\nForex Adaptations:\n    - Action space: position size [-1, 1]\n    - State: price features + portfolio state\n    - Reward: risk-adjusted returns with transaction costs", "source": "core\\features\\deep_rl_trading.py", "category": "risk"}
{"instruction": "What is the SACConfig class and how do I use it?", "input": "", "output": "The SACConfig class:\n\nSAC Configuration.\n\nKey features from Haarnoja et al. (2018):\n1. Maximum entropy framework\n2. Automatic temperature tuning\n3. Stochastic policy for exploration", "source": "core\\features\\deep_rl_trading.py", "category": "volatility"}
{"instruction": "What is the SACGaussianActor class and how do I use it?", "input": "", "output": "The SACGaussianActor class:\n\nSAC Gaussian Policy Network.\n\n\"Our method instead learns a stochastic policy to implicitly\ntrade off between exploration and exploitation.\"\n- Haarnoja et al. (2018)", "source": "core\\features\\deep_rl_trading.py", "category": "volatility"}
{"instruction": "What is the SACCritic class and how do I use it?", "input": "", "output": "The SACCritic class:\n\nSAC Twin Q-Networks (same as TD3).", "source": "core\\features\\deep_rl_trading.py", "category": "general"}
{"instruction": "What is the SACTrader class and how do I use it?", "input": "", "output": "The SACTrader class:\n\nSoft Actor-Critic for Forex Trading.\n\nCitation:\n    Haarnoja, T., Zhou, A., Abbeel, P., & Levine, S. (2018).\n    \"Soft Actor-Critic: Off-Policy Maximum Entropy Deep Reinforcement\n    Learning with a Stochastic Actor\"\n    ICML 2018.\n\nKey Features:\n    1. Maximum entropy RL - encourages exploration\n    2. Automatic temperature adjustment\n    3. Stochastic policy - better exploration than deterministic\n\n\"The entropy term encourages the policy to explore more widely,\nwhile the maximum entropy objective helps to prevent the policy\nfrom prematurely converging to a bad local optimum.\"\n- Haarnoja et al. (2018)\n\nForex Adaptations:\n    - Continuous position sizing with natural exploration\n    - Entropy bonus helps discover diverse trading strategies\n    - Robust to changing market conditions", "source": "core\\features\\deep_rl_trading.py", "category": "volatility"}
{"instruction": "What is the EarnHFTConfig class and how do I use it?", "input": "", "output": "The EarnHFTConfig class:\n\nEarnHFT Configuration.\n\nFrom Qin et al. (2024) AAAI:\n\"We propose EarnHFT, a hierarchical RL framework that trains\nlow-level agents on different market trends and a router to\nselect suitable agents based on macro market information.\"", "source": "core\\features\\deep_rl_trading.py", "category": "rl"}
{"instruction": "What is the EarnHFTSubAgent class and how do I use it?", "input": "", "output": "The EarnHFTSubAgent class:\n\nEarnHFT Sub-Agent for specific market condition.\n\n\"Each low-level agent is trained to make optimal decisions\nunder a specific market trend.\"\n- Qin et al. (2024)", "source": "core\\features\\deep_rl_trading.py", "category": "rl"}
{"instruction": "What is the EarnHFTRouter class and how do I use it?", "input": "", "output": "The EarnHFTRouter class:\n\nEarnHFT Router Network.\n\n\"The router network selects which low-level agent to use\nbased on the macro market state.\"\n- Qin et al. (2024)", "source": "core\\features\\deep_rl_trading.py", "category": "rl"}
{"instruction": "What is the EarnHFTTrader class and how do I use it?", "input": "", "output": "The EarnHFTTrader class:\n\nEarnHFT: Efficient Hierarchical RL for High Frequency Trading.\n\nCitation:\n    Qin, M., Sun, S., Zhang, W., Xia, H., Wang, X., & An, B. (2024).\n    \"EarnHFT: Efficient Hierarchical Reinforcement Learning for\n    High Frequency Trading\"\n    AAAI 2024, 38(13), 14669-14676.\n\nArchitecture:\n    1. Multiple sub-agents specialized for different market trends\n    2. Router network selects appropriate sub-agent\n    3. Hierarchical structure enables efficient adaptation\n\n\"EarnHFT significantly outperforms 6 state-of-the-art baselines\nin 6 popular financial criteria, exceeding the runner-up by 30%\nin profitability.\"\n- Qin et al. (2024)\n\nMarket Trends:\n    - Bull (uptrend): sub_agent[0]\n    - Neutral (sideways): sub_agent[1]\n    - Bear (downtrend): sub_agent[2]", "source": "core\\features\\deep_rl_trading.py", "category": "rl"}
{"instruction": "What is the MacroHFTConfig class and how do I use it?", "input": "", "output": "The MacroHFTConfig class:\n\nMacroHFT Configuration.\n\nFrom Zong et al. (2024) KDD:\n\"MacroHFT uses memory-augmented networks to capture long-term\nmarket patterns and conditional adapters to handle regime changes.\"", "source": "core\\features\\deep_rl_trading.py", "category": "regime"}
{"instruction": "What is the MemoryAugmentedNetwork class and how do I use it?", "input": "", "output": "The MemoryAugmentedNetwork class:\n\nMemory-Augmented Neural Network for MacroHFT.\n\n\"The memory module stores historical market patterns,\nenabling the agent to reason over long-term dependencies.\"\n- Zong et al. (2024)", "source": "core\\features\\deep_rl_trading.py", "category": "rl"}
{"instruction": "What is the ConditionalAdapter class and how do I use it?", "input": "", "output": "The ConditionalAdapter class:\n\nConditional Adapter for market regime adaptation.\n\n\"Each sub-agent uses a conditional adapter to adjust\nits policy based on current market conditions.\"\n- Zong et al. (2024)", "source": "core\\features\\deep_rl_trading.py", "category": "rl"}
{"instruction": "What is the MacroHFTTrader class and how do I use it?", "input": "", "output": "The MacroHFTTrader class:\n\nMacroHFT: Memory Augmented Context-aware RL for HFT.\n\nCitation:\n    Zong, Y., et al. (2024).\n    \"MacroHFT: Memory Augmented Context-aware Reinforcement Learning\n    On High Frequency Trading\"\n    KDD 2024.\n\nKey Innovations:\n    1. External memory for long-term pattern storage\n    2. Conditional adapters for regime adaptation\n    3. Multiple sub-agents for different market indicators\n\n\"MacroHFT first trains multiple types of sub-agents with market\ndata decomposed according to various financial indicators, where\neach agent owns a conditional adapter to adjust its trading policy\naccording to market conditions.\"\n- Zong et al. (2024)", "source": "core\\features\\deep_rl_trading.py", "category": "risk"}
{"instruction": "What is the DeepScalperConfig class and how do I use it?", "input": "", "output": "The DeepScalperConfig class:\n\nDeepScalper Configuration.\n\nFrom Sun et al. (2022) CIKM:\n\"DeepScalper uses hindsight bonus reward and auxiliary task\nto improve risk management in intraday trading.\"", "source": "core\\features\\deep_rl_trading.py", "category": "risk"}
{"instruction": "What is the RiskAwareNetwork class and how do I use it?", "input": "", "output": "The RiskAwareNetwork class:\n\nRisk-Aware Q-Network with auxiliary risk prediction.\n\n\"We introduce an auxiliary task to predict future risk,\nenabling the agent to make more informed decisions.\"\n- Sun et al. (2022)", "source": "core\\features\\deep_rl_trading.py", "category": "risk"}
{"instruction": "What is the DeepScalperTrader class and how do I use it?", "input": "", "output": "The DeepScalperTrader class:\n\nDeepScalper: Risk-Aware RL for Intraday Trading.\n\nCitation:\n    Sun, S., et al. (2022).\n    \"DeepScalper: A Risk-Aware Reinforcement Learning Framework to\n    Capture Fleeting Intraday Trading Opportunities\"\n    CIKM 2022.\n\nKey Features:\n    1. Hindsight bonus reward for learning from missed opportunities\n    2. Auxiliary risk prediction task\n    3. Risk-adjusted action selection\n\n\"DeepScalper significantly outperforms state-of-the-art baselines\nin terms of four financial criteria.\"\n- Sun et al. (2022)", "source": "core\\features\\deep_rl_trading.py", "category": "risk"}
{"instruction": "What is the DeepRLFeatureGenerator class and how do I use it?", "input": "", "output": "The DeepRLFeatureGenerator class:\n\nGenerate features from deep RL agent states for analysis.", "source": "core\\features\\deep_rl_trading.py", "category": "rl"}
{"instruction": "Explain the Generate Deep Rl Features function", "input": "", "output": "Function: generate_deep_rl_features\n\nConvenience function to generate deep RL features.", "source": "core\\features\\deep_rl_trading.py", "category": "rl"}
{"instruction": "Explain the Select Action function", "input": "", "output": "Function: select_action\n\nSelect action with optional exploration noise.", "source": "core\\features\\deep_rl_trading.py", "category": "general"}
{"instruction": "What is the formula for Train Step?", "input": "", "output": "Perform one training step.\n\nImplements TD3 algorithm:\n1. Sample mini-batch\n2. Compute target Q with clipped double Q-learning\n3. Update critics\n4. Delayed policy update with smoothing", "source": "core\\features\\deep_rl_trading.py", "category": "general"}
{"instruction": "Explain the Train Step function", "input": "", "output": "Function: train_step\n\nPerform one training step.\n\nImplements TD3 algorithm:\n1. Sample mini-batch\n2. Compute target Q with clipped double Q-learning\n3. Update critics\n4. Delayed policy update with smoothing", "source": "core\\features\\deep_rl_trading.py", "category": "general"}
{"instruction": "Explain the Store Transition function", "input": "", "output": "Function: store_transition\n\nStore experience in replay buffer.", "source": "core\\features\\deep_rl_trading.py", "category": "general"}
{"instruction": "Explain the Save function", "input": "", "output": "Function: save\n\nSave model weights.", "source": "core\\features\\deep_rl_trading.py", "category": "general"}
{"instruction": "Explain the Load function", "input": "", "output": "Function: load\n\nLoad model weights.", "source": "core\\features\\deep_rl_trading.py", "category": "general"}
{"instruction": "Explain the Sample function", "input": "", "output": "Function: sample\n\nSample action and compute log probability.", "source": "core\\features\\deep_rl_trading.py", "category": "general"}
{"instruction": "Explain the Get Action function", "input": "", "output": "Function: get_action\n\nGet action for evaluation.", "source": "core\\features\\deep_rl_trading.py", "category": "general"}
{"instruction": "Explain the Select Action function", "input": "", "output": "Function: select_action\n\nSelect action from stochastic policy.", "source": "core\\features\\deep_rl_trading.py", "category": "volatility"}
{"instruction": "What is the formula for Train Step?", "input": "", "output": "Perform one SAC training step.\n\nImplements:\n1. Critic update with entropy-augmented target\n2. Actor update maximizing Q + entropy\n3. Temperature update (if auto_alpha)", "source": "core\\features\\deep_rl_trading.py", "category": "alpha"}
{"instruction": "Explain the Train Step function", "input": "", "output": "Function: train_step\n\nPerform one SAC training step.\n\nImplements:\n1. Critic update with entropy-augmented target\n2. Actor update maximizing Q + entropy\n3. Temperature update (if auto_alpha)", "source": "core\\features\\deep_rl_trading.py", "category": "alpha"}
{"instruction": "Explain the Detect Trend function", "input": "", "output": "Function: detect_trend\n\nDetect market trend from recent prices.\n\nReturns:\n    0: Bull (uptrend)\n    1: Neutral (sideways)\n    2: Bear (downtrend)", "source": "core\\features\\deep_rl_trading.py", "category": "general"}
{"instruction": "Explain the Select Action function", "input": "", "output": "Function: select_action\n\nSelect action using hierarchical structure.\n\nReturns:\n    (action, selected_agent_idx)", "source": "core\\features\\deep_rl_trading.py", "category": "rl"}
{"instruction": "What is the formula for Train Step?", "input": "", "output": "Train sub-agent for specific market trend.\n\n\"Each sub-agent learns independently on its respective\nmarket trend data.\"\n- Qin et al. (2024)", "source": "core\\features\\deep_rl_trading.py", "category": "rl"}
{"instruction": "Explain the Train Step function", "input": "", "output": "Function: train_step\n\nTrain sub-agent for specific market trend.\n\n\"Each sub-agent learns independently on its respective\nmarket trend data.\"\n- Qin et al. (2024)", "source": "core\\features\\deep_rl_trading.py", "category": "rl"}
{"instruction": "What is the formula for Train Router?", "input": "", "output": "Train router to select appropriate sub-agent.\n\nUses the reward as supervision signal for router learning.", "source": "core\\features\\deep_rl_trading.py", "category": "alpha"}
{"instruction": "Explain the Train Router function", "input": "", "output": "Function: train_router\n\nTrain router to select appropriate sub-agent.\n\nUses the reward as supervision signal for router learning.", "source": "core\\features\\deep_rl_trading.py", "category": "alpha"}
{"instruction": "Explain the Store Transition function", "input": "", "output": "Function: store_transition\n\nStore experience in appropriate buffer based on market trend.", "source": "core\\features\\deep_rl_trading.py", "category": "general"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nRead from memory and augment input.", "source": "core\\features\\deep_rl_trading.py", "category": "general"}
{"instruction": "Explain the Compute Market Condition function", "input": "", "output": "Function: compute_market_condition\n\nExtract market condition features from state.\n\nReturns 4D vector: [trend, volatility, mean_rev, momentum]", "source": "core\\features\\deep_rl_trading.py", "category": "volatility"}
{"instruction": "What is the formula for Select Action?", "input": "", "output": "Select action using memory-augmented hierarchical structure.", "source": "core\\features\\deep_rl_trading.py", "category": "general"}
{"instruction": "Explain the Select Action function", "input": "", "output": "Function: select_action\n\nSelect action using memory-augmented hierarchical structure.", "source": "core\\features\\deep_rl_trading.py", "category": "general"}
{"instruction": "Explain the Train Step function", "input": "", "output": "Function: train_step\n\nTrain MacroHFT with memory and adapters.", "source": "core\\features\\deep_rl_trading.py", "category": "general"}
{"instruction": "Explain the Compute Actual Risk function", "input": "", "output": "Function: compute_actual_risk\n\nCompute actual risk from returns (for auxiliary task supervision).", "source": "core\\features\\deep_rl_trading.py", "category": "risk"}
{"instruction": "What is the formula for Compute Hindsight Bonus?", "input": "", "output": "Compute hindsight bonus reward.\n\n\"The hindsight bonus encourages the agent to learn from\nwhat would have been the optimal action in hindsight.\"\n- Sun et al. (2022)", "source": "core\\features\\deep_rl_trading.py", "category": "rl"}
{"instruction": "Explain the Compute Hindsight Bonus function", "input": "", "output": "Function: compute_hindsight_bonus\n\nCompute hindsight bonus reward.\n\n\"The hindsight bonus encourages the agent to learn from\nwhat would have been the optimal action in hindsight.\"\n- Sun et al. (2022)", "source": "core\\features\\deep_rl_trading.py", "category": "rl"}
{"instruction": "What is the formula for Select Action?", "input": "", "output": "Select action with risk-awareness.\n\nReturns:\n    (action, predicted_risk)", "source": "core\\features\\deep_rl_trading.py", "category": "risk"}
{"instruction": "Explain the Select Action function", "input": "", "output": "Function: select_action\n\nSelect action with risk-awareness.\n\nReturns:\n    (action, predicted_risk)", "source": "core\\features\\deep_rl_trading.py", "category": "risk"}
{"instruction": "Explain the Store Transition function", "input": "", "output": "Function: store_transition\n\nStore transition with risk label.", "source": "core\\features\\deep_rl_trading.py", "category": "risk"}
{"instruction": "What is the formula for Train Step?", "input": "", "output": "Train DeepScalper with risk-aware learning.", "source": "core\\features\\deep_rl_trading.py", "category": "risk"}
{"instruction": "Explain the Train Step function", "input": "", "output": "Function: train_step\n\nTrain DeepScalper with risk-aware learning.", "source": "core\\features\\deep_rl_trading.py", "category": "risk"}
{"instruction": "What is the formula for Generate Features?", "input": "", "output": "Generate deep RL-derived features.\n\nFeatures:\n- Q-value estimates\n- Action probabilities\n- Risk predictions\n- Confidence scores", "source": "core\\features\\deep_rl_trading.py", "category": "risk"}
{"instruction": "Explain the Generate Features function", "input": "", "output": "Function: generate_features\n\nGenerate deep RL-derived features.\n\nFeatures:\n- Q-value estimates\n- Action probabilities\n- Risk predictions\n- Confidence scores", "source": "core\\features\\deep_rl_trading.py", "category": "risk"}
{"instruction": "Explain the purpose of Emerging Markets Quantitative Finance Factors", "input": "", "output": "Emerging Markets Quantitative Finance Factors\n=============================================\nQuantitative formulas specific to emerging market currencies.\n\nRegions Covered:\n- Brazil (BRL)\n- Russia (RUB) - historical research\n- Southeast Asia (SGD, HKD, CNH)\n- Mexico (MXN)\n- Turkey (TRY)\n- South Africa (ZAR)\n\nSources:\n1. B3 Exchange (Brasil Bolsa Balcao) Research\n   - Quantitative Brokers algorithms: Bolt, Strobe, Closer\n   - PUMA trading platform research\n   - ScienceDirect: \"Algorithmic trading impact on spreads\"\n\n2. MOEX (Moscow Exchange) Historical Research\n   - Pre-2022 FX market research\n   - Petrocurrency dynamics (RUB-oil correlation)\n\n3. Asian Central Banks Research\n   - MAS (Singapore): SGD NEER band management\n   - HKMA: HKD peg dynamics\n   - PBOC: CNH-CNY spread research\n\n4. Mexican Central Bank (Banxico)\n   - MXN carry trade analysis\n   - Remittance flow impact\n\n5. SARB (South African Reserve Bank)\n   - ZAR commodity currency dynamics\n\nTotal: 20 factors organized into:\n- BRL Carry (4): Brazil high-rate environment\n- Petrocurrency (4): Oil-correlated currencies\n- Asian Pegs (4): Managed currency dynamics\n- EM Volatility (4): Emerging market risk\n- Commodity FX (4): Commodity-linked currencies", "source": "core\\features\\emerging_quant.py", "category": "alpha"}
{"instruction": "What is the EmergingMarketsFeatures class and how do I use it?", "input": "", "output": "The EmergingMarketsFeatures class:\n\nEmerging Markets Quantitative Features.\n\nBased on research from:\n- B3 Exchange (Brazil)\n- Asian central banks (MAS, HKMA, PBOC)\n- Banxico (Mexico)\n- SARB (South Africa)\n- Historical MOEX research (Russia)\n\nSpecialized for EM currencies with unique characteristics:\n- High carry environments\n- Commodity linkages\n- Peg/band management\n- Political risk premiums\n\nUsage:\n    features = EmergingMarketsFeatures()\n    df_features = features.generate_all(ohlcv_df)", "source": "core\\features\\emerging_quant.py", "category": "risk"}
{"instruction": "Show me a code example for EmergingMarketsFeatures", "input": "", "output": "features = EmergingMarketsFeatures()\n    df_features = features.generate_all(ohlcv_df)", "source": "core\\features\\emerging_quant.py", "category": "risk"}
{"instruction": "Explain the Generate Emerging Features function", "input": "", "output": "Function: generate_emerging_features\n\nGenerate Emerging Markets features.\n\nArgs:\n    df: OHLCV DataFrame\n\nReturns:\n    DataFrame with 20 emerging market factors", "source": "core\\features\\emerging_quant.py", "category": "alpha"}
{"instruction": "Explain the Generate All function", "input": "", "output": "Function: generate_all\n\nGenerate all Emerging Markets features.\n\nArgs:\n    df: DataFrame with columns: open, high, low, close, volume\n\nReturns:\n    DataFrame with 20 factor columns", "source": "core\\features\\emerging_quant.py", "category": "alpha"}
{"instruction": "Explain the Get Feature Names function", "input": "", "output": "Function: get_feature_names\n\nGet list of all feature names.", "source": "core\\features\\emerging_quant.py", "category": "general"}
{"instruction": "Explain the Get Factor Category function", "input": "", "output": "Function: get_factor_category\n\nGet the category of a factor by name.", "source": "core\\features\\emerging_quant.py", "category": "alpha"}
{"instruction": "Explain the purpose of HFT Feature Engineering Pipeline", "input": "", "output": "HFT Feature Engineering Pipeline\n================================\nUnified feature generation combining all signal sources for HFT.\n\nSignal Sources (Chinese RenTech + USA Renaissance):\n- Alpha101 (WorldQuant) - 62+ alphas\n- Alpha191 (国泰君安 Guotai Junan) - 191 short-period factors\n- Renaissance Signals - 50+ weak signals\n- Order Flow (OFI/OEI/VPIN) - Microstructure signals\n- Cross-Asset - DXY, VIX, correlations\n- Microstructure Vol - TSRV, noise filtering\n- HAR-RV Volatility - Multi-scale volatility (Corsi 2009)\n- Range-Based Volatility - Parkinson (1980), Garman-Klass (1980),\n                           Rogers-Satchell (1991), Yang-Zhang (2000)\n- Market Impact Models - Kyle (1985), Glosten-Milgrom (1985),\n                         Roll (1984), Huang-Stoll (1997)\n- Technical - Fast indicators for HFT\n\nRenaissance Technologies Inferred Methods:\n- Advanced Kalman Filters (EKF/UKF) - State estimation\n- GARCH Family - Volatility forecasting\n- Jump Detection (Bipower Variation) - News vs continuous trading\n- Regime Features (HMM) - Market state detection\n- Spectral/Wavelet Analysis - Cycle detection\n\nChinese Gold Standard Algorithms (幻方量化, 九坤投资, 明汯投资):\n- Microprice (Stoikov 2018) - Better mid-price estimation\n- Smart Money Factor 2.0 (开源证券) - Institutional flow detection\n- Kyle Lambda - Market impact estimation\n- Amihud Illiquidity - Non-liquidity factor\n- Integrated OFI (Cont 2014) - Order flow imbalance\n- Lee-Ready Classification - Trade direction (85% accuracy)\n- Book/Queue Imbalance - LOB pressure signals\n- Higher-Order Moments - Skewness, kurtosis, tail risk\n- Intraday Momentum - Session effects\n- IC/ICIR Engine - Factor evaluation\n\nTarget: 500+ features per tick for ML ensemble", "source": "core\\features\\engine.py", "category": "alpha"}
{"instruction": "What is the FeatureConfig class and how do I use it?", "input": "", "output": "The FeatureConfig class:\n\nFeature engineering configuration.", "source": "core\\features\\engine.py", "category": "general"}
{"instruction": "What is the FastTechnicalFeatures class and how do I use it?", "input": "", "output": "The FastTechnicalFeatures class:\n\nUltra-fast technical indicators for HFT.\nOptimized for tick-by-tick computation.", "source": "core\\features\\engine.py", "category": "microstructure"}
{"instruction": "What is the HFTFeatureEngine class and how do I use it?", "input": "", "output": "The HFTFeatureEngine class:\n\nUnified HFT Feature Engineering Engine.\n\nCombines all signal sources into a single feature vector.\nOptimized for real-time tick-by-tick processing.\n\nUsage:\n    engine = HFTFeatureEngine()\n    engine.initialize(historical_data)\n\n    for tick in live_ticks:\n        features = engine.process_tick(tick)\n        prediction = model.predict(features)", "source": "core\\features\\engine.py", "category": "alpha"}
{"instruction": "Show me a code example for HFTFeatureEngine", "input": "", "output": "engine = HFTFeatureEngine()\n    engine.initialize(historical_data)", "source": "core\\features\\engine.py", "category": "alpha"}
{"instruction": "What is the FeatureSelector class and how do I use it?", "input": "", "output": "The FeatureSelector class:\n\nFeature selection for ML training.\nRemoves low-variance and highly correlated features.", "source": "core\\features\\engine.py", "category": "risk"}
{"instruction": "Explain the Create Hft Feature Engine function", "input": "", "output": "Function: create_hft_feature_engine\n\nFactory function to create feature engine.", "source": "core\\features\\engine.py", "category": "alpha"}
{"instruction": "Explain the Update function", "input": "", "output": "Function: update\n\nUpdate with new tick and return features.", "source": "core\\features\\engine.py", "category": "microstructure"}
{"instruction": "Explain the Compute Features function", "input": "", "output": "Function: compute_features\n\nCompute all fast technical features.", "source": "core\\features\\engine.py", "category": "general"}
{"instruction": "Explain the Initialize function", "input": "", "output": "Function: initialize\n\nInitialize engine with historical data.\n\nArgs:\n    historical_data: DataFrame with columns [timestamp, bid, ask, volume]\n    symbol: Trading symbol", "source": "core\\features\\engine.py", "category": "volatility"}
{"instruction": "What is the formula for Process Tick?", "input": "", "output": "Process a single tick and return features.\n\nArgs:\n    symbol: Trading symbol\n    bid: Bid price\n    ask: Ask price\n    volume: Trade volume\n    timestamp: Tick timestamp\n\nReturns:\n    Dict of feature_name -> feature_value", "source": "core\\features\\engine.py", "category": "volatility"}
{"instruction": "Explain the Process Tick function", "input": "", "output": "Function: process_tick\n\nProcess a single tick and return features.\n\nArgs:\n    symbol: Trading symbol\n    bid: Bid price\n    ask: Ask price\n    volume: Trade volume\n    timestamp: Tick timestamp\n\nReturns:\n    Dict of feature_name -> feature_value", "source": "core\\features\\engine.py", "category": "volatility"}
{"instruction": "Explain the Get Feature Vector function", "input": "", "output": "Function: get_feature_vector\n\nConvert feature dict to numpy array in consistent order.", "source": "core\\features\\engine.py", "category": "general"}
{"instruction": "What is the formula for Get Feature Dataframe?", "input": "", "output": "Convert feature dict to single-row DataFrame.", "source": "core\\features\\engine.py", "category": "general"}
{"instruction": "Explain the Get Feature Dataframe function", "input": "", "output": "Function: get_feature_dataframe\n\nConvert feature dict to single-row DataFrame.", "source": "core\\features\\engine.py", "category": "general"}
{"instruction": "Explain the Batch Process function", "input": "", "output": "Function: batch_process\n\nProcess entire DataFrame and add all features.\n\nArgs:\n    data: DataFrame with price data\n    symbol: Trading symbol\n\nReturns:\n    DataFrame with all features added", "source": "core\\features\\engine.py", "category": "general"}
{"instruction": "Explain the Fit function", "input": "", "output": "Function: fit\n\nFit selector to training data.", "source": "core\\features\\engine.py", "category": "general"}
{"instruction": "Explain the Transform function", "input": "", "output": "Function: transform\n\nTransform data to selected features only.", "source": "core\\features\\engine.py", "category": "general"}
{"instruction": "Explain the Fit Transform function", "input": "", "output": "Function: fit_transform\n\nFit and transform in one step.", "source": "core\\features\\engine.py", "category": "general"}
{"instruction": "Explain the purpose of European Academic Quantitative Finance Factors", "input": "", "output": "European Academic Quantitative Finance Factors\n===============================================\nGold standard quantitative formulas from European research institutions.\n\nSources:\n1. ETH Zurich - Swiss Finance Institute\n   - Heston stochastic volatility implementation\n   - Risk factor decomposition\n\n2. Imperial College London - Mathematical Finance\n   - Jump-diffusion models\n   - Optimal execution\n\n3. Oxford-Man Institute of Quantitative Finance\n   - Realized volatility measures\n   - Market microstructure\n\n4. Paris-Dauphine / HEC Paris\n   - SABR model for FX options\n   - Stochastic local volatility\n\n5. Frankfurt School of Finance & Management\n   - Deutsche Borse microstructure research\n   - ECB policy impact models\n\n6. Gatheral (2018) - \"Volatility is Rough\"\n   - Rough volatility framework\n   - Fractional Brownian motion\n\nTotal: 15 factors organized into:\n- Heston Volatility (3): Stochastic volatility features\n- SABR Features (3): Smile dynamics\n- Rough Volatility (3): Fractional vol features\n- Jump Detection (3): Merton jump-diffusion\n- ECB Policy (3): European central bank impact", "source": "core\\features\\europe_quant.py", "category": "alpha"}
{"instruction": "What is the EuropeQuantFeatures class and how do I use it?", "input": "", "output": "The EuropeQuantFeatures class:\n\nEuropean Academic Quantitative Features.\n\nBased on research from:\n- ETH Zurich (Heston model implementation)\n- Imperial College London (jump detection)\n- Oxford-Man Institute (realized volatility)\n- Paris-Dauphine (SABR model)\n- Frankfurt School (ECB policy)\n\nImplements academic-grade volatility models used in European quantitative finance.\n\nUsage:\n    features = EuropeQuantFeatures()\n    df_features = features.generate_all(ohlcv_df)", "source": "core\\features\\europe_quant.py", "category": "volatility"}
{"instruction": "Show me a code example for EuropeQuantFeatures", "input": "", "output": "features = EuropeQuantFeatures()\n    df_features = features.generate_all(ohlcv_df)", "source": "core\\features\\europe_quant.py", "category": "volatility"}
{"instruction": "Explain the Generate Europe Features function", "input": "", "output": "Function: generate_europe_features\n\nGenerate European Academic features.\n\nArgs:\n    df: OHLCV DataFrame\n\nReturns:\n    DataFrame with 15 European quant factors", "source": "core\\features\\europe_quant.py", "category": "alpha"}
{"instruction": "Explain the Generate All function", "input": "", "output": "Function: generate_all\n\nGenerate all Europe Quant features.\n\nArgs:\n    df: DataFrame with columns: open, high, low, close, volume\n\nReturns:\n    DataFrame with 15 factor columns", "source": "core\\features\\europe_quant.py", "category": "alpha"}
{"instruction": "Explain the Get Feature Names function", "input": "", "output": "Function: get_feature_names\n\nGet list of all feature names.", "source": "core\\features\\europe_quant.py", "category": "general"}
{"instruction": "Explain the Get Factor Category function", "input": "", "output": "Function: get_factor_category\n\nGet the category of a factor by name.", "source": "core\\features\\europe_quant.py", "category": "alpha"}
{"instruction": "Explain the purpose of Experimental Feature Engine - Integrates ALL experimental modules", "input": "", "output": "Experimental Feature Engine - Integrates ALL experimental modules\n=================================================================\nCombines 150+ features from core/_experimental/ modules:\n\n1. Kalman Filters (10 features)\n   - Extended Kalman Filter\n   - Unscented Kalman Filter\n   - Adaptive Kalman\n\n2. GARCH Models (5 features)\n   - GARCH(1,1)\n   - EGARCH\n   - GJR-GARCH\n\n3. Chinese HFT Factors (12 features)\n   - Microprice\n   - Smart Money\n   - Kyle lambda\n\n4. Attention Factors (7 features)\n   - Stat arb (Sharpe 4.0+)\n   - Cross-sectional attention\n\n5. Market Impact (5 features)\n   - Kyle model\n   - Glosten-Milgrom\n   - Hasbrouck\n\n6. Order Flow (8 features)\n   - OFI (Order Flow Imbalance)\n   - OEI (Order Execution Imbalance)\n   - VPIN\n   - Hawkes\n\n7. Jump Detection (3 features)\n   - Lee-Mykland\n   - Hawkes intensity\n\n8. HAR-RV Volatility (3 features)\n   - Daily, weekly, monthly components\n\n9. Alpha191 Guotai Junan (30 top selections)\n   - Chinese institutional factors\n\n10. LOB Features (8 features)\n    - Book imbalance\n    - Depth ratio\n\n11. Regime Features (5 features)\n    - HMM states\n    - Markov switching\n\n12. Range Volatility (4 features)\n    - Parkinson\n    - Garman-Klass\n\n13. Elite Quant Factors (20 features)\n    - Selected from research papers\n\n14. MyTT China Formulas (30+ features)\n    - MACD, KDJ, RSI, BOLL, WR, BIAS\n    - DMI, TRIX, VR, EMV, DPO, BRAR\n    - ATR, CCI, PSY, TAQ, MTM, ROC\n\nTotal: 180+ experimental features", "source": "core\\features\\experimental_engine.py", "category": "alpha"}
{"instruction": "What is the ExperimentalConfig class and how do I use it?", "input": "", "output": "The ExperimentalConfig class:\n\nConfiguration for experimental feature engine.", "source": "core\\features\\experimental_engine.py", "category": "general"}
{"instruction": "What is the ExperimentalFeatureEngine class and how do I use it?", "input": "", "output": "The ExperimentalFeatureEngine class:\n\nUnified engine for all experimental features.\n\nUsage:\n    engine = ExperimentalFeatureEngine()\n    features = engine.generate_all(df)", "source": "core\\features\\experimental_engine.py", "category": "general"}
{"instruction": "Show me a code example for ExperimentalFeatureEngine", "input": "", "output": "engine = ExperimentalFeatureEngine()\n    features = engine.generate_all(df)", "source": "core\\features\\experimental_engine.py", "category": "general"}
{"instruction": "Explain the Generate Experimental Features function", "input": "", "output": "Function: generate_experimental_features\n\nConvenience function to generate all experimental features.", "source": "core\\features\\experimental_engine.py", "category": "general"}
{"instruction": "Explain the Create Experimental Engine function", "input": "", "output": "Function: create_experimental_engine\n\nFactory function to create experimental feature engine.\n\nArgs:\n    config: Experimental config (uses defaults if None)\n    verbose: Enable verbose logging\n\nReturns:\n    ExperimentalFeatureEngine instance", "source": "core\\features\\experimental_engine.py", "category": "alpha"}
{"instruction": "Explain the Generate All function", "input": "", "output": "Function: generate_all\n\nGenerate all experimental features.\n\nArgs:\n    df: DataFrame with OHLCV data\n\nReturns:\n    DataFrame with experimental features", "source": "core\\features\\experimental_engine.py", "category": "general"}
{"instruction": "Explain the purpose of Fast Feature Engine for Batch Training", "input": "", "output": "Fast Feature Engine for Batch Training\n=======================================\nVectorized feature generation - 10x faster than HFTFeatureEngine.\nUses pandas/numpy operations instead of tick-by-tick processing.\n\nTarget: Generate 100+ features in <30 seconds per 100k ticks.", "source": "core\\features\\fast_engine.py", "category": "microstructure"}
{"instruction": "What is the FastFeatureEngine class and how do I use it?", "input": "", "output": "The FastFeatureEngine class:\n\nFast vectorized feature generation for batch training.\n\nFeatures categories:\n- Returns (multi-horizon)\n- Volatility (rolling)\n- Spread/Microstructure\n- Technical indicators\n- Statistical moments", "source": "core\\features\\fast_engine.py", "category": "volatility"}
{"instruction": "Explain the Create Targets function", "input": "", "output": "Function: create_targets\n\nCreate prediction targets.\n\nArgs:\n    df: DataFrame with mid price\n    horizons: List of forward horizons in ticks\n\nReturns:\n    DataFrame with target columns added", "source": "core\\features\\fast_engine.py", "category": "microstructure"}
{"instruction": "Explain the Batch Process Symbol function", "input": "", "output": "Function: batch_process_symbol\n\nLoad and process a symbol's data.\n\nArgs:\n    symbol: Currency pair symbol\n    data_dir: Directory with CSV files\n\nReturns:\n    Processed DataFrame or None if failed", "source": "core\\features\\fast_engine.py", "category": "general"}
{"instruction": "Explain the Process function", "input": "", "output": "Function: process\n\nGenerate all features for a dataframe.\n\nArgs:\n    df: DataFrame with columns: timestamp, bid, ask (or close)\n    symbol: Optional symbol name\n\nReturns:\n    DataFrame with all features added", "source": "core\\features\\fast_engine.py", "category": "microstructure"}
{"instruction": "What is the source paper for microprice?", "input": "", "output": "The source is: Stoikov (2018). ", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "Explain the purpose of Gitee Chinese Quantitative Factors for Forex Trading", "input": "", "output": "Gitee Chinese Quantitative Factors for Forex Trading\n=====================================================\nResearch from Gitee/GitHub Chinese quant repositories adapted for forex.\n\nRESEARCH SOURCES:\n-----------------\n[1] QUANTAXIS (yutiansut) - 中国最大量化框架\n    Gitee: https://gitee.com/yutiansut/QUANTAXIS\n    GitHub: https://github.com/yutiansut/QUANTAXIS\n    Stars: 8.5k+\n    License: MIT\n\n[2] QuantsPlaybook (hugo2046) - 券商金工研报复现\n    GitHub: https://github.com/hugo2046/QuantsPlaybook\n    Stars: 3.3k\n    Content: 100+ strategies from Chinese securities research\n\n[3] Alpha-101-GTJA-191 - 国泰君安191因子\n    GitHub: https://github.com/wpwpwpwpwpwpwpwpwp/Alpha-101-GTJA-191\n    Original: 国泰君安 \"基于短周期价量特征的多因子选股体系\" (2017)\n    Stars: 116\n\n[4] JoinQuant Alpha191\n    GitHub: https://github.com/JoinQuant/jqdatasdk/blob/master/jqdatasdk/alpha191.py\n    Platform: https://joinquant.com/data/dict/alpha191\n\n[5] VPIN Implementation\n    GitHub: https://github.com/jheusser/vpin\n    GitHub: https://github.com/yt-feng/VPIN\n    Stars: 113\n\n[6] Microprice\n    GitHub: https://github.com/sstoikov/microprice\n    Paper: Stoikov (2018) \"The Micro-Price: A High-Frequency Estimator\"\n\n[7] vnpy - 量化交易平台\n    GitHub: https://github.com/vnpy/vnpy\n    Stars: 25k+\n\n[8] Hikyuu - 极速量化框架\n    Gitee: https://gitee.com/fasiondog/hikyuu\n    Stars: 2.5k+\n\nACADEMIC CITATIONS:\n-------------------\n[A1] Amihud, Y. (2002). \"Illiquidity and Stock Returns: Cross-Section and\n     Time-Series Effects.\" Journal of Financial Markets, 5(1), 31-56.\n\n[A2] Cont, R., Kukanov, A., & Stoikov, S. (2014). \"The Price Impact of Order\n     Book Events.\" Journal of Financial Econometrics, 12(1), 47-88.\n\n[A3] Cont, R. (2023). \"Cross-Impact of Order Flow Imbalance in Equity Markets.\"\n     Quantitative Finance. (PCA extension for multi-level OFI)\n\n[A4] Easley, D., López de Prado, M., & O'Hara, M. (2012). \"Flow Toxicity and\n     Liquidity in a High-frequency World.\" Review of Financial Studies, 25(5).\n\n[A5] Kyle, A. S. (1985). \"Continuous Auctions and Insider Trading.\"\n     Econometrica, 53(6), 1315-1335.\n\n[A6] Garman, M. B., & Klass, M. J. (1980). \"On the Estimation of Security Price\n     Volatilities from Historical Data.\" Journal of Business, 53(1), 67-78.\n\n[A7] Yang, D., & Zhang, Q. (2000). \"Drift-Independent Volatility Estimation\n     Based on High, Low, Open, and Close Prices.\" Journal of Business, 73(3).\n\n[A8] Parkinson, M. (1980). \"The Extreme Value Method for Estimating the\n     Variance of the Rate of Return.\" Journal of Business, 53(1), 61-65.\n\n[A9] Rogers, L. C. G., & Satchell, S. E. (1991). \"Estimating Variance from\n     High, Low and Closing Prices.\" Annals of Applied Probability, 1(4).\n\n[A10] Hasbrouck, J. (2009). \"Trading Costs and Returns for U.S. Equities:\n      Estimating Effective Costs from Daily Data.\" Journal of Finance, 64(3).\n\nCHINESE SECURITIES RESEARCH REPORTS:\n------------------------------------\n[R1] 开源证券 《聪明钱因子模型的2.0版本》(2020)\n     URL: https://www.kysec.cn/index.php?m=content&c=index&a=show&catid=108&id=1595\n\n[R2] 招商证券 \"琢璞\"系列报告之十七：高频数据中的知情交易（二）(2020)\n     URL: https://asset.quant-wiki.com/pdf/20200630-招商证券.pdf\n\n[R3] 兴业证券 高频研究系列五：市场微观结构剖析\n     URL: https://asset.quant-wiki.com/pdf/20221109-兴业证券.pdf\n\n[R4] 国泰君安 数量化专题之九十三 (2017)\n     \"基于短周期价量特征的多因子选股体系\"\n\n[R5] 华泰证券 人工智能系列 (遗传规划因子挖掘、图神经网络)\n\n[R6] 海通证券 \"海量\"专题 (深度学习高频因子)\n\nFOREX APPLICABILITY NOTES:\n--------------------------\n- Most Alpha191 factors originally designed for A-shares\n- Factors using only OHLCV data are directly applicable to forex\n- Volume in forex = tick volume (proxy, not actual traded volume)\n- Spread-based factors work well in forex (24h market, variable spreads)\n- Order flow factors require L2 data from broker (e.g., IBKR, LMAX)", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "What is the Alpha191ForexFactors class and how do I use it?", "input": "", "output": "The Alpha191ForexFactors class:\n\nAlpha191 factors adapted for forex trading.\n\nOriginal Source:\n    国泰君安 \"基于短周期价量特征的多因子选股体系\" (2017)\n    GitHub: https://github.com/wpwpwpwpwpwpwpwpwp/Alpha-101-GTJA-191\n    JoinQuant: https://joinquant.com/data/dict/alpha191\n\nSelection Criteria:\n    - Uses only OHLCV data (no fundamentals)\n    - No A-share specific features (no limit-up/down, suspend)\n    - Applicable to 24-hour forex market\n\nForex Applicability: HIGH", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "What is the SmartMoneyFactor2 class and how do I use it?", "input": "", "output": "The SmartMoneyFactor2 class:\n\nSmart Money Factor 2.0 (聪明钱因子模型的2.0版本).\n\nSource:\n    开源证券 《市场微观结构研究系列（3）：聪明钱因子模型的2.0版本》(2020)\n    URL: https://www.kysec.cn/index.php?m=content&c=index&a=show&catid=108&id=1595\n\nReproduced in:\n    QuantsPlaybook (hugo2046)\n    GitHub: https://github.com/hugo2046/QuantsPlaybook/blob/master/B-因子构建类/聪明钱因子模型的2.0版本\n\nMethodology:\n    1. Calculate S-indicator: S_t = |R_t| / sqrt(V_t)\n    2. Rank by S (descending), top 20% cumulative volume = \"smart money\"\n    3. Calculate Q = VWAP_smart / VWAP_all\n    4. Q > 1: Smart money buying high (bearish signal)\n    5. Q < 1: Smart money buying low (bullish signal)\n\nForex Applicability: HIGH", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "What is the VPINEnhanced class and how do I use it?", "input": "", "output": "The VPINEnhanced class:\n\nEnhanced VPIN Implementation.\n\nSources:\n    GitHub: https://github.com/jheusser/vpin (113 stars)\n    GitHub: https://github.com/yt-feng/VPIN\n    招商证券 \"琢璞\"系列报告之十七 (2020)\n\nCitation:\n    Easley, D., López de Prado, M., & O'Hara, M. (2012).\n    \"Flow Toxicity and Liquidity in a High-frequency World\"\n    Review of Financial Studies, 25(5), 1457-1493.\n\nFormula:\n    VPIN = Σ|V_B - V_S| / (n × V_bucket)\n\n    V_B: Buy volume (classified using BVC)\n    V_S: Sell volume\n    n: Number of buckets\n    V_bucket: Volume per bucket (volume clock)\n\nForex Applicability: HIGH", "source": "core\\features\\gitee_chinese_factors.py", "category": "volatility"}
{"instruction": "What is the IntegratedOFI class and how do I use it?", "input": "", "output": "The IntegratedOFI class:\n\nIntegrated Order Flow Imbalance with PCA.\n\nSources:\n    兴业证券 高频研究系列五 (2022)\n    VeighNa社区: https://www.vnpy.com/forum/topic/33101\n\nCitations:\n    Cont, R., Kukanov, A., & Stoikov, S. (2014).\n    \"The Price Impact of Order Book Events\"\n    Journal of Financial Econometrics, 12(1), 47-88.\n\n    Cont, R. (2023). \"Cross-Impact of Order Flow Imbalance in Equity Markets\"\n    Quantitative Finance. (PCA extension)\n\nFormula (Single Level):\n    OFI_t = I{P_bid ≥ P_bid_prev} × V_bid - I{P_bid ≤ P_bid_prev} × V_bid_prev\n          - I{P_ask ≤ P_ask_prev} × V_ask + I{P_ask ≥ P_ask_prev} × V_ask_prev\n\nIntegrated OFI:\n    Extract first principal component from multi-level OFI\n    Explains ~85% of variance (Cont 2023)\n\nForex Applicability: HIGH (with L2 data)", "source": "core\\features\\gitee_chinese_factors.py", "category": "risk"}
{"instruction": "What is the VolatilityEstimators class and how do I use it?", "input": "", "output": "The VolatilityEstimators class:\n\nRange-Based Volatility Estimators.\n\nSources:\n    GitHub: burakbayramli/books/Volatility_Trading_Sinclair\n    TradingView: Garman-Klass-Yang-Zhang indicators\n\nCitations:\n    [A6] Garman, M. B., & Klass, M. J. (1980)\n    [A7] Yang, D., & Zhang, Q. (2000)\n    [A8] Parkinson, M. (1980)\n    [A9] Rogers, L. C. G., & Satchell, S. E. (1991)\n\nAdvantages over close-to-close volatility:\n    - More efficient (lower variance)\n    - Uses intraday information (OHLC)\n    - Better for short-term forecasting\n\nForex Applicability: HIGH", "source": "core\\features\\gitee_chinese_factors.py", "category": "volatility"}
{"instruction": "What is the MarketImpactFactors class and how do I use it?", "input": "", "output": "The MarketImpactFactors class:\n\nMarket Impact and Illiquidity Factors.\n\nCitations:\n    [A5] Kyle, A. S. (1985). \"Continuous Auctions and Insider Trading\"\n    [A1] Amihud, Y. (2002). \"Illiquidity and Stock Returns\"\n    [A10] Hasbrouck, J. (2009). \"Trading Costs and Returns\"\n\nSources:\n    frds.io: https://frds.io/measures/kyle_lambda/\n    QuantsPlaybook\n\nForex Applicability: HIGH", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "What is the MicropriceCalculator class and how do I use it?", "input": "", "output": "The MicropriceCalculator class:\n\nMicroprice - Fair Price Estimation from Order Book.\n\nSource:\n    GitHub: https://github.com/sstoikov/microprice\n    Paper: https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2970694\n\nCitation:\n    Stoikov, S. (2018). \"The Micro-Price: A High-Frequency Estimator of\n    Future Prices.\" Quantitative Finance.\n\nFormula:\n    Microprice = P_mid + Imbalance × Spread / 2\n\n    Imbalance = (V_bid - V_ask) / (V_bid + V_ask)\n\nAlternative (size-weighted):\n    Microprice = (V_ask × P_bid + V_bid × P_ask) / (V_bid + V_ask)\n\nForex Applicability: HIGH (with L2 data)", "source": "core\\features\\gitee_chinese_factors.py", "category": "microstructure"}
{"instruction": "What is the GiteeChineseFactorGenerator class and how do I use it?", "input": "", "output": "The GiteeChineseFactorGenerator class:\n\nUnified generator for all Gitee Chinese quantitative factors.\n\nCombines:\n    - Alpha191 forex-applicable factors (国泰君安)\n    - Smart Money Factor 2.0 (开源证券)\n    - VPIN Enhanced (招商证券/Easley)\n    - Integrated OFI (兴业证券/Cont)\n    - Volatility Estimators (Yang-Zhang, Garman-Klass, etc.)\n    - Market Impact Factors (Kyle, Amihud)\n    - Microprice (Stoikov)\n\nTotal Features: ~60-80 factors\n\nSources:\n    See module docstring for complete citation list.", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "What is the formula for Generate Gitee Chinese Factors?", "input": "", "output": "Generate all Gitee Chinese factors in one call.\n\nArgs:\n    df: DataFrame with OHLCV columns\n\nReturns:\n    DataFrame with ~60-80 factor columns\n\nExample:\n    >>> import pandas as pd\n    >>> df = pd.read_parquet('forex_data.parquet')\n    >>> factors = generate_gitee_chinese_factors(df)\n    >>> print(factors.columns.tolist())", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "Explain the Generate Gitee Chinese Factors function", "input": "", "output": "Function: generate_gitee_chinese_factors\n\nGenerate all Gitee Chinese factors in one call.\n\nArgs:\n    df: DataFrame with OHLCV columns\n\nReturns:\n    DataFrame with ~60-80 factor columns\n\nExample:\n    >>> import pandas as pd\n    >>> df = pd.read_parquet('forex_data.parquet')\n    >>> factors = generate_gitee_chinese_factors(df)\n    >>> print(factors.columns.tolist())", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "Explain the Get Citation Info function", "input": "", "output": "Function: get_citation_info\n\nGet full citation information for this module.", "source": "core\\features\\gitee_chinese_factors.py", "category": "general"}
{"instruction": "What is the formula for Alpha 001?", "input": "", "output": "Alpha001: Volume-Price Correlation\nFormula: -1 * CORR(RANK(DELTA(LOG(VOLUME),1)), RANK((CLOSE-OPEN)/OPEN), 6)\n\nForex Applicability: MEDIUM (volume is tick volume)", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "Explain the Alpha 001 function", "input": "", "output": "Function: alpha_001\n\nAlpha001: Volume-Price Correlation\nFormula: -1 * CORR(RANK(DELTA(LOG(VOLUME),1)), RANK((CLOSE-OPEN)/OPEN), 6)\n\nForex Applicability: MEDIUM (volume is tick volume)", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 002?", "input": "", "output": "Alpha002: Price Position Change\nFormula: -1 * DELTA(((CLOSE-LOW)-(HIGH-CLOSE))/(HIGH-LOW), 1)\n\nForex Applicability: HIGH (pure price-based)", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "Explain the Alpha 002 function", "input": "", "output": "Function: alpha_002\n\nAlpha002: Price Position Change\nFormula: -1 * DELTA(((CLOSE-LOW)-(HIGH-CLOSE))/(HIGH-LOW), 1)\n\nForex Applicability: HIGH (pure price-based)", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 014?", "input": "", "output": "Alpha014: 5-Day Momentum\nFormula: CLOSE - DELAY(CLOSE, 5)\n\nForex Applicability: HIGH", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "Explain the Alpha 014 function", "input": "", "output": "Function: alpha_014\n\nAlpha014: 5-Day Momentum\nFormula: CLOSE - DELAY(CLOSE, 5)\n\nForex Applicability: HIGH", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 018?", "input": "", "output": "Alpha018: 5-Day Price Ratio\nFormula: CLOSE / DELAY(CLOSE, 5)\n\nForex Applicability: HIGH", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "Explain the Alpha 018 function", "input": "", "output": "Function: alpha_018\n\nAlpha018: 5-Day Price Ratio\nFormula: CLOSE / DELAY(CLOSE, 5)\n\nForex Applicability: HIGH", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 020?", "input": "", "output": "Alpha020: 6-Day Percentage Return\nFormula: (CLOSE - DELAY(CLOSE, 6)) / DELAY(CLOSE, 6) * 100\n\nForex Applicability: HIGH", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "Explain the Alpha 020 function", "input": "", "output": "Function: alpha_020\n\nAlpha020: 6-Day Percentage Return\nFormula: (CLOSE - DELAY(CLOSE, 6)) / DELAY(CLOSE, 6) * 100\n\nForex Applicability: HIGH", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 031?", "input": "", "output": "Alpha031: Price Deviation from MA\nFormula: (CLOSE - MEAN(CLOSE, 12)) / MEAN(CLOSE, 12) * 100\n\nForex Applicability: HIGH", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "Explain the Alpha 031 function", "input": "", "output": "Function: alpha_031\n\nAlpha031: Price Deviation from MA\nFormula: (CLOSE - MEAN(CLOSE, 12)) / MEAN(CLOSE, 12) * 100\n\nForex Applicability: HIGH", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 046?", "input": "", "output": "Alpha046: Multi-MA Average Ratio\nFormula: (MA(CLOSE,3) + MA(CLOSE,6) + MA(CLOSE,12) + MA(CLOSE,24)) / 4 / CLOSE\n\nForex Applicability: HIGH", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "Explain the Alpha 046 function", "input": "", "output": "Function: alpha_046\n\nAlpha046: Multi-MA Average Ratio\nFormula: (MA(CLOSE,3) + MA(CLOSE,6) + MA(CLOSE,12) + MA(CLOSE,24)) / 4 / CLOSE\n\nForex Applicability: HIGH", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 053?", "input": "", "output": "Alpha053: Win Rate\nFormula: COUNT(CLOSE > DELAY(CLOSE, 1), 12) / 12 * 100\n\nForex Applicability: HIGH", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "Explain the Alpha 053 function", "input": "", "output": "Function: alpha_053\n\nAlpha053: Win Rate\nFormula: COUNT(CLOSE > DELAY(CLOSE, 1), 12) / 12 * 100\n\nForex Applicability: HIGH", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 054?", "input": "", "output": "Alpha054: Price Dispersion\nFormula: (-1 * RANK((STD(ABS(CLOSE - OPEN)) + (CLOSE - OPEN)) + CORR(CLOSE, OPEN, 10)))\n\nForex Applicability: HIGH", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "Explain the Alpha 054 function", "input": "", "output": "Function: alpha_054\n\nAlpha054: Price Dispersion\nFormula: (-1 * RANK((STD(ABS(CLOSE - OPEN)) + (CLOSE - OPEN)) + CORR(CLOSE, OPEN, 10)))\n\nForex Applicability: HIGH", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 060?", "input": "", "output": "Alpha060: Williams %R Variant\nFormula: -1 * RANK(((CLOSE - LOW) - (HIGH - CLOSE)) / (HIGH - LOW) * VOLUME)\n\nForex Applicability: MEDIUM (uses volume)", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "Explain the Alpha 060 function", "input": "", "output": "Function: alpha_060\n\nAlpha060: Williams %R Variant\nFormula: -1 * RANK(((CLOSE - LOW) - (HIGH - CLOSE)) / (HIGH - LOW) * VOLUME)\n\nForex Applicability: MEDIUM (uses volume)", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 101?", "input": "", "output": "Alpha101: Normalized Price Position\nFormula: (CLOSE - OPEN) / ((HIGH - LOW) + 0.001)\n\nForex Applicability: HIGH (Williams %R style)", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "Explain the Alpha 101 function", "input": "", "output": "Function: alpha_101\n\nAlpha101: Normalized Price Position\nFormula: (CLOSE - OPEN) / ((HIGH - LOW) + 0.001)\n\nForex Applicability: HIGH (Williams %R style)", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 126?", "input": "", "output": "Alpha126: Typical Price\nFormula: (CLOSE + HIGH + LOW) / 3\n\nForex Applicability: HIGH", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "Explain the Alpha 126 function", "input": "", "output": "Function: alpha_126\n\nAlpha126: Typical Price\nFormula: (CLOSE + HIGH + LOW) / 3\n\nForex Applicability: HIGH", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 130?", "input": "", "output": "Alpha130: Volume-Weighted Returns\nFormula: RANK(DECAYLINEAR(((HIGH + LOW) / 2 - (DELAY(HIGH) + DELAY(LOW)) / 2) * VWAP, 5))\n\nForex Applicability: MEDIUM (uses volume)", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "Explain the Alpha 130 function", "input": "", "output": "Function: alpha_130\n\nAlpha130: Volume-Weighted Returns\nFormula: RANK(DECAYLINEAR(((HIGH + LOW) / 2 - (DELAY(HIGH) + DELAY(LOW)) / 2) * VWAP, 5))\n\nForex Applicability: MEDIUM (uses volume)", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "What is VWAP in quantitative trading?", "input": "", "output": "VWAP (Volume-Weighted Average Price execution).\n\nImplementation details:\nAlpha130: Volume-Weighted Returns\nFormula: RANK(DECAYLINEAR(((HIGH + LOW) / 2 - (DELAY(HIGH) + DELAY(LOW)) / 2) * VWAP, 5))\n\nForex Applicability: MEDIUM (uses volume)", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 160?", "input": "", "output": "Alpha160: Conditional Volatility\nFormula: SMA(IF(CLOSE <= DELAY(CLOSE), STD(CLOSE, 20), 0), 20, 1)\n\nForex Applicability: HIGH", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "Explain the Alpha 160 function", "input": "", "output": "Function: alpha_160\n\nAlpha160: Conditional Volatility\nFormula: SMA(IF(CLOSE <= DELAY(CLOSE), STD(CLOSE, 20), 0), 20, 1)\n\nForex Applicability: HIGH", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 188?", "input": "", "output": "Alpha188: Normalized Range Expansion\nFormula: ((HIGH - LOW - SMA(HIGH - LOW, 11, 2)) / SMA(HIGH - LOW, 11, 2)) * 100\n\nForex Applicability: HIGH", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "Explain the Alpha 188 function", "input": "", "output": "Function: alpha_188\n\nAlpha188: Normalized Range Expansion\nFormula: ((HIGH - LOW - SMA(HIGH - LOW, 11, 2)) / SMA(HIGH - LOW, 11, 2)) * 100\n\nForex Applicability: HIGH", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 191?", "input": "", "output": "Alpha191: Volume-Price Momentum\nFormula: (CORR(MEAN(VOLUME, 20), LOW, 5) + (HIGH + LOW) / 2) - CLOSE\n\nForex Applicability: MEDIUM (uses volume)", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "Explain the Alpha 191 function", "input": "", "output": "Function: alpha_191\n\nAlpha191: Volume-Price Momentum\nFormula: (CORR(MEAN(VOLUME, 20), LOW, 5) + (HIGH + LOW) / 2) - CLOSE\n\nForex Applicability: MEDIUM (uses volume)", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "What is the formula for Compute All?", "input": "", "output": "Compute all forex-applicable Alpha191 factors.\n\nReturns:\n    DataFrame with all factor columns", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "Explain the Compute All function", "input": "", "output": "Function: compute_all\n\nCompute all forex-applicable Alpha191 factors.\n\nReturns:\n    DataFrame with all factor columns", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "What is the formula for Calculate S Indicator?", "input": "", "output": "Calculate S-indicator per observation.\n\nFormula:\n    S_t = |R_t| / sqrt(V_t)\n\nInterpretation:\n    High S = large price move relative to volume (informed trade)\n    Low S = small price move for volume (noise trade)", "source": "core\\features\\gitee_chinese_factors.py", "category": "volatility"}
{"instruction": "Explain the Calculate S Indicator function", "input": "", "output": "Function: calculate_s_indicator\n\nCalculate S-indicator per observation.\n\nFormula:\n    S_t = |R_t| / sqrt(V_t)\n\nInterpretation:\n    High S = large price move relative to volume (informed trade)\n    Low S = small price move for volume (noise trade)", "source": "core\\features\\gitee_chinese_factors.py", "category": "volatility"}
{"instruction": "What is the formula for Identify Smart Trades?", "input": "", "output": "Identify \"smart money\" trades using S-indicator ranking.\n\nReturns:\n    Boolean series where True = smart money trade", "source": "core\\features\\gitee_chinese_factors.py", "category": "general"}
{"instruction": "Explain the Identify Smart Trades function", "input": "", "output": "Function: identify_smart_trades\n\nIdentify \"smart money\" trades using S-indicator ranking.\n\nReturns:\n    Boolean series where True = smart money trade", "source": "core\\features\\gitee_chinese_factors.py", "category": "general"}
{"instruction": "What is the formula for Calculate Factor?", "input": "", "output": "Calculate Smart Money Factor Q.\n\nFormula:\n    Q = VWAP_smart / VWAP_all\n\nSignal:\n    Q > 1: Smart money selling (bearish)\n    Q < 1: Smart money buying (bullish)", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "Explain the Calculate Factor function", "input": "", "output": "Function: calculate_factor\n\nCalculate Smart Money Factor Q.\n\nFormula:\n    Q = VWAP_smart / VWAP_all\n\nSignal:\n    Q > 1: Smart money selling (bearish)\n    Q < 1: Smart money buying (bullish)", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "What is VWAP in quantitative trading?", "input": "", "output": "VWAP (Volume-Weighted Average Price execution).\n\nImplementation details:\nCalculate Smart Money Factor Q.\n\nFormula:\n    Q = VWAP_smart / VWAP_all\n\nSignal:\n    Q > 1: Smart money selling (bearish)\n    Q < 1: Smart money buying (bullish)", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "Explain the Calculate Enhanced Factor function", "input": "", "output": "Function: calculate_enhanced_factor\n\nCalculate enhanced Smart Money Factor with additional signals.\n\nReturns:\n    DataFrame with multiple smart money indicators", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "What is the formula for Bulk Volume Classification?", "input": "", "output": "Bulk Volume Classification (BVC) method.\n\nCitation: Easley et al. (2012), Section 2.2\n\nFormula:\n    Z = (P_close - P_open) / σ\n    V_buy = V × Φ(Z)\n    V_sell = V × (1 - Φ(Z))\n\nWhere Φ is the standard normal CDF.", "source": "core\\features\\gitee_chinese_factors.py", "category": "volatility"}
{"instruction": "Explain the Bulk Volume Classification function", "input": "", "output": "Function: bulk_volume_classification\n\nBulk Volume Classification (BVC) method.\n\nCitation: Easley et al. (2012), Section 2.2\n\nFormula:\n    Z = (P_close - P_open) / σ\n    V_buy = V × Φ(Z)\n    V_sell = V × (1 - Φ(Z))\n\nWhere Φ is the standard normal CDF.", "source": "core\\features\\gitee_chinese_factors.py", "category": "volatility"}
{"instruction": "What is the formula for Calculate Vpin?", "input": "", "output": "Calculate VPIN time series.\n\nHigh VPIN indicates:\n    - High probability of informed trading\n    - Expected volatility increase\n    - Toxic order flow (adverse selection risk)", "source": "core\\features\\gitee_chinese_factors.py", "category": "volatility"}
{"instruction": "Explain the Calculate Vpin function", "input": "", "output": "Function: calculate_vpin\n\nCalculate VPIN time series.\n\nHigh VPIN indicates:\n    - High probability of informed trading\n    - Expected volatility increase\n    - Toxic order flow (adverse selection risk)", "source": "core\\features\\gitee_chinese_factors.py", "category": "volatility"}
{"instruction": "What is VPIN in quantitative trading?", "input": "", "output": "VPIN (Volume-Synchronized Probability of Informed Trading).\n\nImplementation details:\nCalculate VPIN time series.\n\nHigh VPIN indicates:\n    - High probability of informed trading\n    - Expected volatility increase\n    - Toxic order flow (adverse selection risk)", "source": "core\\features\\gitee_chinese_factors.py", "category": "volatility"}
{"instruction": "What is the formula for Calculate Vpin Cdf?", "input": "", "output": "Calculate VPIN CDF (percentile rank).\n\nVPIN CDF > 0.9 = Extreme toxicity, expect flash crash\n\nSource: Easley et al. (2012), Section 4", "source": "core\\features\\gitee_chinese_factors.py", "category": "general"}
{"instruction": "Explain the Calculate Vpin Cdf function", "input": "", "output": "Function: calculate_vpin_cdf\n\nCalculate VPIN CDF (percentile rank).\n\nVPIN CDF > 0.9 = Extreme toxicity, expect flash crash\n\nSource: Easley et al. (2012), Section 4", "source": "core\\features\\gitee_chinese_factors.py", "category": "general"}
{"instruction": "What is VPIN in quantitative trading?", "input": "", "output": "VPIN (Volume-Synchronized Probability of Informed Trading).\n\nImplementation details:\nCalculate VPIN CDF (percentile rank).\n\nVPIN CDF > 0.9 = Extreme toxicity, expect flash crash\n\nSource: Easley et al. (2012), Section 4", "source": "core\\features\\gitee_chinese_factors.py", "category": "general"}
{"instruction": "What is the formula for Calculate All Signals?", "input": "", "output": "Calculate all VPIN-related signals.", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "Explain the Calculate All Signals function", "input": "", "output": "Function: calculate_all_signals\n\nCalculate all VPIN-related signals.", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "What is VPIN in quantitative trading?", "input": "", "output": "VPIN (Volume-Synchronized Probability of Informed Trading).\n\nImplementation details:\nCalculate all VPIN-related signals.", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "Explain the Calculate Single Level Ofi function", "input": "", "output": "Function: calculate_single_level_ofi\n\nCalculate OFI for a single price level.\n\nCitation: Cont et al. (2014), Equation (2)", "source": "core\\features\\gitee_chinese_factors.py", "category": "general"}
{"instruction": "What is OFI in quantitative trading?", "input": "", "output": "OFI (Order Flow Imbalance).\n\nImplementation details:\nCalculate OFI for a single price level.\n\nCitation: Cont et al. (2014), Equation (2)", "source": "core\\features\\gitee_chinese_factors.py", "category": "general"}
{"instruction": "Explain the Calculate Integrated Ofi Simple function", "input": "", "output": "Function: calculate_integrated_ofi_simple\n\nCalculate integrated OFI from simple OHLCV data.\n\nApproximation when L2 data not available.", "source": "core\\features\\gitee_chinese_factors.py", "category": "general"}
{"instruction": "What is OFI in quantitative trading?", "input": "", "output": "OFI (Order Flow Imbalance).\n\nImplementation details:\nCalculate integrated OFI from simple OHLCV data.\n\nApproximation when L2 data not available.", "source": "core\\features\\gitee_chinese_factors.py", "category": "general"}
{"instruction": "What is the formula for Calculate Ofi Price Impact?", "input": "", "output": "Calculate OFI and estimate price impact coefficient (lambda).\n\nModel: ΔP_t = λ × OFI_t + ε_t\n\nCitation: Cont et al. (2014), Section 3\n\nReturns:\n    (ofi_series, lambda_series)", "source": "core\\features\\gitee_chinese_factors.py", "category": "execution"}
{"instruction": "Explain the Calculate Ofi Price Impact function", "input": "", "output": "Function: calculate_ofi_price_impact\n\nCalculate OFI and estimate price impact coefficient (lambda).\n\nModel: ΔP_t = λ × OFI_t + ε_t\n\nCitation: Cont et al. (2014), Section 3\n\nReturns:\n    (ofi_series, lambda_series)", "source": "core\\features\\gitee_chinese_factors.py", "category": "execution"}
{"instruction": "What is OFI in quantitative trading?", "input": "", "output": "OFI (Order Flow Imbalance).\n\nImplementation details:\nCalculate OFI and estimate price impact coefficient (lambda).\n\nModel: ΔP_t = λ × OFI_t + ε_t\n\nCitation: Cont et al. (2014), Section 3\n\nReturns:\n    (ofi_series, lambda_series)", "source": "core\\features\\gitee_chinese_factors.py", "category": "execution"}
{"instruction": "What is the formula for Calculate All Ofi Features?", "input": "", "output": "Calculate all OFI-related features.", "source": "core\\features\\gitee_chinese_factors.py", "category": "general"}
{"instruction": "Explain the Calculate All Ofi Features function", "input": "", "output": "Function: calculate_all_ofi_features\n\nCalculate all OFI-related features.", "source": "core\\features\\gitee_chinese_factors.py", "category": "general"}
{"instruction": "What is OFI in quantitative trading?", "input": "", "output": "OFI (Order Flow Imbalance).\n\nImplementation details:\nCalculate all OFI-related features.", "source": "core\\features\\gitee_chinese_factors.py", "category": "general"}
{"instruction": "What is the formula for Parkinson?", "input": "", "output": "Parkinson (1980) volatility estimator.\n\nCitation: [A8]\n\nFormula:\n    σ² = (1/4ln2) × [ln(H/L)]²\n\nEfficiency: 5x more efficient than close-to-close", "source": "core\\features\\gitee_chinese_factors.py", "category": "volatility"}
{"instruction": "Explain the Parkinson function", "input": "", "output": "Function: parkinson\n\nParkinson (1980) volatility estimator.\n\nCitation: [A8]\n\nFormula:\n    σ² = (1/4ln2) × [ln(H/L)]²\n\nEfficiency: 5x more efficient than close-to-close", "source": "core\\features\\gitee_chinese_factors.py", "category": "volatility"}
{"instruction": "What is the formula for Garman Klass?", "input": "", "output": "Garman-Klass (1980) volatility estimator.\n\nCitation: [A6]\n\nFormula:\n    σ² = 0.5 × [ln(H/L)]² - (2ln2 - 1) × [ln(C/O)]²\n\nEfficiency: 8x more efficient than close-to-close", "source": "core\\features\\gitee_chinese_factors.py", "category": "volatility"}
{"instruction": "Explain the Garman Klass function", "input": "", "output": "Function: garman_klass\n\nGarman-Klass (1980) volatility estimator.\n\nCitation: [A6]\n\nFormula:\n    σ² = 0.5 × [ln(H/L)]² - (2ln2 - 1) × [ln(C/O)]²\n\nEfficiency: 8x more efficient than close-to-close", "source": "core\\features\\gitee_chinese_factors.py", "category": "volatility"}
{"instruction": "What is the formula for Rogers Satchell?", "input": "", "output": "Rogers-Satchell (1991) volatility estimator.\n\nCitation: [A9]\n\nFormula:\n    σ² = ln(H/C) × ln(H/O) + ln(L/C) × ln(L/O)\n\nAdvantage: Handles drift (non-zero mean returns)", "source": "core\\features\\gitee_chinese_factors.py", "category": "volatility"}
{"instruction": "Explain the Rogers Satchell function", "input": "", "output": "Function: rogers_satchell\n\nRogers-Satchell (1991) volatility estimator.\n\nCitation: [A9]\n\nFormula:\n    σ² = ln(H/C) × ln(H/O) + ln(L/C) × ln(L/O)\n\nAdvantage: Handles drift (non-zero mean returns)", "source": "core\\features\\gitee_chinese_factors.py", "category": "volatility"}
{"instruction": "What is the formula for Yang Zhang?", "input": "", "output": "Yang-Zhang (2000) volatility estimator.\n\nCitation: [A7]\n\nFormula:\n    σ² = σ²_o + k × σ²_c + (1-k) × σ²_rs\n\n    σ²_o = Var(ln(O_t / C_{t-1}))  (overnight volatility)\n    σ²_c = Var(ln(C_t / O_t))      (close-to-open volatility)\n    σ²_rs = Rogers-Satchell variance\n    k = 0.34 / (1.34 + (n+1)/(n-1))\n\nAdvantage: Accounts for overnight gaps (important for forex)\nEfficiency: Most efficient OHLC estimator", "source": "core\\features\\gitee_chinese_factors.py", "category": "volatility"}
{"instruction": "Explain the Yang Zhang function", "input": "", "output": "Function: yang_zhang\n\nYang-Zhang (2000) volatility estimator.\n\nCitation: [A7]\n\nFormula:\n    σ² = σ²_o + k × σ²_c + (1-k) × σ²_rs\n\n    σ²_o = Var(ln(O_t / C_{t-1}))  (overnight volatility)\n    σ²_c = Var(ln(C_t / O_t))      (close-to-open volatility)\n    σ²_rs = Rogers-Satchell variance\n    k = 0.34 / (1.34 + (n+1)/(n-1))\n\nAdvantage: Accounts for overnight gaps (important for forex)\nEfficiency: Most efficient OHLC estimator", "source": "core\\features\\gitee_chinese_factors.py", "category": "volatility"}
{"instruction": "Explain the Calculate All function", "input": "", "output": "Function: calculate_all\n\nCalculate all volatility estimators.", "source": "core\\features\\gitee_chinese_factors.py", "category": "volatility"}
{"instruction": "What is the formula for Kyle Lambda?", "input": "", "output": "Kyle's Lambda - Market impact coefficient.\n\nCitation: [A5] Kyle (1985), [A10] Hasbrouck (2009)\n\nModel:\n    r_t = λ × S_t + ε_t\n\n    r_t: Return in bps\n    S_t: Signed square-root dollar volume\n    λ: Price impact (Kyle's lambda)\n\nInterpretation:\n    Higher λ = more illiquid market\n    λ = cost of demanding liquidity", "source": "core\\features\\gitee_chinese_factors.py", "category": "volatility"}
{"instruction": "Explain the Kyle Lambda function", "input": "", "output": "Function: kyle_lambda\n\nKyle's Lambda - Market impact coefficient.\n\nCitation: [A5] Kyle (1985), [A10] Hasbrouck (2009)\n\nModel:\n    r_t = λ × S_t + ε_t\n\n    r_t: Return in bps\n    S_t: Signed square-root dollar volume\n    λ: Price impact (Kyle's lambda)\n\nInterpretation:\n    Higher λ = more illiquid market\n    λ = cost of demanding liquidity", "source": "core\\features\\gitee_chinese_factors.py", "category": "volatility"}
{"instruction": "What is the formula for Amihud Illiquidity?", "input": "", "output": "Amihud Illiquidity Ratio.\n\nCitation: [A1] Amihud (2002)\n\nFormula:\n    ILLIQ_i = (1/D) × Σ |r_{i,d}| / DollarVolume_{i,d}\n\nInterpretation:\n    Higher ILLIQ = less liquid\n    Price impact per dollar traded", "source": "core\\features\\gitee_chinese_factors.py", "category": "volatility"}
{"instruction": "Explain the Amihud Illiquidity function", "input": "", "output": "Function: amihud_illiquidity\n\nAmihud Illiquidity Ratio.\n\nCitation: [A1] Amihud (2002)\n\nFormula:\n    ILLIQ_i = (1/D) × Σ |r_{i,d}| / DollarVolume_{i,d}\n\nInterpretation:\n    Higher ILLIQ = less liquid\n    Price impact per dollar traded", "source": "core\\features\\gitee_chinese_factors.py", "category": "volatility"}
{"instruction": "Explain the Calculate All function", "input": "", "output": "Function: calculate_all\n\nCalculate all market impact factors.", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "Explain the Calculate Basic function", "input": "", "output": "Function: calculate_basic\n\nCalculate basic microprice.", "source": "core\\features\\gitee_chinese_factors.py", "category": "general"}
{"instruction": "What is the formula for Calculate Weighted?", "input": "", "output": "Calculate size-weighted microprice.\n\nIntuition: If more size at bid, fair price closer to ask", "source": "core\\features\\gitee_chinese_factors.py", "category": "microstructure"}
{"instruction": "Explain the Calculate Weighted function", "input": "", "output": "Function: calculate_weighted\n\nCalculate size-weighted microprice.\n\nIntuition: If more size at bid, fair price closer to ask", "source": "core\\features\\gitee_chinese_factors.py", "category": "microstructure"}
{"instruction": "Explain the Calculate From Df function", "input": "", "output": "Function: calculate_from_df\n\nCalculate microprice features from DataFrame.\n\nRequires columns: bid, ask (and optionally bid_size, ask_size)", "source": "core\\features\\gitee_chinese_factors.py", "category": "microstructure"}
{"instruction": "What is the formula for Generate All?", "input": "", "output": "Generate all Gitee Chinese factors.\n\nArgs:\n    df: DataFrame with OHLCV columns\n        Required: close\n        Optional: open, high, low, volume, bid, ask, bid_size, ask_size\n\nReturns:\n    DataFrame with all factor columns (~60-80 features)", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "Explain the Generate All function", "input": "", "output": "Function: generate_all\n\nGenerate all Gitee Chinese factors.\n\nArgs:\n    df: DataFrame with OHLCV columns\n        Required: close\n        Optional: open, high, low, volume, bid, ask, bid_size, ask_size\n\nReturns:\n    DataFrame with all factor columns (~60-80 features)", "source": "core\\features\\gitee_chinese_factors.py", "category": "alpha"}
{"instruction": "What is the formula for Get Feature Groups?", "input": "", "output": "Get feature names grouped by source/category.", "source": "core\\features\\gitee_chinese_factors.py", "category": "general"}
{"instruction": "Explain the Get Feature Groups function", "input": "", "output": "Function: get_feature_groups\n\nGet feature names grouped by source/category.", "source": "core\\features\\gitee_chinese_factors.py", "category": "general"}
{"instruction": "What is the source paper for research paper?", "input": "", "output": "The source is: arXiv:1601.00991. ", "source": "core\\features\\github_gold_standard.py", "category": "alpha"}
{"instruction": "What is the source paper for research paper?", "input": "", "output": "The source is: arXiv:2009.11189. ", "source": "core\\features\\github_gold_standard.py", "category": "alpha"}
{"instruction": "Explain the purpose of GitHub Gold Standard Quantitative Trading Formulas", "input": "", "output": "GitHub Gold Standard Quantitative Trading Formulas\n====================================================\nProduction-grade formulas extracted from top GitHub repositories (35k+ stars combined).\nAll formulas include proper academic citations and source code references.\n\nAcademic Citations:\n------------------\n[1] Cont, R., Kukanov, A., & Stoikov, S. (2014). \"The Price Impact of Order Book Events.\"\n    Journal of Financial Econometrics, 12(1), 47-88.\n    GitHub: https://github.com/nicolezattarin/LOB-feature-analysis\n\n[2] Easley, D., Lopez de Prado, M., & O'Hara, M. (2012). \"Flow Toxicity and Liquidity\n    in a High-Frequency World.\" Review of Financial Studies, 25(5), 1457-1493.\n    GitHub: https://github.com/yt-feng/VPIN\n\n[3] Garman, M.B., & Klass, M.J. (1980). \"On the Estimation of Security Price Volatilities\n    from Historical Data.\" Journal of Business, 53(1), 67-78.\n    GitHub: https://github.com/jasonstrimpel/volatility-trading\n\n[4] Parkinson, M. (1980). \"The Extreme Value Method for Estimating the Variance of the\n    Rate of Return.\" Journal of Business, 53(1), 61-65.\n\n[5] Rogers, L.C.G., & Satchell, S.E. (1991). \"Estimating Variance from High, Low and\n    Closing Prices.\" Annals of Applied Probability, 1(4), 504-512.\n\n[6] Yang, D., & Zhang, Q. (2000). \"Drift Independent Volatility Estimation Based on\n    High, Low, Open, and Close Prices.\" Journal of Business, 73(3), 477-492.\n\n[7] Lopez de Prado, M. (2018). \"Advances in Financial Machine Learning.\" Wiley.\n    GitHub: https://github.com/hudson-and-thames/mlfinlab\n\n[8] Kelly, J.L. (1956). \"A New Interpretation of Information Rate.\"\n    Bell System Technical Journal, 35(4), 917-926.\n\n[9] Sharpe, W.F. (1966). \"Mutual Fund Performance.\" Journal of Business, 39(1), 119-138.\n    GitHub: https://github.com/ranaroussi/quantstats\n\n[10] Sortino, F.A., & van der Meer, R. (1991). \"Downside Risk.\"\n     Journal of Portfolio Management, 17(4), 27-31.\n\n[11] Liu, Y., et al. (2024). \"iTransformer: Inverted Transformers Are Effective for\n     Time Series Forecasting.\" ICLR 2024 Spotlight.\n     GitHub: https://github.com/thuml/iTransformer\n\n[12] Kakushadze, Z. (2016). \"101 Formulaic Alphas.\" Wilmott, 2016(84), 72-81.\n     arXiv: https://arxiv.org/abs/1601.00991\n     GitHub: https://github.com/yli188/WorldQuant_alpha101_code\n\n[13] Hawkes, A.G. (1971). \"Spectra of Some Self-Exciting and Mutually Exciting\n     Point Processes.\" Biometrika, 58(1), 83-90.\n     GitHub: https://github.com/omitakahiro/Hawkes\n\n[14] Yang, X., et al. (2020). \"Qlib: An AI-oriented Quantitative Investment Platform.\"\n     arXiv: https://arxiv.org/abs/2009.11189\n     GitHub: https://github.com/microsoft/qlib\n\n[15] Liu, X.-Y., et al. (2021). \"FinRL: Deep Reinforcement Learning Framework to\n     Automate Trading in Quantitative Finance.\" SSRN.\n     GitHub: https://github.com/AI4Finance-Foundation/FinRL\n\nLicense: MIT (compatible with all source repositories)", "source": "core\\features\\github_gold_standard.py", "category": "alpha"}
{"instruction": "What is the OFIResult class and how do I use it?", "input": "", "output": "The OFIResult class:\n\nOrder Flow Imbalance result container.", "source": "core\\features\\github_gold_standard.py", "category": "general"}
{"instruction": "What is the OrderFlowImbalance class and how do I use it?", "input": "", "output": "The OrderFlowImbalance class:\n\nOrder Flow Imbalance (OFI) Calculator.\n\nFormula:\n--------\nOFI_t = ΔW_t - ΔV_t\n\nwhere:\n- ΔW_t = change in bid volume (adjusted for price movements)\n- ΔV_t = change in ask volume (adjusted for price movements)\n\nFor bid side:\n- If P_bid increases: ΔW = V_bid (new level)\n- If P_bid unchanged: ΔW = V_bid - V_bid_prev (volume change)\n- If P_bid decreases: ΔW = -V_bid_prev (level removed)\n\nFor ask side (inverse logic):\n- If P_ask decreases: ΔV = V_ask (new level)\n- If P_ask unchanged: ΔV = V_ask - V_ask_prev\n- If P_ask increases: ΔV = -V_ask_prev\n\nCitation:\n---------\nCont, R., Kukanov, A., & Stoikov, S. (2014).\n\"The Price Impact of Order Book Events.\"\nJournal of Financial Econometrics, 12(1), 47-88.\n\nSource:\n-------\nhttps://github.com/nicolezattarin/LOB-feature-analysis", "source": "core\\features\\github_gold_standard.py", "category": "volatility"}
{"instruction": "What is the VPINResult class and how do I use it?", "input": "", "output": "The VPINResult class:\n\nVPIN calculation result.", "source": "core\\features\\github_gold_standard.py", "category": "general"}
{"instruction": "What is the VPIN class and how do I use it?", "input": "", "output": "The VPIN class:\n\nVolume-Synchronized Probability of Informed Trading (VPIN).\n\nFormula:\n--------\nVPIN = Σ|V_buy^τ - V_sell^τ| / (n × V_bucket)\n\nwhere:\n- V_buy^τ = buy-initiated volume in bucket τ\n- V_sell^τ = sell-initiated volume in bucket τ\n- n = number of buckets in rolling window\n- V_bucket = fixed volume per bucket\n\nTrade classification uses Bulk Volume Classification (BVC):\nV_buy = V × Z((P - P_prev) / σ)\nV_sell = V × (1 - Z((P - P_prev) / σ))\n\nwhere Z is the standard normal CDF.\n\nCitation:\n---------\nEasley, D., Lopez de Prado, M., & O'Hara, M. (2012).\n\"Flow Toxicity and Liquidity in a High-Frequency World.\"\nReview of Financial Studies, 25(5), 1457-1493.\n\nSource:\n-------\nhttps://github.com/yt-feng/VPIN\nhttps://github.com/monty-se/PINstimation", "source": "core\\features\\github_gold_standard.py", "category": "volatility"}
{"instruction": "What is the VolatilityEstimators class and how do I use it?", "input": "", "output": "The VolatilityEstimators class:\n\nRange-Based Volatility Estimators.\n\nThese estimators are more efficient than close-to-close volatility\nbecause they use intraday price information (high, low, open, close).\n\nEfficiency comparison (vs close-to-close):\n- Parkinson: 5.2x more efficient\n- Garman-Klass: 7.4x more efficient\n- Rogers-Satchell: Handles drift\n- Yang-Zhang: Handles opening jumps + drift\n\nCitations:\n----------\n[3] Garman, M.B., & Klass, M.J. (1980). JoB, 53(1), 67-78.\n[4] Parkinson, M. (1980). JoB, 53(1), 61-65.\n[5] Rogers, L.C.G., & Satchell, S.E. (1991). AAP, 1(4), 504-512.\n[6] Yang, D., & Zhang, Q. (2000). JoB, 73(3), 477-492.\n\nSource:\n-------\nhttps://github.com/jasonstrimpel/volatility-trading", "source": "core\\features\\github_gold_standard.py", "category": "volatility"}
{"instruction": "What is the RiskMetrics class and how do I use it?", "input": "", "output": "The RiskMetrics class:\n\nRisk-Adjusted Performance Metrics.\n\nImplements industry-standard risk metrics from QuantStats.\n\nCitations:\n----------\n[9] Sharpe, W.F. (1966). \"Mutual Fund Performance.\" JoB, 39(1), 119-138.\n[10] Sortino, F.A., & van der Meer, R. (1991). JPM, 17(4), 27-31.\n\nSource:\n-------\nhttps://github.com/ranaroussi/quantstats", "source": "core\\features\\github_gold_standard.py", "category": "risk"}
{"instruction": "What is the KellyCriterion class and how do I use it?", "input": "", "output": "The KellyCriterion class:\n\nKelly Criterion for Optimal Position Sizing.\n\nFormula:\n--------\nf* = (p × b - q) / b = W - (1-W) / R\n\nwhere:\n- f* = optimal fraction of capital to bet\n- p (W) = probability of winning\n- q = probability of losing (1 - p)\n- b (R) = win/loss ratio\n\nFor continuous returns:\nf* = μ / σ²\n\nCitation:\n---------\nKelly, J.L. (1956). \"A New Interpretation of Information Rate.\"\nBell System Technical Journal, 35(4), 917-926.\n\nSource:\n-------\nhttps://github.com/ranaroussi/quantstats", "source": "core\\features\\github_gold_standard.py", "category": "risk"}
{"instruction": "What is the HawkesProcess class and how do I use it?", "input": "", "output": "The HawkesProcess class:\n\nHawkes Process for Self-Exciting Order Flow.\n\nFormula:\n--------\nλ(t) = μ + Σᵢ α × exp(-β(t - tᵢ))\n\nwhere:\n- λ(t) = intensity at time t\n- μ = base (background) intensity\n- α = jump size (excitation parameter)\n- β = decay rate\n- tᵢ = past event times\n\nUsed for:\n- Modeling trade clustering\n- Predicting order flow intensity\n- Detecting unusual trading activity\n\nCitation:\n---------\nHawkes, A.G. (1971). \"Spectra of Some Self-Exciting and\nMutually Exciting Point Processes.\" Biometrika, 58(1), 83-90.\n\nSource:\n-------\nhttps://github.com/omitakahiro/Hawkes\nhttps://x-datainitiative.github.io/tick/modules/hawkes.html", "source": "core\\features\\github_gold_standard.py", "category": "microstructure"}
{"instruction": "What is the GoldStandardFeatures class and how do I use it?", "input": "", "output": "The GoldStandardFeatures class:\n\nCombined Gold Standard Feature Generator.\n\nGenerates features from all academic sources:\n- Order Flow Imbalance (Cont et al. 2014)\n- VPIN (Easley et al. 2012)\n- Volatility Estimators (Garman-Klass, Parkinson, etc.)\n- Risk Metrics (Sharpe, Sortino, etc.)", "source": "core\\features\\github_gold_standard.py", "category": "volatility"}
{"instruction": "Explain the Generate Gold Standard Features function", "input": "", "output": "Function: generate_gold_standard_features\n\nGenerate all gold standard features.\n\nArgs:\n    df: OHLCV DataFrame\n\nReturns:\n    DataFrame with ~12 gold standard features", "source": "core\\features\\github_gold_standard.py", "category": "general"}
{"instruction": "What is the formula for Calculate Kelly Position?", "input": "", "output": "Calculate position size using fractional Kelly.\n\nArgs:\n    win_rate: Historical win rate (0 to 1)\n    avg_win: Average winning trade return\n    avg_loss: Average losing trade return (positive number)\n    account_value: Total account value\n    fraction: Kelly fraction (0.25 = quarter Kelly)\n\nReturns:\n    Recommended position size", "source": "core\\features\\github_gold_standard.py", "category": "risk"}
{"instruction": "Explain the Calculate Kelly Position function", "input": "", "output": "Function: calculate_kelly_position\n\nCalculate position size using fractional Kelly.\n\nArgs:\n    win_rate: Historical win rate (0 to 1)\n    avg_win: Average winning trade return\n    avg_loss: Average losing trade return (positive number)\n    account_value: Total account value\n    fraction: Kelly fraction (0.25 = quarter Kelly)\n\nReturns:\n    Recommended position size", "source": "core\\features\\github_gold_standard.py", "category": "risk"}
{"instruction": "What is Kelly Criterion in quantitative trading?", "input": "", "output": "Kelly Criterion (position sizing formula that maximizes long-term growth).\n\nImplementation details:\nCalculate position size using fractional Kelly.\n\nArgs:\n    win_rate: Historical win rate (0 to 1)\n    avg_win: Average winning trade return\n    avg_loss: Average losing trade return (positive number)\n    account_value: Total account value\n    fraction: Kelly fraction (0.25 = quarter Kelly)\n\nReturns:\n    Recommended position size", "source": "core\\features\\github_gold_standard.py", "category": "risk"}
{"instruction": "Explain the Calculate function", "input": "", "output": "Function: calculate\n\nCalculate Order Flow Imbalance.\n\nArgs:\n    bid_prices: Best bid price series\n    bid_volumes: Best bid volume series\n    ask_prices: Best ask price series\n    ask_volumes: Best ask volume series\n\nReturns:\n    OFIResult with OFI values and components", "source": "core\\features\\github_gold_standard.py", "category": "volatility"}
{"instruction": "What is OFI in quantitative trading?", "input": "", "output": "OFI (Order Flow Imbalance).\n\nImplementation details:\nCalculate Order Flow Imbalance.\n\nArgs:\n    bid_prices: Best bid price series\n    bid_volumes: Best bid volume series\n    ask_prices: Best ask price series\n    ask_volumes: Best ask volume series\n\nReturns:\n    OFIResult with OFI values and components", "source": "core\\features\\github_gold_standard.py", "category": "volatility"}
{"instruction": "What is the formula for Calculate From Ohlcv?", "input": "", "output": "Approximate OFI from OHLCV data (for forex without L2 data).\n\nUses tick rule to classify trades as buys/sells.\n\nArgs:\n    df: DataFrame with OHLCV columns\n    spread_col: Column name for spread (optional)\n\nReturns:\n    Approximated OFI series", "source": "core\\features\\github_gold_standard.py", "category": "microstructure"}
{"instruction": "Explain the Calculate From Ohlcv function", "input": "", "output": "Function: calculate_from_ohlcv\n\nApproximate OFI from OHLCV data (for forex without L2 data).\n\nUses tick rule to classify trades as buys/sells.\n\nArgs:\n    df: DataFrame with OHLCV columns\n    spread_col: Column name for spread (optional)\n\nReturns:\n    Approximated OFI series", "source": "core\\features\\github_gold_standard.py", "category": "microstructure"}
{"instruction": "What is OFI in quantitative trading?", "input": "", "output": "OFI (Order Flow Imbalance).\n\nImplementation details:\nApproximate OFI from OHLCV data (for forex without L2 data).\n\nUses tick rule to classify trades as buys/sells.\n\nArgs:\n    df: DataFrame with OHLCV columns\n    spread_col: Column name for spread (optional)\n\nReturns:\n    Approximated OFI series", "source": "core\\features\\github_gold_standard.py", "category": "microstructure"}
{"instruction": "Explain the Bulk Volume Classification function", "input": "", "output": "Function: bulk_volume_classification\n\nBulk Volume Classification (BVC) for trade direction.\n\nFrom Easley et al. (2012), Section III.A.\n\nArgs:\n    prices: Price series\n    volumes: Volume series\n    sigma: Price volatility (if None, estimated from data)\n\nReturns:\n    Tuple of (buy_volume, sell_volume) series", "source": "core\\features\\github_gold_standard.py", "category": "volatility"}
{"instruction": "Explain the Calculate function", "input": "", "output": "Function: calculate\n\nCalculate VPIN from price and volume series.\n\nArgs:\n    prices: Price series\n    volumes: Volume series\n\nReturns:\n    VPINResult with VPIN values and diagnostics", "source": "core\\features\\github_gold_standard.py", "category": "volatility"}
{"instruction": "What is VPIN in quantitative trading?", "input": "", "output": "VPIN (Volume-Synchronized Probability of Informed Trading).\n\nImplementation details:\nCalculate VPIN from price and volume series.\n\nArgs:\n    prices: Price series\n    volumes: Volume series\n\nReturns:\n    VPINResult with VPIN values and diagnostics", "source": "core\\features\\github_gold_standard.py", "category": "volatility"}
{"instruction": "Explain the Calculate From Ohlcv function", "input": "", "output": "Function: calculate_from_ohlcv\n\nCalculate VPIN approximation from OHLCV data.\n\nFor forex without tick data, uses BVC on bar data.\n\nArgs:\n    df: DataFrame with OHLCV columns\n\nReturns:\n    Rolling VPIN series", "source": "core\\features\\github_gold_standard.py", "category": "microstructure"}
{"instruction": "What is VPIN in quantitative trading?", "input": "", "output": "VPIN (Volume-Synchronized Probability of Informed Trading).\n\nImplementation details:\nCalculate VPIN approximation from OHLCV data.\n\nFor forex without tick data, uses BVC on bar data.\n\nArgs:\n    df: DataFrame with OHLCV columns\n\nReturns:\n    Rolling VPIN series", "source": "core\\features\\github_gold_standard.py", "category": "microstructure"}
{"instruction": "What is the formula for Close To Close?", "input": "", "output": "Standard close-to-close volatility.\n\nFormula: σ = std(ln(C_t / C_{t-1})) × √periods\n\nArgs:\n    close: Close price series\n\nReturns:\n    Annualized volatility series", "source": "core\\features\\github_gold_standard.py", "category": "volatility"}
{"instruction": "Explain the Close To Close function", "input": "", "output": "Function: close_to_close\n\nStandard close-to-close volatility.\n\nFormula: σ = std(ln(C_t / C_{t-1})) × √periods\n\nArgs:\n    close: Close price series\n\nReturns:\n    Annualized volatility series", "source": "core\\features\\github_gold_standard.py", "category": "volatility"}
{"instruction": "What is the formula for Parkinson?", "input": "", "output": "Parkinson Volatility Estimator.\n\nFormula: σ² = (1 / 4ln(2)) × E[ln(H/L)²]\n\n5.2x more efficient than close-to-close.\nAssumes no drift and continuous trading.\n\nCitation: Parkinson (1980) [4]\n\nArgs:\n    high: High price series\n    low: Low price series\n\nReturns:\n    Annualized Parkinson volatility", "source": "core\\features\\github_gold_standard.py", "category": "volatility"}
{"instruction": "Explain the Parkinson function", "input": "", "output": "Function: parkinson\n\nParkinson Volatility Estimator.\n\nFormula: σ² = (1 / 4ln(2)) × E[ln(H/L)²]\n\n5.2x more efficient than close-to-close.\nAssumes no drift and continuous trading.\n\nCitation: Parkinson (1980) [4]\n\nArgs:\n    high: High price series\n    low: Low price series\n\nReturns:\n    Annualized Parkinson volatility", "source": "core\\features\\github_gold_standard.py", "category": "volatility"}
{"instruction": "What is the formula for Garman Klass?", "input": "", "output": "Garman-Klass Volatility Estimator.\n\nFormula: σ² = 0.5 × ln(H/L)² - (2ln(2)-1) × ln(C/O)²\n\n7.4x more efficient than close-to-close.\nAssumes no drift and continuous trading.\n\nCitation: Garman & Klass (1980) [3]\n\nArgs:\n    open_: Open price series\n    high: High price series\n    low: Low price series\n    close: Close price series\n\nReturns:\n    Annualized Garman-Klass volatility", "source": "core\\features\\github_gold_standard.py", "category": "volatility"}
{"instruction": "Explain the Garman Klass function", "input": "", "output": "Function: garman_klass\n\nGarman-Klass Volatility Estimator.\n\nFormula: σ² = 0.5 × ln(H/L)² - (2ln(2)-1) × ln(C/O)²\n\n7.4x more efficient than close-to-close.\nAssumes no drift and continuous trading.\n\nCitation: Garman & Klass (1980) [3]\n\nArgs:\n    open_: Open price series\n    high: High price series\n    low: Low price series\n    close: Close price series\n\nReturns:\n    Annualized Garman-Klass volatility", "source": "core\\features\\github_gold_standard.py", "category": "volatility"}
{"instruction": "What is the formula for Rogers Satchell?", "input": "", "output": "Rogers-Satchell Volatility Estimator.\n\nFormula: σ² = ln(H/C)×ln(H/O) + ln(L/C)×ln(L/O)\n\nHandles non-zero drift (trending markets).\n\nCitation: Rogers & Satchell (1991) [5]\n\nArgs:\n    open_: Open price series\n    high: High price series\n    low: Low price series\n    close: Close price series\n\nReturns:\n    Annualized Rogers-Satchell volatility", "source": "core\\features\\github_gold_standard.py", "category": "volatility"}
{"instruction": "Explain the Rogers Satchell function", "input": "", "output": "Function: rogers_satchell\n\nRogers-Satchell Volatility Estimator.\n\nFormula: σ² = ln(H/C)×ln(H/O) + ln(L/C)×ln(L/O)\n\nHandles non-zero drift (trending markets).\n\nCitation: Rogers & Satchell (1991) [5]\n\nArgs:\n    open_: Open price series\n    high: High price series\n    low: Low price series\n    close: Close price series\n\nReturns:\n    Annualized Rogers-Satchell volatility", "source": "core\\features\\github_gold_standard.py", "category": "volatility"}
{"instruction": "What is the formula for Yang Zhang?", "input": "", "output": "Yang-Zhang Volatility Estimator.\n\nFormula: σ² = σ²_overnight + k×σ²_open + (1-k)×σ²_RS\n\nHandles both drift AND opening jumps.\nMost comprehensive estimator.\n\nCitation: Yang & Zhang (2000) [6]\n\nArgs:\n    open_: Open price series\n    high: High price series\n    low: Low price series\n    close: Close price series\n    k: Weighting factor (0.34 is optimal for daily data)\n\nReturns:\n    Annualized Yang-Zhang volatility", "source": "core\\features\\github_gold_standard.py", "category": "alpha"}
{"instruction": "Explain the Yang Zhang function", "input": "", "output": "Function: yang_zhang\n\nYang-Zhang Volatility Estimator.\n\nFormula: σ² = σ²_overnight + k×σ²_open + (1-k)×σ²_RS\n\nHandles both drift AND opening jumps.\nMost comprehensive estimator.\n\nCitation: Yang & Zhang (2000) [6]\n\nArgs:\n    open_: Open price series\n    high: High price series\n    low: Low price series\n    close: Close price series\n    k: Weighting factor (0.34 is optimal for daily data)\n\nReturns:\n    Annualized Yang-Zhang volatility", "source": "core\\features\\github_gold_standard.py", "category": "alpha"}
{"instruction": "Explain the Generate All function", "input": "", "output": "Function: generate_all\n\nGenerate all volatility estimators.\n\nArgs:\n    df: DataFrame with OHLC columns\n\nReturns:\n    DataFrame with volatility columns", "source": "core\\features\\github_gold_standard.py", "category": "volatility"}
{"instruction": "What is the formula for Sharpe Ratio?", "input": "", "output": "Sharpe Ratio.\n\nFormula: SR = (R_p - R_f) / σ_p × √periods\n\nCitation: Sharpe (1966) [9]\n\nArgs:\n    returns: Return series\n\nReturns:\n    Annualized Sharpe ratio", "source": "core\\features\\github_gold_standard.py", "category": "risk"}
{"instruction": "Explain the Sharpe Ratio function", "input": "", "output": "Function: sharpe_ratio\n\nSharpe Ratio.\n\nFormula: SR = (R_p - R_f) / σ_p × √periods\n\nCitation: Sharpe (1966) [9]\n\nArgs:\n    returns: Return series\n\nReturns:\n    Annualized Sharpe ratio", "source": "core\\features\\github_gold_standard.py", "category": "risk"}
{"instruction": "What is Sharpe Ratio in quantitative trading?", "input": "", "output": "Sharpe Ratio (risk-adjusted return measure).\n\nImplementation details:\nSharpe Ratio.\n\nFormula: SR = (R_p - R_f) / σ_p × √periods\n\nCitation: Sharpe (1966) [9]\n\nArgs:\n    returns: Return series\n\nReturns:\n    Annualized Sharpe ratio", "source": "core\\features\\github_gold_standard.py", "category": "risk"}
{"instruction": "What is the formula for Sortino Ratio?", "input": "", "output": "Sortino Ratio.\n\nFormula: SoR = (R_p - R_f) / σ_downside × √periods\n\nwhere σ_downside = √(Σ(R_t)² for R_t < 0) / N\n\nCitation: Sortino & van der Meer (1991) [10]\n\nArgs:\n    returns: Return series\n\nReturns:\n    Annualized Sortino ratio", "source": "core\\features\\github_gold_standard.py", "category": "general"}
{"instruction": "Explain the Sortino Ratio function", "input": "", "output": "Function: sortino_ratio\n\nSortino Ratio.\n\nFormula: SoR = (R_p - R_f) / σ_downside × √periods\n\nwhere σ_downside = √(Σ(R_t)² for R_t < 0) / N\n\nCitation: Sortino & van der Meer (1991) [10]\n\nArgs:\n    returns: Return series\n\nReturns:\n    Annualized Sortino ratio", "source": "core\\features\\github_gold_standard.py", "category": "general"}
{"instruction": "What is the formula for Calmar Ratio?", "input": "", "output": "Calmar Ratio.\n\nFormula: CR = CAGR / |Max Drawdown|\n\nArgs:\n    returns: Return series\n\nReturns:\n    Calmar ratio", "source": "core\\features\\github_gold_standard.py", "category": "risk"}
{"instruction": "Explain the Calmar Ratio function", "input": "", "output": "Function: calmar_ratio\n\nCalmar Ratio.\n\nFormula: CR = CAGR / |Max Drawdown|\n\nArgs:\n    returns: Return series\n\nReturns:\n    Calmar ratio", "source": "core\\features\\github_gold_standard.py", "category": "risk"}
{"instruction": "What is the formula for Max Drawdown?", "input": "", "output": "Maximum Drawdown.\n\nFormula: MDD = max(peak_t - trough_t) / peak_t\n\nArgs:\n    returns: Return series\n\nReturns:\n    Maximum drawdown (negative value)", "source": "core\\features\\github_gold_standard.py", "category": "risk"}
{"instruction": "Explain the Max Drawdown function", "input": "", "output": "Function: max_drawdown\n\nMaximum Drawdown.\n\nFormula: MDD = max(peak_t - trough_t) / peak_t\n\nArgs:\n    returns: Return series\n\nReturns:\n    Maximum drawdown (negative value)", "source": "core\\features\\github_gold_standard.py", "category": "risk"}
{"instruction": "What is the formula for Cagr?", "input": "", "output": "Compound Annual Growth Rate.\n\nFormula: CAGR = (V_final / V_initial)^(1/years) - 1\n\nArgs:\n    returns: Return series\n\nReturns:\n    CAGR", "source": "core\\features\\github_gold_standard.py", "category": "general"}
{"instruction": "Explain the Cagr function", "input": "", "output": "Function: cagr\n\nCompound Annual Growth Rate.\n\nFormula: CAGR = (V_final / V_initial)^(1/years) - 1\n\nArgs:\n    returns: Return series\n\nReturns:\n    CAGR", "source": "core\\features\\github_gold_standard.py", "category": "general"}
{"instruction": "Explain the Value At Risk function", "input": "", "output": "Function: value_at_risk\n\nValue at Risk (Historical).\n\nArgs:\n    returns: Return series\n    confidence: Confidence level (e.g., 0.95 for 95%)\n\nReturns:\n    VaR (negative value representing loss)", "source": "core\\features\\github_gold_standard.py", "category": "risk"}
{"instruction": "What is the formula for Conditional Var?", "input": "", "output": "Conditional Value at Risk (Expected Shortfall).\n\nFormula: CVaR = E[R | R < VaR]\n\nArgs:\n    returns: Return series\n    confidence: Confidence level\n\nReturns:\n    CVaR (negative value)", "source": "core\\features\\github_gold_standard.py", "category": "risk"}
{"instruction": "Explain the Conditional Var function", "input": "", "output": "Function: conditional_var\n\nConditional Value at Risk (Expected Shortfall).\n\nFormula: CVaR = E[R | R < VaR]\n\nArgs:\n    returns: Return series\n    confidence: Confidence level\n\nReturns:\n    CVaR (negative value)", "source": "core\\features\\github_gold_standard.py", "category": "risk"}
{"instruction": "Explain the Generate All function", "input": "", "output": "Function: generate_all\n\nGenerate all risk metrics.\n\nArgs:\n    returns: Return series\n\nReturns:\n    Dict with all metrics", "source": "core\\features\\github_gold_standard.py", "category": "risk"}
{"instruction": "What is the formula for Kelly Fraction?", "input": "", "output": "Calculate full Kelly fraction.\n\nArgs:\n    win_rate: Probability of winning (0 to 1)\n    win_loss_ratio: Average win / Average loss\n\nReturns:\n    Optimal bet fraction (0 to 1)", "source": "core\\features\\github_gold_standard.py", "category": "risk"}
{"instruction": "Explain the Kelly Fraction function", "input": "", "output": "Function: kelly_fraction\n\nCalculate full Kelly fraction.\n\nArgs:\n    win_rate: Probability of winning (0 to 1)\n    win_loss_ratio: Average win / Average loss\n\nReturns:\n    Optimal bet fraction (0 to 1)", "source": "core\\features\\github_gold_standard.py", "category": "risk"}
{"instruction": "What is Kelly Criterion in quantitative trading?", "input": "", "output": "Kelly Criterion (position sizing formula that maximizes long-term growth).\n\nImplementation details:\nCalculate full Kelly fraction.\n\nArgs:\n    win_rate: Probability of winning (0 to 1)\n    win_loss_ratio: Average win / Average loss\n\nReturns:\n    Optimal bet fraction (0 to 1)", "source": "core\\features\\github_gold_standard.py", "category": "risk"}
{"instruction": "What is the formula for Fractional Kelly?", "input": "", "output": "Calculate fractional Kelly (more conservative).\n\nHalf-Kelly (fraction=0.5) provides:\n- 75% of optimal growth rate\n- 50% of the volatility\n\nQuarter-Kelly (fraction=0.25) provides:\n- 43.75% of optimal growth rate\n- 25% of the volatility\n\nArgs:\n    win_rate: Probability of winning\n    win_loss_ratio: Win/loss ratio\n    fraction: Kelly fraction (0.25-0.5 recommended)\n\nReturns:\n    Fractional Kelly bet size", "source": "core\\features\\github_gold_standard.py", "category": "volatility"}
{"instruction": "Explain the Fractional Kelly function", "input": "", "output": "Function: fractional_kelly\n\nCalculate fractional Kelly (more conservative).\n\nHalf-Kelly (fraction=0.5) provides:\n- 75% of optimal growth rate\n- 50% of the volatility\n\nQuarter-Kelly (fraction=0.25) provides:\n- 43.75% of optimal growth rate\n- 25% of the volatility\n\nArgs:\n    win_rate: Probability of winning\n    win_loss_ratio: Win/loss ratio\n    fraction: Kelly fraction (0.25-0.5 recommended)\n\nReturns:\n    Fractional Kelly bet size", "source": "core\\features\\github_gold_standard.py", "category": "volatility"}
{"instruction": "What is Kelly Criterion in quantitative trading?", "input": "", "output": "Kelly Criterion (position sizing formula that maximizes long-term growth).\n\nImplementation details:\nCalculate fractional Kelly (more conservative).\n\nHalf-Kelly (fraction=0.5) provides:\n- 75% of optimal growth rate\n- 50% of the volatility\n\nQuarter-Kelly (fraction=0.25) provides:\n- 43.75% of optimal growth rate\n- 25% of the volatility\n\nArgs:\n    win_rate: Probability of winning\n    win_loss_ratio: Win/loss ratio\n    fraction: Kelly fraction (0.25-0.5 recommended)\n\nReturns:\n    Fractional Kelly bet size", "source": "core\\features\\github_gold_standard.py", "category": "volatility"}
{"instruction": "What is the formula for Kelly From Returns?", "input": "", "output": "Calculate Kelly from historical returns.\n\nFormula: f* = μ / σ²\n\nArgs:\n    returns: Historical return series\n\nReturns:\n    Optimal Kelly leverage", "source": "core\\features\\github_gold_standard.py", "category": "risk"}
{"instruction": "Explain the Kelly From Returns function", "input": "", "output": "Function: kelly_from_returns\n\nCalculate Kelly from historical returns.\n\nFormula: f* = μ / σ²\n\nArgs:\n    returns: Historical return series\n\nReturns:\n    Optimal Kelly leverage", "source": "core\\features\\github_gold_standard.py", "category": "risk"}
{"instruction": "What is Kelly Criterion in quantitative trading?", "input": "", "output": "Kelly Criterion (position sizing formula that maximizes long-term growth).\n\nImplementation details:\nCalculate Kelly from historical returns.\n\nFormula: f* = μ / σ²\n\nArgs:\n    returns: Historical return series\n\nReturns:\n    Optimal Kelly leverage", "source": "core\\features\\github_gold_standard.py", "category": "risk"}
{"instruction": "What is the formula for Position Size?", "input": "", "output": "Calculate position size in currency.\n\nArgs:\n    account_value: Total account value\n    win_rate: Win probability\n    win_loss_ratio: Win/loss ratio\n    fraction: Kelly fraction (0.25 default)\n    max_position_pct: Maximum position cap (0.10 = 10%)\n\nReturns:\n    Position size in currency", "source": "core\\features\\github_gold_standard.py", "category": "risk"}
{"instruction": "Explain the Position Size function", "input": "", "output": "Function: position_size\n\nCalculate position size in currency.\n\nArgs:\n    account_value: Total account value\n    win_rate: Win probability\n    win_loss_ratio: Win/loss ratio\n    fraction: Kelly fraction (0.25 default)\n    max_position_pct: Maximum position cap (0.10 = 10%)\n\nReturns:\n    Position size in currency", "source": "core\\features\\github_gold_standard.py", "category": "risk"}
{"instruction": "What is Kelly Criterion in quantitative trading?", "input": "", "output": "Kelly Criterion (position sizing formula that maximizes long-term growth).\n\nImplementation details:\nCalculate position size in currency.\n\nArgs:\n    account_value: Total account value\n    win_rate: Win probability\n    win_loss_ratio: Win/loss ratio\n    fraction: Kelly fraction (0.25 default)\n    max_position_pct: Maximum position cap (0.10 = 10%)\n\nReturns:\n    Position size in currency", "source": "core\\features\\github_gold_standard.py", "category": "risk"}
{"instruction": "Explain the Intensity function", "input": "", "output": "Function: intensity\n\nCalculate conditional intensity at time t.\n\nArgs:\n    t: Current time\n    event_times: Array of past event times (< t)\n\nReturns:\n    Intensity λ(t)", "source": "core\\features\\github_gold_standard.py", "category": "general"}
{"instruction": "Explain the Intensity Series function", "input": "", "output": "Function: intensity_series\n\nCalculate intensity at multiple time points.\n\nArgs:\n    times: Array of evaluation times\n    event_times: Array of event times\n\nReturns:\n    Array of intensities", "source": "core\\features\\github_gold_standard.py", "category": "general"}
{"instruction": "Explain the Simulate function", "input": "", "output": "Function: simulate\n\nSimulate Hawkes process using Ogata's thinning algorithm.\n\nArgs:\n    T: End time\n    seed: Random seed\n\nReturns:\n    Array of event times", "source": "core\\features\\github_gold_standard.py", "category": "general"}
{"instruction": "What is the formula for Branching Ratio?", "input": "", "output": "Calculate branching ratio (criticality measure).\n\nn* = α/β\n\n- n* < 1: Subcritical (stable)\n- n* = 1: Critical (marginally stable)\n- n* > 1: Supercritical (explosive)\n\nReturns:\n    Branching ratio", "source": "core\\features\\github_gold_standard.py", "category": "general"}
{"instruction": "Explain the Branching Ratio function", "input": "", "output": "Function: branching_ratio\n\nCalculate branching ratio (criticality measure).\n\nn* = α/β\n\n- n* < 1: Subcritical (stable)\n- n* = 1: Critical (marginally stable)\n- n* > 1: Supercritical (explosive)\n\nReturns:\n    Branching ratio", "source": "core\\features\\github_gold_standard.py", "category": "general"}
{"instruction": "Explain the Estimate From Trades function", "input": "", "output": "Function: estimate_from_trades\n\nEstimate Hawkes parameters from trade data (MLE).\n\nSimplified estimation using method of moments.\n\nArgs:\n    trade_times: Array of trade arrival times\n    T: Total time period\n\nReturns:\n    Dict with estimated parameters", "source": "core\\features\\github_gold_standard.py", "category": "general"}
{"instruction": "Explain the Generate Microstructure Features function", "input": "", "output": "Function: generate_microstructure_features\n\nGenerate microstructure features.\n\nArgs:\n    df: DataFrame with OHLCV columns\n\nReturns:\n    DataFrame with microstructure features", "source": "core\\features\\github_gold_standard.py", "category": "microstructure"}
{"instruction": "Explain the Get Feature Names function", "input": "", "output": "Function: get_feature_names\n\nGet list of all feature names.", "source": "core\\features\\github_gold_standard.py", "category": "general"}
{"instruction": "Explain the purpose of Temporal Graph Neural Network Features", "input": "", "output": "Temporal Graph Neural Network Features\n======================================\nGraph-based feature engineering for trading from Tsinghua/Chinese research.\n\nCitations:\n[1] TGNS: Tsinghua THUNLP Lab (2023). \"Graph Attention Networks for\n    Financial Time Series Prediction.\"\n    - Temporal attention over price sequences\n    - Cross-asset dependency modeling\n\n[2] Veličković et al. (2018). \"Graph Attention Networks\" ICLR.\n    - Foundation paper for GAT architecture\n\n[3] Wu et al. (2020). \"Connecting the Dots: Multivariate Time Series\n    Forecasting with Graph Neural Networks\" KDD.\n    - GNN for multivariate time series\n\nKey Innovation:\n    - Currency pair correlations as graph edges\n    - Temporal attention mechanisms\n    - Message passing for cross-asset signals\n\nImplementation (simplified for feature extraction):\n    - Correlation graph construction\n    - Attention-weighted aggregation\n    - Temporal message passing features\n\nTotal: 15 features\n\nUsage:\n    from core.features.gnn_temporal import TemporalGNNFeatures\n    gnn = TemporalGNNFeatures()\n    features = gnn.generate_all(df)", "source": "core\\features\\gnn_temporal.py", "category": "alpha"}
{"instruction": "What is the GraphAttentionLayer class and how do I use it?", "input": "", "output": "The GraphAttentionLayer class:\n\nSimplified Graph Attention Layer for Feature Extraction.\n\nComputes attention-weighted aggregation over temporal neighbors.\n\nReference: Veličković et al. (2018) \"Graph Attention Networks\"", "source": "core\\features\\gnn_temporal.py", "category": "general"}
{"instruction": "What is the TemporalGNNFeatures class and how do I use it?", "input": "", "output": "The TemporalGNNFeatures class:\n\nTemporal Graph Neural Network Feature Generator.\n\nExtracts graph-based features from time series without full GNN inference.\nUses correlation graphs, attention mechanisms, and message passing concepts.\n\nCitations:\n[1] TGNS: Tsinghua THUNLP (2023). \"Graph Attention Networks for Financial\n    Time Series Prediction.\"\n[2] Veličković et al. (2018). \"Graph Attention Networks\" ICLR.\n[3] Wu et al. (2020). \"Connecting the Dots: Multivariate Time Series\n    Forecasting with Graph Neural Networks\" KDD.\n\nTotal: 15 features\n- Correlation Graph: 4 features\n- Temporal Attention: 4 features\n- Message Passing: 4 features\n- Graph Statistics: 3 features", "source": "core\\features\\gnn_temporal.py", "category": "risk"}
{"instruction": "Explain the Generate Gnn Features function", "input": "", "output": "Function: generate_gnn_features\n\nGenerate GNN temporal features.\n\nArgs:\n    df: OHLCV DataFrame\n\nReturns:\n    DataFrame with 15 GNN features", "source": "core\\features\\gnn_temporal.py", "category": "general"}
{"instruction": "What is the formula for Compute Attention?", "input": "", "output": "Compute scaled dot-product attention.\n\nArgs:\n    query: Query vector\n    keys: Key matrix\n    values: Value matrix\n    mask: Optional attention mask\n\nReturns:\n    Attention-weighted output", "source": "core\\features\\gnn_temporal.py", "category": "microstructure"}
{"instruction": "Explain the Compute Attention function", "input": "", "output": "Function: compute_attention\n\nCompute scaled dot-product attention.\n\nArgs:\n    query: Query vector\n    keys: Key matrix\n    values: Value matrix\n    mask: Optional attention mask\n\nReturns:\n    Attention-weighted output", "source": "core\\features\\gnn_temporal.py", "category": "microstructure"}
{"instruction": "What is the formula for Generate All?", "input": "", "output": "Generate all GNN-based features.\n\nArgs:\n    df: DataFrame with OHLCV data\n\nReturns:\n    DataFrame with 15 GNN features", "source": "core\\features\\gnn_temporal.py", "category": "general"}
{"instruction": "Explain the Generate All function", "input": "", "output": "Function: generate_all\n\nGenerate all GNN-based features.\n\nArgs:\n    df: DataFrame with OHLCV data\n\nReturns:\n    DataFrame with 15 GNN features", "source": "core\\features\\gnn_temporal.py", "category": "general"}
{"instruction": "Explain the Get Feature Names function", "input": "", "output": "Function: get_feature_names\n\nGet list of all feature names.", "source": "core\\features\\gnn_temporal.py", "category": "general"}
{"instruction": "Explain the Get Citations function", "input": "", "output": "Function: get_citations\n\nGet academic citations for GNN trading.", "source": "core\\features\\gnn_temporal.py", "category": "general"}
{"instruction": "Explain the purpose of India Quantitative Finance Factors", "input": "", "output": "India Quantitative Finance Factors\n==================================\nGold standard quantitative formulas from Indian research institutions.\n\nSources:\n1. Indian Institute of Quantitative Finance (IIQF) - Curriculum materials\n   - Triangular arbitrage strategies\n   - INR carry decomposition\n\n2. NSE Academy ML for Quant Finance Program\n   - Machine learning applications in Indian markets\n   - High-frequency microstructure\n\n3. ScienceDirect (2024) - \"Synergizing quantitative finance models and market\n   microstructure analysis for enhanced algorithmic trading\"\n   - 60.63% profitable trades on NSE\n   - Feature engineering for Indian markets\n\n4. IIM Sirmaur Research Papers\n   - Emerging market volatility models\n   - Monsoon seasonality effects on INR\n\n5. Reserve Bank of India (RBI) Working Papers\n   - Forex intervention detection\n   - INR volatility dynamics\n\nTotal: 25 factors organized into:\n- Carry Factors (5): INR interest rate differential proxies\n- Seasonality Factors (5): Monsoon, festival, fiscal year effects\n- Intervention Detection (5): RBI intervention signals\n- Microstructure (5): NSE-specific patterns\n- Arbitrage Signals (5): Triangular and cross-rate opportunities", "source": "core\\features\\india_quant.py", "category": "alpha"}
{"instruction": "What is the IndiaQuantFeatures class and how do I use it?", "input": "", "output": "The IndiaQuantFeatures class:\n\nIndian Market Quantitative Features.\n\nBased on research from:\n- IIQF (Indian Institute of Quantitative Finance)\n- NSE Academy ML programs\n- RBI forex research\n- IIM academic papers\n\nAdapted for forex pairs involving INR or correlated currencies.\n\nUsage:\n    features = IndiaQuantFeatures()\n    df_features = features.generate_all(ohlcv_df)", "source": "core\\features\\india_quant.py", "category": "volatility"}
{"instruction": "Show me a code example for IndiaQuantFeatures", "input": "", "output": "features = IndiaQuantFeatures()\n    df_features = features.generate_all(ohlcv_df)", "source": "core\\features\\india_quant.py", "category": "volatility"}
{"instruction": "Explain the Generate India Features function", "input": "", "output": "Function: generate_india_features\n\nGenerate India Quant features.\n\nArgs:\n    df: OHLCV DataFrame\n\nReturns:\n    DataFrame with 25 Indian market factors", "source": "core\\features\\india_quant.py", "category": "alpha"}
{"instruction": "Explain the Generate All function", "input": "", "output": "Function: generate_all\n\nGenerate all India Quant features.\n\nArgs:\n    df: DataFrame with columns: open, high, low, close, volume\n\nReturns:\n    DataFrame with 25 factor columns", "source": "core\\features\\india_quant.py", "category": "alpha"}
{"instruction": "Explain the Get Feature Names function", "input": "", "output": "Function: get_feature_names\n\nGet list of all feature names.", "source": "core\\features\\india_quant.py", "category": "general"}
{"instruction": "Explain the Get Factor Category function", "input": "", "output": "Function: get_factor_category\n\nGet the category of a factor by name.", "source": "core\\features\\india_quant.py", "category": "alpha"}
{"instruction": "Explain the purpose of Japan Quantitative Finance Factors", "input": "", "output": "Japan Quantitative Finance Factors\n==================================\nGold standard quantitative formulas from Japanese market research.\n\nSources:\n1. JPX Working Paper No.4 - \"Analysis of High-Frequency Trading at TSE\"\n   Tokyo Stock Exchange research on HFT microstructure\n   - 25.9% of trading volume from HFT\n   - Arrowhead platform latency: 2ms execution\n\n2. J-Quants Educational Initiative (Japan Exchange Group)\n   - Machine learning for Japanese markets\n   - Factor investing in JPY\n\n3. Springer (2019) - \"High-Frequency Trading in Japan: A Unique Evolution\"\n   - Japanese market-making vs arbitrage\n   - Regulatory environment impact\n\n4. Bank of Japan (BOJ) Research Papers\n   - Yen carry trade dynamics\n   - JPY safe haven characteristics\n   - Currency intervention detection\n\n5. University of Tokyo - Financial Engineering Lab\n   - Japanese session microstructure\n   - Asian session price discovery\n\n6. HAR-RV Model - Corsi (2009) Journal of Financial Econometrics\n   - Heterogeneous Autoregressive model for Realized Volatility\n   - Daily, weekly, monthly volatility components\n\n7. Power-Law Order Clustering - JPX Working Papers\n   - Order sizes follow power-law distribution\n   - Microstructure analysis\n\nTotal: 30 factors organized into:\n- Carry Factors (4): Yen carry trade institutional models\n- HFT Microstructure (4): Arrowhead latency models\n- Session Patterns (4): Japanese session specific patterns\n- Market Making (4): Japanese MM vs arbitrage\n- Safe Haven (4): JPY safe haven dynamics\n- HAR-RV Volatility (5): Heterogeneous volatility components (NEW)\n- Power-Law Microstructure (3): Order flow power-law features (NEW)\n- BOJ Intervention (2): Intervention detection signals (NEW)", "source": "core\\features\\japan_quant.py", "category": "alpha"}
{"instruction": "What is the JapanQuantFeatures class and how do I use it?", "input": "", "output": "The JapanQuantFeatures class:\n\nJapanese Market Quantitative Features.\n\nBased on research from:\n- JPX Working Papers (Tokyo Stock Exchange)\n- J-Quants educational initiative\n- Bank of Japan forex research\n- Japanese academic institutions\n\nSpecialized for JPY pairs and Asian session dynamics.\n\nUsage:\n    features = JapanQuantFeatures()\n    df_features = features.generate_all(ohlcv_df)", "source": "core\\features\\japan_quant.py", "category": "general"}
{"instruction": "Show me a code example for JapanQuantFeatures", "input": "", "output": "features = JapanQuantFeatures()\n    df_features = features.generate_all(ohlcv_df)", "source": "core\\features\\japan_quant.py", "category": "general"}
{"instruction": "What is the formula for Generate Japan Features?", "input": "", "output": "Generate Japan Quant features.\n\nArgs:\n    df: OHLCV DataFrame\n\nReturns:\n    DataFrame with 30 Japanese market factors (including HAR-RV, Power-Law, BOJ)", "source": "core\\features\\japan_quant.py", "category": "alpha"}
{"instruction": "Explain the Generate Japan Features function", "input": "", "output": "Function: generate_japan_features\n\nGenerate Japan Quant features.\n\nArgs:\n    df: OHLCV DataFrame\n\nReturns:\n    DataFrame with 30 Japanese market factors (including HAR-RV, Power-Law, BOJ)", "source": "core\\features\\japan_quant.py", "category": "alpha"}
{"instruction": "Explain the Generate All function", "input": "", "output": "Function: generate_all\n\nGenerate all Japan Quant features.\n\nArgs:\n    df: DataFrame with columns: open, high, low, close, volume\n\nReturns:\n    DataFrame with 20 factor columns", "source": "core\\features\\japan_quant.py", "category": "alpha"}
{"instruction": "Explain the Get Feature Names function", "input": "", "output": "Function: get_feature_names\n\nGet list of all feature names.", "source": "core\\features\\japan_quant.py", "category": "general"}
{"instruction": "Explain the Get Factor Category function", "input": "", "output": "Function: get_factor_category\n\nGet the category of a factor by name.", "source": "core\\features\\japan_quant.py", "category": "alpha"}
{"instruction": "Explain the Get Citations function", "input": "", "output": "Function: get_citations\n\nGet academic citations for Japan Quant methods.", "source": "core\\features\\japan_quant.py", "category": "general"}
{"instruction": "Explain the purpose of Korean Quantitative Finance Factors", "input": "", "output": "Korean Quantitative Finance Factors\n===================================\nGold standard quantitative formulas from Korean market research.\n\nSources:\n1. KAIST (Korea Advanced Institute of Science and Technology)\n   - MS-GARCH models for regime switching\n   - Advanced volatility modeling\n\n2. KRX (Korea Exchange) Research\n   - VKOSPI modeling (Korean VIX equivalent)\n   - High-frequency microstructure\n\n3. Seoul National University Financial Engineering\n   - Regime-aware LSTM models\n   - Korean market microstructure\n\n4. Korean Academic Papers\n   - CGMY Lévy processes for jump modeling\n   - GEW-LSTM hybrid architectures\n\nCitations:\n[1] Hamilton, J.D. (1989). \"A New Approach to the Economic Analysis of\n    Nonstationary Time Series and the Business Cycle\" Econometrica.\n    Foundation for Markov-Switching models.\n\n[2] Carr, P., Geman, H., Madan, D.B., Yor, M. (2002). \"The Fine Structure\n    of Asset Returns: An Empirical Investigation\" Journal of Business.\n    CGMY Lévy process for modeling jumps.\n\n[3] Kim, S.H. et al. (2019). \"GEW-LSTM: A Hybrid Deep Learning Model for\n    Financial Time Series Prediction\" Korean Journal of Financial Studies.\n\nTotal: 20 factors organized into:\n- MS-GARCH Regime (5): Markov-Switching GARCH regime detection\n- CGMY Lévy (4): Jump intensity and characteristics\n- VKOSPI Models (4): Korean VIX analog features\n- GEW-LSTM Hybrid (4): Gram matrix + LSTM inspired\n- Regime-Aware (3): Multi-regime prediction signals", "source": "core\\features\\korea_quant.py", "category": "alpha"}
{"instruction": "What is the KoreaQuantFeatures class and how do I use it?", "input": "", "output": "The KoreaQuantFeatures class:\n\nKorean Market Quantitative Features.\n\nBased on research from:\n- KAIST (Korea Advanced Institute of Science and Technology)\n- KRX (Korea Exchange) research papers\n- Seoul National University Financial Engineering\n- Korean academic journals\n\nSpecialized for volatility regime detection and jump modeling.\n\nUsage:\n    features = KoreaQuantFeatures()\n    df_features = features.generate_all(ohlcv_df)", "source": "core\\features\\korea_quant.py", "category": "volatility"}
{"instruction": "Show me a code example for KoreaQuantFeatures", "input": "", "output": "features = KoreaQuantFeatures()\n    df_features = features.generate_all(ohlcv_df)", "source": "core\\features\\korea_quant.py", "category": "volatility"}
{"instruction": "Explain the Generate Korea Features function", "input": "", "output": "Function: generate_korea_features\n\nGenerate Korea Quant features.\n\nArgs:\n    df: OHLCV DataFrame\n\nReturns:\n    DataFrame with 20 Korean market factors", "source": "core\\features\\korea_quant.py", "category": "alpha"}
{"instruction": "Explain the Generate All function", "input": "", "output": "Function: generate_all\n\nGenerate all Korea Quant features.\n\nArgs:\n    df: DataFrame with columns: open, high, low, close, volume\n\nReturns:\n    DataFrame with 20 factor columns", "source": "core\\features\\korea_quant.py", "category": "alpha"}
{"instruction": "Explain the Get Feature Names function", "input": "", "output": "Function: get_feature_names\n\nGet list of all feature names.", "source": "core\\features\\korea_quant.py", "category": "general"}
{"instruction": "Explain the Get Citations function", "input": "", "output": "Function: get_citations\n\nGet academic citations for Korean quant methods.", "source": "core\\features\\korea_quant.py", "category": "general"}
{"instruction": "Explain the purpose of Multi-Agent Reinforcement Learning (MARL) Trading Features", "input": "", "output": "Multi-Agent Reinforcement Learning (MARL) Trading Features\n==========================================================\nFeature extraction inspired by multi-agent market dynamics from Chinese research.\n\nCitations:\n[1] Sun, S. et al. (2023). \"Multi-Agent Reinforcement Learning for Quantitative\n    Trading: A Survey\" arXiv:2302.13753.\n    Comprehensive survey of MARL in trading.\n\n[2] 国泰君安/Fudan University (2024). \"Market as Multi-Agent System\"\n    Chinese institutional research on agent-based market modeling.\n\n[3] Littman, M.L. (1994). \"Markov Games as a Framework for Multi-Agent\n    Reinforcement Learning\" ICML.\n    Foundation for multi-agent learning in games.\n\n[4] Hu, J. & Wellman, M.P. (2003). \"Nash Q-Learning for General-Sum\n    Stochastic Games\" JMLR.\n    Nash equilibrium learning in multi-agent settings.\n\nKey Innovation:\n    - Market = multiple interacting agents with different strategies\n    - Price is emergent from agent interactions\n    - Features capture agent behavior signatures\n\nImplementation:\n    - Agent consensus signals\n    - Market impact from agent actions\n    - Equilibrium price estimation\n    - Agent type detection\n\nTotal: 15 features\n\nUsage:\n    from core.features.marl_trading import MultiAgentRLFeatures\n    marl = MultiAgentRLFeatures()\n    features = marl.generate_all(df)", "source": "core\\features\\marl_trading.py", "category": "alpha"}
{"instruction": "What is the AgentTypeDetector class and how do I use it?", "input": "", "output": "The AgentTypeDetector class:\n\nDetects signatures of different agent types in market data.\n\nAgent Types:\n- Momentum: Trend followers, buy high/sell low\n- Value: Mean-reversion, buy low/sell high\n- Noise: Random trading, no clear pattern\n- Informed: Anticipates moves, leads price\n\nReference: Kyle (1985) on informed vs noise traders", "source": "core\\features\\marl_trading.py", "category": "rl"}
{"instruction": "What is the MultiAgentRLFeatures class and how do I use it?", "input": "", "output": "The MultiAgentRLFeatures class:\n\nMulti-Agent Reinforcement Learning Feature Generator.\n\nModels market as multi-agent system where price emerges from\ninteractions between different agent types.\n\nCitations:\n[1] Sun et al. (2023). \"Multi-Agent Reinforcement Learning for\n    Quantitative Trading\" arXiv:2302.13753.\n[2] Littman (1994). \"Markov Games as a Framework for Multi-Agent RL\"\n[3] Hu & Wellman (2003). \"Nash Q-Learning for General-Sum Games\"\n\nTotal: 15 features\n- Agent Detection: 4 features (momentum, value, noise, informed signatures)\n- Agent Consensus: 4 features (agreement, divergence, dominance, balance)\n- Market Impact: 4 features (price impact, volume impact, persistence, decay)\n- Equilibrium: 3 features (Nash estimate, deviation, convergence)", "source": "core\\features\\marl_trading.py", "category": "volatility"}
{"instruction": "Explain the Generate Marl Features function", "input": "", "output": "Function: generate_marl_features\n\nGenerate MARL trading features.\n\nArgs:\n    df: OHLCV DataFrame\n\nReturns:\n    DataFrame with 15 MARL features", "source": "core\\features\\marl_trading.py", "category": "rl"}
{"instruction": "Explain the Detect Momentum Signature function", "input": "", "output": "Function: detect_momentum_signature\n\nDetect momentum agent activity (positive autocorrelation).", "source": "core\\features\\marl_trading.py", "category": "rl"}
{"instruction": "Explain the Detect Value Signature function", "input": "", "output": "Function: detect_value_signature\n\nDetect value agent activity (negative autocorrelation).", "source": "core\\features\\marl_trading.py", "category": "rl"}
{"instruction": "Explain the Detect Noise Signature function", "input": "", "output": "Function: detect_noise_signature\n\nDetect noise trader activity (high variance, low autocorrelation).", "source": "core\\features\\marl_trading.py", "category": "risk"}
{"instruction": "Explain the Detect Informed Signature function", "input": "", "output": "Function: detect_informed_signature\n\nDetect informed trader activity.\n\nInformed traders: large volume precedes price moves", "source": "core\\features\\marl_trading.py", "category": "volatility"}
{"instruction": "Explain the Generate All function", "input": "", "output": "Function: generate_all\n\nGenerate all MARL features.\n\nArgs:\n    df: DataFrame with OHLCV data\n\nReturns:\n    DataFrame with 15 MARL features", "source": "core\\features\\marl_trading.py", "category": "rl"}
{"instruction": "Explain the Get Feature Names function", "input": "", "output": "Function: get_feature_names\n\nGet list of all feature names.", "source": "core\\features\\marl_trading.py", "category": "general"}
{"instruction": "Explain the Get Citations function", "input": "", "output": "Function: get_citations\n\nGet academic citations for MARL trading.", "source": "core\\features\\marl_trading.py", "category": "rl"}
{"instruction": "Explain the purpose of MegaFeatureGenerator - Unified 1300+ Feature Generator", "input": "", "output": "MegaFeatureGenerator - Unified 1300+ Feature Generator\n======================================================\nCombines ALL feature libraries from:\n- Chinese Quant: Alpha101 (62), Alpha158 (179), Alpha360 (200), Barra CNE6 (46)\n- Chinese Quant: Alpha191 Guotai Junan (191), Chinese HFT Factors (50+)\n- USA Academic: Carry, Momentum, Value, Volatility, Macro, Technical (50)\n- GitHub/Gitee: MLFinLab (17), Time-Series-Library (41)\n- Renaissance: Weak Signals (51)\n- Chinese HFT Additions: RSRS, Yang-Zhang Vol, Hawkes OFI (25+)\n- GLOBAL EXPANSION (2026-01-17):\n  - India Quant: IIQF, NSE Academy, RBI research (25)\n  - Japan Quant: JPX, J-Quants, TSE Arrowhead, HAR-RV, BOJ (30) - UPDATED\n  - Europe Quant: ETH, Imperial, Heston, SABR (15)\n  - Emerging Markets: Brazil, Russia, SE Asia (20)\n  - Universal Math: OU, Kelly, Cointegration (30)\n- REINFORCEMENT LEARNING (2026-01-17):\n  - Pure Mathematical RL: Q-Learning, SARSA, TD(λ), Dyna-Q (35)\n  - Almgren-Chriss Optimal Execution\n  - Thompson Sampling Bandits\n  - Kelly-RL Integration\n- EASTERN ASIA GOLD STANDARD (2026-01-17):\n  - MOE (Mixture of Experts): MIGA architecture (20) - 24% excess return\n  - GNN Temporal: Graph attention, message passing (15)\n  - Korea Quant: MS-GARCH, CGMY Lévy, VKOSPI (20)\n  - Asia FX Spread: CNH-CNY, HKD peg (15)\n  - MARL Trading: Multi-agent RL dynamics (15)\n\nTotal: 1350+ features for institutional-grade ML\n\nUsage:\n    from core.features.mega_generator import MegaFeatureGenerator\n\n    generator = MegaFeatureGenerator()\n    features = generator.generate_all(ohlcv_df)\n    print(f\"Generated {len(features.columns)} features\")", "source": "core\\features\\mega_generator.py", "category": "alpha"}
{"instruction": "What is the ChineseHFTAdditions class and how do I use it?", "input": "", "output": "The ChineseHFTAdditions class:\n\nAdditional Chinese HFT formulas not in existing implementations.\n\nIncludes:\n- RSRS (支撑阻力相对强度) - Regime detection from Chinese quants\n- Yang-Zhang Volatility - More efficient vol estimation\n- Volume Clock Acceleration - Second derivative of volume\n- Hawkes-inspired OFI - Order flow with decay\n- Session Reversal - T+1 effect adapted for forex", "source": "core\\features\\mega_generator.py", "category": "volatility"}
{"instruction": "What is the MegaFeatureGenerator class and how do I use it?", "input": "", "output": "The MegaFeatureGenerator class:\n\nUnified generator for ALL 1200+ features.\n\nFeature breakdown:\n- Alpha101: 62 WorldQuant alphas\n- Alpha158: 179 Microsoft Qlib factors\n- Alpha360: 200 raw price features (compact version)\n- Barra CNE6: 46 risk factors\n- Alpha191: 191 Guotai Junan factors (Chinese institutional)\n- Chinese HFT: 50+ HFT microstructure factors\n- Chinese HFT Additions: 25+ RSRS, Yang-Zhang, Hawkes\n- US Academic: 50 peer-reviewed factors\n- MLFinLab: 17 Lopez de Prado features\n- Time-Series-Library: 41 deep learning inspired\n- Renaissance: 51 weak signals\n- India Quant: 25 IIQF/NSE/RBI factors (NEW 2026-01-17)\n- Japan Quant: 20 JPX/J-Quants factors (NEW 2026-01-17)\n- Europe Quant: 15 Heston/SABR/Rough Vol factors (NEW 2026-01-17)\n- Emerging Markets: 20 Brazil/Asia factors (NEW 2026-01-17)\n- Universal Math: 30 OU/Kelly/Cointegration factors (NEW 2026-01-17)\n- RL Algorithms: 35 Q-Learning/SARSA/TD(λ)/Dyna-Q/Thompson (NEW 2026-01-17)", "source": "core\\features\\mega_generator.py", "category": "alpha"}
{"instruction": "What is the formula for Generate Mega Features?", "input": "", "output": "Generate all 1100+ features in one call.\n\nArgs:\n    df: OHLCV DataFrame\n    alpha360_lookback: 20 for compact (120 features), 60 for full (360 features)\n    verbose: Print progress\n\nReturns:\n    DataFrame with 1100+ features", "source": "core\\features\\mega_generator.py", "category": "alpha"}
{"instruction": "Explain the Generate Mega Features function", "input": "", "output": "Function: generate_mega_features\n\nGenerate all 1100+ features in one call.\n\nArgs:\n    df: OHLCV DataFrame\n    alpha360_lookback: 20 for compact (120 features), 60 for full (360 features)\n    verbose: Print progress\n\nReturns:\n    DataFrame with 1100+ features", "source": "core\\features\\mega_generator.py", "category": "alpha"}
{"instruction": "What is the formula for Generate Chinese Quant Features?", "input": "", "output": "Generate only Chinese Quant features (800+).", "source": "core\\features\\mega_generator.py", "category": "general"}
{"instruction": "Explain the Generate Chinese Quant Features function", "input": "", "output": "Function: generate_chinese_quant_features\n\nGenerate only Chinese Quant features (800+).", "source": "core\\features\\mega_generator.py", "category": "general"}
{"instruction": "What is the formula for Generate Academic Features?", "input": "", "output": "Generate USA Academic + MLFinLab features (67).", "source": "core\\features\\mega_generator.py", "category": "general"}
{"instruction": "Explain the Generate Academic Features function", "input": "", "output": "Function: generate_academic_features\n\nGenerate USA Academic + MLFinLab features (67).", "source": "core\\features\\mega_generator.py", "category": "general"}
{"instruction": "Explain the Generate Renaissance Features function", "input": "", "output": "Function: generate_renaissance_features\n\nGenerate Renaissance weak signals (51).", "source": "core\\features\\mega_generator.py", "category": "alpha"}
{"instruction": "What is the formula for Rsrs?", "input": "", "output": "RSRS (相对强度指标) - Relative Strength Rating System.\nChinese quant standard for regime detection.\n\nCalculates slope of high vs low regression, then z-scores it.\nHigh RSRS = bullish regime, Low RSRS = bearish regime.", "source": "core\\features\\mega_generator.py", "category": "regime"}
{"instruction": "Explain the Rsrs function", "input": "", "output": "Function: rsrs\n\nRSRS (相对强度指标) - Relative Strength Rating System.\nChinese quant standard for regime detection.\n\nCalculates slope of high vs low regression, then z-scores it.\nHigh RSRS = bullish regime, Low RSRS = bearish regime.", "source": "core\\features\\mega_generator.py", "category": "regime"}
{"instruction": "What is the formula for Yang Zhang Volatility?", "input": "", "output": "Yang-Zhang volatility estimator - more efficient than close-to-close.\nCombines overnight, open-close, and Rogers-Satchell components.", "source": "core\\features\\mega_generator.py", "category": "volatility"}
{"instruction": "Explain the Yang Zhang Volatility function", "input": "", "output": "Function: yang_zhang_volatility\n\nYang-Zhang volatility estimator - more efficient than close-to-close.\nCombines overnight, open-close, and Rogers-Satchell components.", "source": "core\\features\\mega_generator.py", "category": "volatility"}
{"instruction": "What is the formula for Volume Clock Acceleration?", "input": "", "output": "Volume clock acceleration (成交量时钟加速度).\nSecond derivative of volume - detects volume regime changes.", "source": "core\\features\\mega_generator.py", "category": "volatility"}
{"instruction": "Explain the Volume Clock Acceleration function", "input": "", "output": "Function: volume_clock_acceleration\n\nVolume clock acceleration (成交量时钟加速度).\nSecond derivative of volume - detects volume regime changes.", "source": "core\\features\\mega_generator.py", "category": "volatility"}
{"instruction": "What is the formula for Hawkes Ofi?", "input": "", "output": "Hawkes-inspired Order Flow Imbalance.\nDecaying impact of past order flow on current intensity.", "source": "core\\features\\mega_generator.py", "category": "execution"}
{"instruction": "Explain the Hawkes Ofi function", "input": "", "output": "Function: hawkes_ofi\n\nHawkes-inspired Order Flow Imbalance.\nDecaying impact of past order flow on current intensity.", "source": "core\\features\\mega_generator.py", "category": "execution"}
{"instruction": "What is OFI in quantitative trading?", "input": "", "output": "OFI (Order Flow Imbalance).\n\nImplementation details:\nHawkes-inspired Order Flow Imbalance.\nDecaying impact of past order flow on current intensity.", "source": "core\\features\\mega_generator.py", "category": "execution"}
{"instruction": "What is the formula for Session Reversal?", "input": "", "output": "Session reversal effect (T+1 adapted for forex).\nContrarian signal based on recent session returns.", "source": "core\\features\\mega_generator.py", "category": "alpha"}
{"instruction": "Explain the Session Reversal function", "input": "", "output": "Function: session_reversal\n\nSession reversal effect (T+1 adapted for forex).\nContrarian signal based on recent session returns.", "source": "core\\features\\mega_generator.py", "category": "alpha"}
{"instruction": "What is the formula for Trade Intensity?", "input": "", "output": "Trade intensity - volume relative to recent average.\nHigh intensity suggests institutional activity.", "source": "core\\features\\mega_generator.py", "category": "volatility"}
{"instruction": "Explain the Trade Intensity function", "input": "", "output": "Function: trade_intensity\n\nTrade intensity - volume relative to recent average.\nHigh intensity suggests institutional activity.", "source": "core\\features\\mega_generator.py", "category": "volatility"}
{"instruction": "Explain the Price Pressure function", "input": "", "output": "Function: price_pressure\n\nPrice pressure indicator.\nMeasures where close is relative to range.", "source": "core\\features\\mega_generator.py", "category": "general"}
{"instruction": "Explain the Generate All function", "input": "", "output": "Function: generate_all\n\nGenerate all Chinese HFT addition features.", "source": "core\\features\\mega_generator.py", "category": "general"}
{"instruction": "What is the formula for Generate All?", "input": "", "output": "Generate ALL 806+ features.\n\nArgs:\n    df: DataFrame with OHLCV data\n        Required columns: open, high, low, close, volume\n        Optional: vwap, returns, bid, ask, price\n    prefix_features: Add source prefix to feature names (e.g., ALPHA101_*)\n\nReturns:\n    DataFrame with all features (NaN/inf cleaned)", "source": "core\\features\\mega_generator.py", "category": "alpha"}
{"instruction": "Explain the Generate All function", "input": "", "output": "Function: generate_all\n\nGenerate ALL 806+ features.\n\nArgs:\n    df: DataFrame with OHLCV data\n        Required columns: open, high, low, close, volume\n        Optional: vwap, returns, bid, ask, price\n    prefix_features: Add source prefix to feature names (e.g., ALPHA101_*)\n\nReturns:\n    DataFrame with all features (NaN/inf cleaned)", "source": "core\\features\\mega_generator.py", "category": "alpha"}
{"instruction": "What is VWAP in quantitative trading?", "input": "", "output": "VWAP (Volume-Weighted Average Price execution).\n\nImplementation details:\nGenerate ALL 806+ features.\n\nArgs:\n    df: DataFrame with OHLCV data\n        Required columns: open, high, low, close, volume\n        Optional: vwap, returns, bid, ask, price\n    prefix_features: Add source prefix to feature names (e.g., ALPHA101_*)\n\nReturns:\n    DataFrame with all features (NaN/inf cleaned)", "source": "core\\features\\mega_generator.py", "category": "alpha"}
{"instruction": "Explain the Get Feature Counts function", "input": "", "output": "Function: get_feature_counts\n\nGet expected feature counts for each library.", "source": "core\\features\\mega_generator.py", "category": "general"}
{"instruction": "Explain the Get Feature Names function", "input": "", "output": "Function: get_feature_names\n\nGet all feature names (without generating them).", "source": "core\\features\\mega_generator.py", "category": "general"}
{"instruction": "What is the source paper for Primary?", "input": "", "output": "The source is: DeepSeek-AI (2024). ", "source": "core\\features\\mla_attention.py", "category": "microstructure"}
{"instruction": "What is the source paper for time trading decisions?", "input": "", "output": "The source is: DeepSeek-V3 Technical Report (arXiv:2412.19437). ", "source": "core\\features\\mla_attention.py", "category": "microstructure"}
{"instruction": "What is the source paper for research paper?", "input": "", "output": "The source is: arXiv:2412.19437. ", "source": "core\\features\\mla_attention.py", "category": "microstructure"}
{"instruction": "Explain the purpose of Multi-Head Latent Attention (MLA) for Time Series", "input": "", "output": "Multi-Head Latent Attention (MLA) for Time Series\n==================================================\n\nACADEMIC CITATION:\n==================\n\nPrimary Paper:\n    DeepSeek-AI (2024)\n    \"DeepSeek-V3 Technical Report\"\n    arXiv:2412.19437\n    https://arxiv.org/abs/2412.19437\n\n    Key Innovation: Low-rank joint compression for attention keys and values\n    to reduce Key-Value (KV) cache by 85%+ while maintaining performance.\n\nTechnical Specifications (from DeepSeek-V3):\n    - Number of attention heads: 128\n    - Per-head dimension: 128\n    - KV compression dimension: 512\n    - KV cache per token: 70 KB (vs LLaMA-3.1's 516 KB)\n\nRelated Work:\n    - \"TransMLA: Multi-Head Latent Attention\" (2025) arXiv:2502.07864\n    - \"Enabling DeepSeek's MLA in Any Transformer\" (2025) arXiv:2502.14837\n    - \"Hardware-Centric Analysis of MLA\" (2025) arXiv:2506.02523\n\nARCHITECTURE:\n=============\n\nStandard Multi-Head Attention:\n    Q, K, V = W_q X, W_k X, W_v X\n    Attention = softmax(Q K^T / sqrt(d)) V\n    Memory: O(n * d * h) for KV cache\n\nMLA (Multi-Head Latent Attention):\n    1. Compress K, V jointly into low-rank latent representation\n    2. Store compressed latent (much smaller)\n    3. Decompress on-the-fly for attention computation\n\n    c = W_c X  (compressed latent, dimension d_c << d*h)\n    K = W_k c  (decompress to keys)\n    V = W_v c  (decompress to values)\n\n    Memory: O(n * d_c) where d_c = 512 << 128*128 = 16384\n\nFOREX TRADING APPLICATION:\n===========================\n\nProblem: Long price history (100k+ ticks) doesn't fit in GPU memory\n\nStandard Transformer:\n    - 100k ticks * 16 KB/tick = 1.6 GB KV cache\n    - Can only process ~10k ticks on 16GB GPU\n\nMLA Transformer:\n    - 100k ticks * 2 KB/tick = 200 MB KV cache\n    - Can process 100k+ ticks on same GPU\n    - 8x longer context = better regime detection\n\nBenefits for Trading:\n    - Process longer price history\n    - Capture long-term patterns (days/weeks vs hours)\n    - Lower latency (less memory transfer)\n    - Same prediction accuracy\n\nUSAGE:\n======\n\n    from core.features.mla_attention import MLAAttention, MLAConfig\n\n    config = MLAConfig(\n        d_model=128,        # Model dimension\n        n_heads=8,          # Number of attention heads\n        d_compress=32,      # Compression dimension (d_model/4)\n    )\n\n    mla = MLAAttention(config)\n\n    # Input: (batch_size, seq_len, d_model)\n    x = torch.randn(32, 1000, 128)  # 1000 ticks\n    output = mla(x)  # (32, 1000, 128)\n\nMEMORY COMPARISON:\n==================\n\nFor sequence length L=10,000, d_model=128, n_heads=8:\n\nStandard Attention:\n    KV cache = L * n_heads * d_head * 2 (K+V)\n             = 10000 * 8 * 16 * 2 = 2.56M floats = 10 MB\n\nMLA:\n    Compressed cache = L * d_compress\n                     = 10000 * 32 = 320K floats = 1.28 MB\n\n    Reduction: 87.5%\n\nCHINESE QUANT CONNECTION:\n=========================\n\nDeepSeek (幻方量化 High-Flyer) used MLA to:\n- Train 671B parameter model on 10,000 A100 GPUs\n- Achieve GPT-4 level performance at 1/10 the cost\n- Enable efficient inference for real-time trading decisions\n\nSource: DeepSeek-V3 Technical Report (arXiv:2412.19437)", "source": "core\\features\\mla_attention.py", "category": "microstructure"}
{"instruction": "What is the MLAConfig class and how do I use it?", "input": "", "output": "The MLAConfig class:\n\nConfiguration for MLA module.\n\nBased on DeepSeek-V3 specifications (arXiv:2412.19437 Section 2.1).", "source": "core\\features\\mla_attention.py", "category": "general"}
{"instruction": "What is the MLAAttention class and how do I use it?", "input": "", "output": "The MLAAttention class:\n\nMulti-Head Latent Attention.\n\nImplementation of DeepSeek-V3's MLA mechanism (arXiv:2412.19437).\n\nKey idea: Compress K, V into low-rank latent representation,\nreducing KV cache by 85%+ with minimal accuracy loss.", "source": "core\\features\\mla_attention.py", "category": "general"}
{"instruction": "What is the MLATransformerBlock class and how do I use it?", "input": "", "output": "The MLATransformerBlock class:\n\nTransformer block with MLA instead of standard attention.\n\nCan be used as drop-in replacement for standard transformer blocks.", "source": "core\\features\\mla_attention.py", "category": "general"}
{"instruction": "What is the MLATimeSeries class and how do I use it?", "input": "", "output": "The MLATimeSeries class:\n\nFull MLA-based model for time series forecasting.\n\nDesigned for forex price prediction with long context.", "source": "core\\features\\mla_attention.py", "category": "time_series"}
{"instruction": "What is the formula for Create Mla Model?", "input": "", "output": "Create MLA model with DeepSeek-V3 inspired hyperparameters.\n\nArgs:\n    input_dim: Number of input features\n    output_dim: Number of output predictions\n    context_length: Maximum sequence length to process\n\nReturns:\n    MLATimeSeries model", "source": "core\\features\\mla_attention.py", "category": "general"}
{"instruction": "Explain the Create Mla Model function", "input": "", "output": "Function: create_mla_model\n\nCreate MLA model with DeepSeek-V3 inspired hyperparameters.\n\nArgs:\n    input_dim: Number of input features\n    output_dim: Number of output predictions\n    context_length: Maximum sequence length to process\n\nReturns:\n    MLATimeSeries model", "source": "core\\features\\mla_attention.py", "category": "general"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nForward pass with MLA.\n\nArgs:\n    x: (batch_size, seq_len, d_model)\n    mask: (batch_size, seq_len, seq_len) optional attention mask\n    return_compressed: If True, return compressed latent\n\nReturns:\n    output: (batch_size, seq_len, d_model)\n    compressed: (batch_size, seq_len, d_compress) if return_compressed", "source": "core\\features\\mla_attention.py", "category": "microstructure"}
{"instruction": "Explain the Get Kv Cache Size function", "input": "", "output": "Function: get_kv_cache_size\n\nCalculate KV cache size in bytes.\n\nArgs:\n    seq_len: Sequence length\n\nReturns:\n    Cache size in bytes", "source": "core\\features\\mla_attention.py", "category": "general"}
{"instruction": "Explain the Get Standard Kv Cache Size function", "input": "", "output": "Function: get_standard_kv_cache_size\n\nCalculate standard attention KV cache size for comparison.\n\nArgs:\n    seq_len: Sequence length\n\nReturns:\n    Cache size in bytes", "source": "core\\features\\mla_attention.py", "category": "general"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nForward pass.\n\nArgs:\n    x: (batch_size, seq_len, d_model)\n    mask: Optional attention mask\n\nReturns:\n    output: (batch_size, seq_len, d_model)", "source": "core\\features\\mla_attention.py", "category": "microstructure"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nForward pass.\n\nArgs:\n    x: (batch_size, seq_len, input_dim)\n\nReturns:\n    predictions: (batch_size, seq_len, output_dim)", "source": "core\\features\\mla_attention.py", "category": "general"}
{"instruction": "What is the source paper for this technique?", "input": "", "output": "The source is: https://github.com/hudson-and-thames/mlfinlab. ", "source": "core\\features\\mlfinlab_features.py", "category": "microstructure"}
{"instruction": "Explain the purpose of MLFinLab Features - Lopez de Prado Methods", "input": "", "output": "MLFinLab Features - Lopez de Prado Methods\n===========================================\nGold standard implementations from \"Advances in Financial Machine Learning\"\nby Dr. Marcos Lopez de Prado.\n\nSource: https://github.com/hudson-and-thames/mlfinlab\nDocumentation: https://www.mlfinlab.com/\n\nImplemented Features:\n1. Triple Barrier Method - Dynamic labeling\n2. Meta-Labeling - Secondary model for bet sizing\n3. Fractional Differentiation - Stationarity while preserving memory\n4. CUSUM Filter - Event-based sampling\n5. Entropy Features - Market microstructure\n6. Structural Breaks - Regime detection\n\nThese methods are used by institutional quants worldwide.", "source": "core\\features\\mlfinlab_features.py", "category": "microstructure"}
{"instruction": "What is the TripleBarrierLabeling class and how do I use it?", "input": "", "output": "The TripleBarrierLabeling class:\n\nTriple Barrier Method for labeling financial time series.\n\nFrom Chapter 3 of \"Advances in Financial Machine Learning\".\n\nThree barriers:\n- Upper barrier: Take profit (positive return threshold)\n- Lower barrier: Stop loss (negative return threshold)\n- Vertical barrier: Maximum holding period\n\nLabel assignment:\n- 1: Upper barrier hit first (profitable trade)\n- -1: Lower barrier hit first (losing trade)\n- 0: Vertical barrier hit (timeout)", "source": "core\\features\\mlfinlab_features.py", "category": "rl"}
{"instruction": "What is the MetaLabeling class and how do I use it?", "input": "", "output": "The MetaLabeling class:\n\nMeta-Labeling for bet sizing.\n\nFrom Chapter 3 of \"Advances in Financial Machine Learning\".\n\nMeta-labeling is a secondary model that learns when to bet,\nnot the direction. It improves precision while maintaining recall.\n\nUsage:\n1. Primary model predicts direction (side)\n2. Meta-label model predicts whether to take the bet (0 or 1)\n3. Final position = side * meta_label * bet_size", "source": "core\\features\\mlfinlab_features.py", "category": "ensemble"}
{"instruction": "Show me a code example for MetaLabeling", "input": "", "output": "1. Primary model predicts direction (side)\n2. Meta-label model predicts whether to take the bet (0 or 1)\n3. Final position = side * meta_label * bet_size", "source": "core\\features\\mlfinlab_features.py", "category": "ensemble"}
{"instruction": "What is the FractionalDifferentiation class and how do I use it?", "input": "", "output": "The FractionalDifferentiation class:\n\nFractional Differentiation for stationarity.\n\nFrom Chapter 5 of \"Advances in Financial Machine Learning\".\n\nMakes series stationary while preserving memory (predictive power).\nStandard differencing (d=1) removes too much memory.\nFractional d (0 < d < 1) balances stationarity and memory.", "source": "core\\features\\mlfinlab_features.py", "category": "general"}
{"instruction": "What is the CUSUMFilter class and how do I use it?", "input": "", "output": "The CUSUMFilter class:\n\nCUSUM Filter for event-based sampling.\n\nFrom Chapter 2 of \"Advances in Financial Machine Learning\".\n\nSamples events when cumulative sum of returns exceeds threshold.\nMore efficient than fixed-time sampling.", "source": "core\\features\\mlfinlab_features.py", "category": "general"}
{"instruction": "What is the EntropyFeatures class and how do I use it?", "input": "", "output": "The EntropyFeatures class:\n\nEntropy-based features for market microstructure.\n\nFrom Chapter 18 of \"Advances in Financial Machine Learning\".\n\nEntropy measures information content and market efficiency.", "source": "core\\features\\mlfinlab_features.py", "category": "microstructure"}
{"instruction": "What is the MLFinLabFeatures class and how do I use it?", "input": "", "output": "The MLFinLabFeatures class:\n\nCombined MLFinLab feature generator.\n\nGenerates all Lopez de Prado features in one call.", "source": "core\\features\\mlfinlab_features.py", "category": "general"}
{"instruction": "Explain the Generate Mlfinlab Features function", "input": "", "output": "Function: generate_mlfinlab_features\n\nGenerate MLFinLab features.\n\nArgs:\n    df: OHLCV DataFrame\n\nReturns:\n    DataFrame with ~17 MLFinLab features", "source": "core\\features\\mlfinlab_features.py", "category": "general"}
{"instruction": "Explain the Get Daily Volatility function", "input": "", "output": "Function: get_daily_volatility\n\nEstimate daily volatility using exponential weighted std.", "source": "core\\features\\mlfinlab_features.py", "category": "volatility"}
{"instruction": "Explain the Apply Triple Barrier function", "input": "", "output": "Function: apply_triple_barrier\n\nApply triple barrier method to generate labels.\n\nArgs:\n    close: Price series\n    events: Event timestamps (if None, use all)\n\nReturns:\n    DataFrame with columns: t1 (barrier time), ret, label", "source": "core\\features\\mlfinlab_features.py", "category": "general"}
{"instruction": "What is the formula for Generate Meta Labels?", "input": "", "output": "Generate meta-labels based on primary signal correctness.\n\nArgs:\n    primary_signal: Primary model predictions (-1, 0, 1)\n    actual_returns: Actual forward returns\n\nReturns:\n    Series of meta-labels (1 = correct, 0 = incorrect)", "source": "core\\features\\mlfinlab_features.py", "category": "alpha"}
{"instruction": "Explain the Generate Meta Labels function", "input": "", "output": "Function: generate_meta_labels\n\nGenerate meta-labels based on primary signal correctness.\n\nArgs:\n    primary_signal: Primary model predictions (-1, 0, 1)\n    actual_returns: Actual forward returns\n\nReturns:\n    Series of meta-labels (1 = correct, 0 = incorrect)", "source": "core\\features\\mlfinlab_features.py", "category": "alpha"}
{"instruction": "Explain the Get Weights function", "input": "", "output": "Function: get_weights\n\nCalculate fractional differentiation weights.", "source": "core\\features\\mlfinlab_features.py", "category": "general"}
{"instruction": "Explain the Frac Diff function", "input": "", "output": "Function: frac_diff\n\nApply fractional differentiation.\n\nArgs:\n    series: Input time series\n\nReturns:\n    Fractionally differentiated series", "source": "core\\features\\mlfinlab_features.py", "category": "general"}
{"instruction": "Explain the Get Events function", "input": "", "output": "Function: get_events\n\nGet event timestamps using CUSUM filter.\n\nArgs:\n    close: Price series\n\nReturns:\n    DatetimeIndex of event times", "source": "core\\features\\mlfinlab_features.py", "category": "general"}
{"instruction": "Explain the Shannon Entropy function", "input": "", "output": "Function: shannon_entropy\n\nCalculate rolling Shannon entropy.", "source": "core\\features\\mlfinlab_features.py", "category": "general"}
{"instruction": "What is the formula for Approximate Entropy?", "input": "", "output": "Calculate rolling Approximate Entropy.\n\nMeasures regularity/predictability of time series.\nLower = more regular, Higher = more random.", "source": "core\\features\\mlfinlab_features.py", "category": "general"}
{"instruction": "Explain the Approximate Entropy function", "input": "", "output": "Function: approximate_entropy\n\nCalculate rolling Approximate Entropy.\n\nMeasures regularity/predictability of time series.\nLower = more regular, Higher = more random.", "source": "core\\features\\mlfinlab_features.py", "category": "general"}
{"instruction": "Explain the Generate All function", "input": "", "output": "Function: generate_all\n\nGenerate all MLFinLab features.\n\nArgs:\n    df: DataFrame with close price\n\nReturns:\n    DataFrame with MLFinLab features", "source": "core\\features\\mlfinlab_features.py", "category": "general"}
{"instruction": "Explain the Get Feature Names function", "input": "", "output": "Function: get_feature_names\n\nGet list of feature names.", "source": "core\\features\\mlfinlab_features.py", "category": "general"}
{"instruction": "Explain the purpose of Mixture of Experts (MOE) Trading Module", "input": "", "output": "Mixture of Experts (MOE) Trading Module\n=======================================\nGold standard MOE architecture for trading from Chinese/Asian research.\n\nCitation:\n    Zou, W. et al. (2024). \"Trading like Gurus: Mixture of Instructions\n    for Profitable Intelligent Trading.\" arXiv.\n    - 24% excess annual return demonstrated\n    - Multiple expert networks (momentum, mean-rev, volatility, trend)\n    - Gating network selects experts based on market regime\n\nKey Innovation:\n    - Each expert specializes in a market condition\n    - Gating network learns optimal expert weights\n    - Ensemble output combines expert predictions\n\nImplementation:\n    - MomentumExpert: Trend-following signals\n    - MeanReversionExpert: Mean-reversion signals\n    - VolatilityExpert: Volatility regime signals\n    - TrendExpert: Trend strength signals\n    - GatingNetwork: Regime-based expert selection\n\nTotal: 20 features\n\nUsage:\n    from core.features.moe_trading import MixtureOfExpertsFeatures\n    moe = MixtureOfExpertsFeatures()\n    features = moe.generate_all(df)", "source": "core\\features\\moe_trading.py", "category": "alpha"}
{"instruction": "What is the MomentumExpert class and how do I use it?", "input": "", "output": "The MomentumExpert class:\n\nMomentum Expert Network.\n\nSpecializes in trending market conditions.\nUses multiple momentum indicators with different horizons.\n\nReference: Jegadeesh & Titman (1993) \"Returns to Buying Winners\"", "source": "core\\features\\moe_trading.py", "category": "general"}
{"instruction": "What is the MeanReversionExpert class and how do I use it?", "input": "", "output": "The MeanReversionExpert class:\n\nMean Reversion Expert Network.\n\nSpecializes in range-bound markets.\nUses mean-reversion indicators with Ornstein-Uhlenbeck dynamics.\n\nReference: Poterba & Summers (1988) \"Mean Reversion in Stock Prices\"", "source": "core\\features\\moe_trading.py", "category": "general"}
{"instruction": "What is the VolatilityExpert class and how do I use it?", "input": "", "output": "The VolatilityExpert class:\n\nVolatility Expert Network.\n\nSpecializes in volatility regime detection and trading.\nUses volatility clustering and regime detection.\n\nReference: Engle (1982) \"Autoregressive Conditional Heteroskedasticity\"", "source": "core\\features\\moe_trading.py", "category": "volatility"}
{"instruction": "What is the TrendExpert class and how do I use it?", "input": "", "output": "The TrendExpert class:\n\nTrend Expert Network.\n\nSpecializes in identifying and trading trends.\nUses ADX, moving average alignment, and trend persistence.\n\nReference: Wilder (1978) \"New Concepts in Technical Trading Systems\"", "source": "core\\features\\moe_trading.py", "category": "general"}
{"instruction": "What is the GatingNetwork class and how do I use it?", "input": "", "output": "The GatingNetwork class:\n\nGating Network for Expert Selection.\n\nLearns optimal weights for combining experts based on market state.\nUses softmax attention over expert outputs.\n\nReference: Jacobs et al. (1991) \"Adaptive Mixtures of Local Experts\"", "source": "core\\features\\moe_trading.py", "category": "regime"}
{"instruction": "What is the MixtureOfExpertsFeatures class and how do I use it?", "input": "", "output": "The MixtureOfExpertsFeatures class:\n\nMixture of Experts Feature Generator.\n\nCombines multiple expert networks with gating mechanism.\nBased on MIGA paper demonstrating 24% excess returns.\n\nCitations:\n[1] Zou et al. (2024). \"Trading like Gurus: Mixture of Instructions\n    for Profitable Intelligent Trading.\" arXiv.\n[2] Jacobs et al. (1991). \"Adaptive Mixtures of Local Experts\"\n    Neural Computation.\n[3] Shazeer et al. (2017). \"Outrageously Large Neural Networks:\n    The Sparsely-Gated Mixture-of-Experts Layer\" ICLR.\n\nTotal: 20 features\n- Momentum Expert: 4 features\n- Mean Reversion Expert: 3 features\n- Volatility Expert: 3 features\n- Trend Expert: 3 features\n- Gating: 4 features\n- Combined: 3 features", "source": "core\\features\\moe_trading.py", "category": "volatility"}
{"instruction": "Explain the Generate Moe Features function", "input": "", "output": "Function: generate_moe_features\n\nGenerate MOE trading features.\n\nArgs:\n    df: OHLCV DataFrame\n\nReturns:\n    DataFrame with 20 MOE features", "source": "core\\features\\moe_trading.py", "category": "general"}
{"instruction": "Explain the Generate Signals function", "input": "", "output": "Function: generate_signals\n\nGenerate momentum expert signals.", "source": "core\\features\\moe_trading.py", "category": "alpha"}
{"instruction": "What is the formula for Generate Signals?", "input": "", "output": "Generate mean-reversion expert signals.", "source": "core\\features\\moe_trading.py", "category": "alpha"}
{"instruction": "Explain the Generate Signals function", "input": "", "output": "Function: generate_signals\n\nGenerate mean-reversion expert signals.", "source": "core\\features\\moe_trading.py", "category": "alpha"}
{"instruction": "Explain the Generate Signals function", "input": "", "output": "Function: generate_signals\n\nGenerate volatility expert signals.", "source": "core\\features\\moe_trading.py", "category": "alpha"}
{"instruction": "Explain the Generate Signals function", "input": "", "output": "Function: generate_signals\n\nGenerate trend expert signals.", "source": "core\\features\\moe_trading.py", "category": "alpha"}
{"instruction": "Explain the Compute Gates function", "input": "", "output": "Function: compute_gates\n\nCompute gating weights from expert confidences.\n\nArgs:\n    expert_confidences: DataFrame with confidence columns from each expert\n\nReturns:\n    DataFrame with normalized gate weights", "source": "core\\features\\moe_trading.py", "category": "general"}
{"instruction": "Explain the Generate All function", "input": "", "output": "Function: generate_all\n\nGenerate all MOE features.\n\nArgs:\n    df: DataFrame with OHLCV data\n\nReturns:\n    DataFrame with 20 MOE features", "source": "core\\features\\moe_trading.py", "category": "general"}
{"instruction": "Explain the Get Feature Names function", "input": "", "output": "Function: get_feature_names\n\nGet list of all feature names.", "source": "core\\features\\moe_trading.py", "category": "general"}
{"instruction": "Explain the Get Citations function", "input": "", "output": "Function: get_citations\n\nGet academic citations for MOE trading.", "source": "core\\features\\moe_trading.py", "category": "general"}
{"instruction": "Explain the purpose of Renaissance Technologies - Weak Signals Generator", "input": "", "output": "Renaissance Technologies - Weak Signals Generator\nImplements 50+ weak trading signals based on Renaissance principles\n\nJim Simons approach:\n- Multiple weak signals (each 51-55% accuracy)\n- Combined into strong ensemble\n- High-frequency execution\n- Statistical rigor", "source": "core\\features\\renaissance.py", "category": "alpha"}
{"instruction": "What is the RenaissanceSignalGenerator class and how do I use it?", "input": "", "output": "The RenaissanceSignalGenerator class:\n\nGenerate 50+ weak signals following Renaissance methodology\n\nPhilosophy:\n- No single signal is strong (each ~52-55% accuracy)\n- Combine many weak signals for robust predictions\n- Focus on statistical significance\n- Short holding periods", "source": "core\\features\\renaissance.py", "category": "alpha"}
{"instruction": "Explain the Test Renaissance Signals function", "input": "", "output": "Function: test_renaissance_signals\n\nTest Renaissance signals generation", "source": "core\\features\\renaissance.py", "category": "alpha"}
{"instruction": "What is the formula for Generate All Signals?", "input": "", "output": "Generate all Renaissance-style signals", "source": "core\\features\\renaissance.py", "category": "alpha"}
{"instruction": "Explain the Generate All Signals function", "input": "", "output": "Function: generate_all_signals\n\nGenerate all Renaissance-style signals", "source": "core\\features\\renaissance.py", "category": "alpha"}
{"instruction": "Explain the Ensemble Signals function", "input": "", "output": "Function: ensemble_signals\n\nCombine weak signals into ensemble prediction\n\nArgs:\n    method: 'average', 'weighted', 'vote'", "source": "core\\features\\renaissance.py", "category": "alpha"}
{"instruction": "What is the source paper for White?", "input": "", "output": "The source is: Applications of RL in Quantitative Trading). ", "source": "core\\features\\rl_algorithms.py", "category": "alpha"}
{"instruction": "Explain the purpose of Pure Mathematical Reinforcement Learning Algorithms for Trading", "input": "", "output": "Pure Mathematical Reinforcement Learning Algorithms for Trading\n===============================================================\nAlgorithmic RL methods WITHOUT neural networks - pure mathematical formulations.\n\nThis module implements the mathematical foundations of RL as used by:\n- Chinese quants (强化学习量化交易)\n- Worldwide institutional traders\n- Academic research (Almgren-Chriss, Hamilton-Jacobi-Bellman)\n\n═══════════════════════════════════════════════════════════════════════════════\nACADEMIC CITATIONS (Full Bibliographic References)\n═══════════════════════════════════════════════════════════════════════════════\n\nQ-LEARNING:\n    Watkins, C.J.C.H. (1989). \"Learning from Delayed Rewards.\"\n    PhD Thesis, King's College, Cambridge University.\n    - Original Q-learning algorithm with convergence proof\n\n    Watkins, C.J.C.H. & Dayan, P. (1992). \"Q-learning.\"\n    Machine Learning, 8(3-4), 279-292. DOI: 10.1007/BF00992698\n    - Formal convergence analysis\n\nSARSA:\n    Rummery, G.A. & Niranjan, M. (1994). \"On-Line Q-Learning Using\n    Connectionist Systems.\" Technical Report CUED/F-INFENG/TR 166,\n    Cambridge University Engineering Department.\n    - Original SARSA algorithm (State-Action-Reward-State-Action)\n\n    Sutton, R.S. (1996). \"Generalization in Reinforcement Learning:\n    Successful Examples Using Sparse Coarse Coding.\"\n    Advances in Neural Information Processing Systems (NIPS), 8, 1038-1044.\n\nTD(λ) - TEMPORAL DIFFERENCE WITH ELIGIBILITY TRACES:\n    Sutton, R.S. (1988). \"Learning to Predict by the Methods of\n    Temporal Differences.\" Machine Learning, 3(1), 9-44.\n    DOI: 10.1007/BF00115009\n    - Foundation of TD learning\n\n    Tesauro, G. (1994). \"TD-Gammon, a Self-Teaching Backgammon Program,\n    Achieves Master-Level Play.\" Neural Computation, 6(2), 215-219.\n    - Famous TD(λ) application achieving superhuman performance\n\nDYNA-Q (MODEL-BASED RL):\n    Sutton, R.S. (1991). \"Dyna, an Integrated Architecture for Learning,\n    Planning, and Reacting.\" ACM SIGART Bulletin, 2(4), 160-163.\n    - Original Dyna architecture combining model-free and model-based RL\n\n    Sutton, R.S. (1990). \"Integrated Architectures for Learning, Planning,\n    and Reacting Based on Approximating Dynamic Programming.\"\n    Proceedings of the 7th International Conference on Machine Learning.\n\nTHOMPSON SAMPLING:\n    Thompson, W.R. (1933). \"On the Likelihood that One Unknown Probability\n    Exceeds Another in View of the Evidence of Two Samples.\"\n    Biometrika, 25(3-4), 285-294. DOI: 10.2307/2332286\n    - Original Thompson Sampling algorithm (90+ years old, still SOTA)\n\n    Agrawal, S. & Goyal, N. (2012). \"Analysis of Thompson Sampling for\n    the Multi-armed Bandit Problem.\"\n    Proceedings of the 25th Conference on Learning Theory (COLT), 39.1-39.26.\n    - Modern regret analysis proving near-optimality\n\n    Russo, D.J. et al. (2018). \"A Tutorial on Thompson Sampling.\"\n    Foundations and Trends in Machine Learning, 11(1), 1-96.\n    DOI: 10.1561/2200000070\n\nALMGREN-CHRISS OPTIMAL EXECUTION:\n    Almgren, R. & Chriss, N. (2001). \"Optimal Execution of Portfolio\n    Transactions.\" Journal of Risk, 3(2), 5-39.\n    - Seminal paper on optimal trade execution with market impact\n\n    Almgren, R. (2003). \"Optimal Execution with Nonlinear Impact Functions\n    and Trading-Enhanced Risk.\" Applied Mathematical Finance, 10(1), 1-18.\n    DOI: 10.1080/135048602100056\n\n    Gatheral, J. & Schied, A. (2011). \"Optimal Trade Execution under\n    Geometric Brownian Motion in the Almgren and Chriss Framework.\"\n    International Journal of Theoretical and Applied Finance, 14(3), 353-368.\n\n    Ning, B., Ling, F.H.T. & Jaimungal, S. (2021). \"Double Deep Q-Learning\n    for Optimal Execution.\" Applied Mathematical Finance, 28(4), 361-380.\n    DOI: 10.1080/1350486X.2022.2077783\n    - RL extension achieving 10.3% improvement over base Almgren-Chriss\n\nKELLY CRITERION:\n    Kelly, J.L. (1956). \"A New Interpretation of Information Rate.\"\n    Bell System Technical Journal, 35(4), 917-926.\n    DOI: 10.1002/j.1538-7305.1956.tb03809.x\n    - Original optimal betting fraction\n\n    Thorp, E.O. (2006). \"The Kelly Criterion in Blackjack, Sports Betting,\n    and the Stock Market.\" Handbook of Asset and Liability Management, 1, 385-428.\n    - Kelly applications in finance\n\nCOMPREHENSIVE RL IN FINANCE:\n    Hambly, B., Xu, R. & Yang, H. (2023). \"Recent Advances in Reinforcement\n    Learning in Finance.\" Mathematical Finance, 33(3), 437-503.\n    DOI: 10.1111/mafi.12382\n    - Comprehensive review of RL applications in quantitative finance\n\n    Sutton, R.S. & Barto, A.G. (2018). \"Reinforcement Learning:\n    An Introduction\" (2nd ed.). MIT Press. ISBN: 978-0262039246\n    - Definitive RL textbook\n\nCHINESE QUANT SOURCES (中文量化资源):\n    Liu, X.Y. et al. (2022). \"FinRL: Deep Reinforcement Learning Framework\n    to Automate Trading in Quantitative Finance.\"\n    ACM International Conference on AI in Finance (ICAIF).\n    GitHub: https://github.com/AI4Finance-Foundation/FinRL\n\n    BigQuant (2024). \"强化学习在量化交易中的应用白皮书\"\n    (Whitepaper: Applications of RL in Quantitative Trading)\n\n    ai_quant_trade - Chinese Quant RL Implementations\n    GitHub: https://github.com/wizardforcel/ai_quant_trade\n\n═══════════════════════════════════════════════════════════════════════════════\nFEATURE SUMMARY (35 Total)\n═══════════════════════════════════════════════════════════════════════════════\n\nQ-Learning Signals (6 features):\n    - RL_QLEARN_SIGNAL: Trading signal from Q-value softmax\n    - RL_QLEARN_TD_ERROR: Temporal difference error\n    - RL_QLEARN_Q_BUY: Q-value for buy action\n    - RL_QLEARN_Q_SELL: Q-value for sell action\n    - RL_QLEARN_Q_SPREAD: Spread between buy/sell Q-values\n    - RL_QLEARN_CONFIDENCE: Max Q-value (action confidence)\n\nSARSA Signals (5 features):\n    - RL_SARSA_SIGNAL: On-policy trading signal\n    - RL_SARSA_TD_ERROR: SARSA TD error (more conservative)\n    - RL_SARSA_Q_DIV: Q-value divergence from Q-learning\n    - RL_SARSA_SAFE: Safety signal (lower when risky)\n    - RL_SARSA_CAUTION: Caution level for volatile states\n\nTD(λ) Features (5 features):\n    - RL_TD_VALUE: State value estimate\n    - RL_TD_ERROR: TD error with traces\n    - RL_TD_ELIGIBILITY: Eligibility trace strength\n    - RL_TD_CREDIT: Temporal credit assignment\n    - RL_TD_HORIZON: Effective horizon (λ-dependent)\n\nDyna-Q Features (5 features):\n    - RL_DYNA_SIGNAL: Model-based trading signal\n    - RL_DYNA_PLANNING: Planning value improvement\n    - RL_DYNA_MODEL_SIZE: Transition model coverage\n    - RL_DYNA_CONFIDENCE: Model confidence\n    - RL_DYNA_NOVELTY: State novelty (inverse of visits)\n\nThompson Sampling (5 features):\n    - RL_TS_SIGNAL: Posterior mean signal\n    - RL_TS_UNCERTAINTY: Posterior uncertainty\n    - RL_TS_SAMPLED: Sampled action value\n    - RL_TS_EXPLORE: Exploration bonus\n    - RL_TS_EXPLOIT: Exploitation score\n\nOptimal Execution - Almgren-Chriss (5 features):\n    - RL_EXEC_URGENCY: Execution urgency (κ parameter)\n    - RL_EXEC_AGGRESSION: Aggressiveness level\n    - RL_EXEC_VOL_ADJ: Volatility-adjusted execution\n    - RL_EXEC_SPREAD_ADJ: Spread-adjusted execution\n    - RL_EXEC_REGIME: Execution regime signal\n\nKelly-RL Integration (4 features):\n    - RL_KELLY_FRAC: Kelly fraction from RL estimates\n    - RL_KELLY_EDGE: Estimated edge from Q-values\n    - RL_KELLY_CONFIDENCE: RL-weighted Kelly confidence\n    - RL_KELLY_SIGNAL: Combined Kelly-RL signal\n\n═══════════════════════════════════════════════════════════════════════════════\nMATHEMATICAL NOTATION\n═══════════════════════════════════════════════════════════════════════════════\n\n- Q(s,a): Action-value function (expected return from state s taking action a)\n- V(s): State-value function (expected return from state s)\n- π(a|s): Policy (probability of action a in state s)\n- α: Learning rate (step size, typically 0.01-0.3)\n- γ: Discount factor (0 < γ < 1, typically 0.95-0.99)\n- λ: Eligibility trace decay (0 = TD(0), 1 = Monte Carlo)\n- δ: TD error = r + γV(s') - V(s)\n- e(s): Eligibility trace for state s\n- κ: Almgren-Chriss urgency parameter = √(λσ²/η)\n- f*: Kelly optimal fraction = (p·b - q) / b where p=win prob, q=1-p, b=odds", "source": "core\\features\\rl_algorithms.py", "category": "alpha"}
{"instruction": "What is the RLState class and how do I use it?", "input": "", "output": "The RLState class:\n\nDiscretized market state for tabular RL.", "source": "core\\features\\rl_algorithms.py", "category": "rl"}
{"instruction": "What is the QLearningTrader class and how do I use it?", "input": "", "output": "The QLearningTrader class:\n\nTabular Q-Learning for trading decisions.\n\nQ-Learning Update Rule:\nQ(s,a) ← Q(s,a) + α[r + γ·max_a' Q(s',a') - Q(s,a)]\n\nThis is off-policy: learns optimal Q* regardless of behavior policy.\nAggressive in seeking maximum reward.\n\nReferences:\n- Watkins (1989): \"Learning from Delayed Rewards\"\n- FinRL: DQN variations for trading", "source": "core\\features\\rl_algorithms.py", "category": "risk"}
{"instruction": "What is the SARSATrader class and how do I use it?", "input": "", "output": "The SARSATrader class:\n\nSARSA (State-Action-Reward-State-Action) for safer trading.\n\nSARSA Update Rule:\nQ(s,a) ← Q(s,a) + α[r + γ·Q(s',a') - Q(s,a)]\n\nThis is on-policy: learns Q for current policy, not optimal Q*.\nMore conservative than Q-learning in volatile markets.\n\nReferences:\n- Rummery & Niranjan (1994): \"On-Line Q-Learning\"\n- MQL5 Article: SARSA for MetaTrader", "source": "core\\features\\rl_algorithms.py", "category": "volatility"}
{"instruction": "What is the TDLambdaTrader class and how do I use it?", "input": "", "output": "The TDLambdaTrader class:\n\nTD(λ) with Eligibility Traces for trading.\n\nTD(λ) bridges TD(0) and Monte Carlo:\n- λ = 0: One-step TD (low variance, high bias)\n- λ = 1: Monte Carlo (low bias, high variance)\n\nUpdate with eligibility traces:\ne(s) ← γλe(s) + 1  (for visited state)\nV(s) ← V(s) + αδe(s)  (for all states)\n\nReferences:\n- Sutton (1988): \"Learning to Predict by the Methods of TD\"\n- Tesauro (1994): TD-Gammon", "source": "core\\features\\rl_algorithms.py", "category": "risk"}
{"instruction": "What is the DynaQTrader class and how do I use it?", "input": "", "output": "The DynaQTrader class:\n\nDyna-Q: Model-Based RL for sample-efficient trading.\n\nDyna-Q combines:\n1. Direct RL (learning from real experience)\n2. Model learning (building transition model)\n3. Planning (learning from simulated experience)\n\nFor each real experience:\n- Update Q from real experience\n- Update model\n- Perform k planning steps with simulated experience\n\nReferences:\n- Sutton (1991): \"Dyna, an Integrated Architecture for Learning\"\n- ML4Trading course: Dyna for trading", "source": "core\\features\\rl_algorithms.py", "category": "rl"}
{"instruction": "What is the ThompsonSamplingBandit class and how do I use it?", "input": "", "output": "The ThompsonSamplingBandit class:\n\nThompson Sampling for portfolio allocation.\n\nMulti-armed bandit approach where each \"arm\" is a trading action.\nUses Bayesian posterior sampling to balance exploration/exploitation.\n\nFor each action a, maintain Beta(α_a, β_a) prior:\n- α_a: pseudo-count of successes (profitable trades)\n- β_a: pseudo-count of failures (losing trades)\n\nThompson Sampling Algorithm:\n1. Sample θ_a ~ Beta(α_a, β_a) for each action\n2. Select action with highest θ_a\n3. Update α_a or β_a based on outcome\n\nReferences:\n- Thompson (1933): \"On the Likelihood that One Unknown Probability...\"\n- Agrawal & Goyal (2012): \"Analysis of Thompson Sampling\"\n- Springer (2025): \"Bandit Networks for Portfolio Optimization\"", "source": "core\\features\\rl_algorithms.py", "category": "general"}
{"instruction": "What is the AlmgrenChrisExecutor class and how do I use it?", "input": "", "output": "The AlmgrenChrisExecutor class:\n\nAlmgren-Chriss Optimal Execution Framework.\n\nMinimizes: E[Cost] + λ·Var[Cost]\n\nFor linear temporary impact: g(v) = η·v\nFor linear permanent impact: h(v) = γ·v\n\nOptimal trajectory (TWAP adjusted):\nn_k = (sinh(κ(T-t_k)) / sinh(κT)) · X_0\n\nwhere κ = sqrt(λσ²/η)\n\nReferences:\n- Almgren & Chriss (2001): \"Optimal Execution\"\n- Gatheral & Schied (2011): HJB solution\n- arXiv:1403.2229: RL extension achieving 10.3% improvement", "source": "core\\features\\rl_algorithms.py", "category": "risk"}
{"instruction": "What is the RLFeatureGenerator class and how do I use it?", "input": "", "output": "The RLFeatureGenerator class:\n\nGenerate RL-based trading features.\n\nImplements pure mathematical RL algorithms:\n- Q-Learning signals\n- SARSA signals\n- TD(λ) eligibility-weighted features\n- Dyna-Q model confidence\n- Thompson Sampling posterior signals\n- Almgren-Chriss execution features\n- Kelly-RL integrated sizing\n\nTotal: 35 features", "source": "core\\features\\rl_algorithms.py", "category": "alpha"}
{"instruction": "What is the formula for Generate Rl Features?", "input": "", "output": "Generate RL algorithm-based features.\n\nArgs:\n    df: OHLCV DataFrame\n\nReturns:\n    DataFrame with 35 pure algorithmic RL features", "source": "core\\features\\rl_algorithms.py", "category": "rl"}
{"instruction": "Explain the Generate Rl Features function", "input": "", "output": "Function: generate_rl_features\n\nGenerate RL algorithm-based features.\n\nArgs:\n    df: OHLCV DataFrame\n\nReturns:\n    DataFrame with 35 pure algorithmic RL features", "source": "core\\features\\rl_algorithms.py", "category": "rl"}
{"instruction": "What is the formula for Get Rl Citations?", "input": "", "output": "Get academic citations for all RL algorithms implemented.\n\nReturns:\n    Dictionary mapping algorithm names to list of citation dictionaries.\n    Each citation has: authors, year, title, journal/venue, doi (if available)", "source": "core\\features\\rl_algorithms.py", "category": "rl"}
{"instruction": "Explain the Get Rl Citations function", "input": "", "output": "Function: get_rl_citations\n\nGet academic citations for all RL algorithms implemented.\n\nReturns:\n    Dictionary mapping algorithm names to list of citation dictionaries.\n    Each citation has: authors, year, title, journal/venue, doi (if available)", "source": "core\\features\\rl_algorithms.py", "category": "rl"}
{"instruction": "Explain the Print Citations function", "input": "", "output": "Function: print_citations\n\nPrint all citations in academic format.", "source": "core\\features\\rl_algorithms.py", "category": "general"}
{"instruction": "Explain the Discretize State function", "input": "", "output": "Function: discretize_state\n\nConvert continuous market data to discrete state.", "source": "core\\features\\rl_algorithms.py", "category": "regime"}
{"instruction": "What is the formula for Get Q Value?", "input": "", "output": "Get Q-value for state-action pair.", "source": "core\\features\\rl_algorithms.py", "category": "regime"}
{"instruction": "Explain the Get Q Value function", "input": "", "output": "Function: get_q_value\n\nGet Q-value for state-action pair.", "source": "core\\features\\rl_algorithms.py", "category": "regime"}
{"instruction": "What is the formula for Get Best Action?", "input": "", "output": "Select action with highest Q-value (exploitation).", "source": "core\\features\\rl_algorithms.py", "category": "general"}
{"instruction": "Explain the Get Best Action function", "input": "", "output": "Function: get_best_action\n\nSelect action with highest Q-value (exploitation).", "source": "core\\features\\rl_algorithms.py", "category": "general"}
{"instruction": "What is the formula for Get Action Signal?", "input": "", "output": "Convert best action to trading signal [-1, 1].", "source": "core\\features\\rl_algorithms.py", "category": "alpha"}
{"instruction": "Explain the Get Action Signal function", "input": "", "output": "Function: get_action_signal\n\nConvert best action to trading signal [-1, 1].", "source": "core\\features\\rl_algorithms.py", "category": "alpha"}
{"instruction": "What is the formula for Update?", "input": "", "output": "Q-Learning update.\n\nReturns TD error for analysis.", "source": "core\\features\\rl_algorithms.py", "category": "general"}
{"instruction": "Explain the Update function", "input": "", "output": "Function: update\n\nQ-Learning update.\n\nReturns TD error for analysis.", "source": "core\\features\\rl_algorithms.py", "category": "general"}
{"instruction": "What is the formula for Epsilon Greedy Action?", "input": "", "output": "Select action using epsilon-greedy policy.", "source": "core\\features\\rl_algorithms.py", "category": "general"}
{"instruction": "Explain the Epsilon Greedy Action function", "input": "", "output": "Function: epsilon_greedy_action\n\nSelect action using epsilon-greedy policy.", "source": "core\\features\\rl_algorithms.py", "category": "general"}
{"instruction": "Explain the Get Action Signal function", "input": "", "output": "Function: get_action_signal\n\nConvert policy to trading signal.", "source": "core\\features\\rl_algorithms.py", "category": "alpha"}
{"instruction": "What is the formula for Update?", "input": "", "output": "SARSA update (on-policy).\n\nKey difference from Q-learning: uses actual next action,\nnot maximum over all possible actions.", "source": "core\\features\\rl_algorithms.py", "category": "general"}
{"instruction": "Explain the Update function", "input": "", "output": "Function: update\n\nSARSA update (on-policy).\n\nKey difference from Q-learning: uses actual next action,\nnot maximum over all possible actions.", "source": "core\\features\\rl_algorithms.py", "category": "general"}
{"instruction": "Explain the Update function", "input": "", "output": "Function: update\n\nTD(λ) update with eligibility traces.\n\nReturns (TD error, eligibility of current state).", "source": "core\\features\\rl_algorithms.py", "category": "regime"}
{"instruction": "Explain the Get Value Signal function", "input": "", "output": "Function: get_value_signal\n\nGet normalized value estimate.", "source": "core\\features\\rl_algorithms.py", "category": "alpha"}
{"instruction": "Explain the Update Real function", "input": "", "output": "Function: update_real\n\nUpdate from real experience.", "source": "core\\features\\rl_algorithms.py", "category": "general"}
{"instruction": "Explain the Planning Step function", "input": "", "output": "Function: planning_step\n\nPerform planning steps using model.\n\nReturns number of updates made.", "source": "core\\features\\rl_algorithms.py", "category": "general"}
{"instruction": "What is the formula for Get Action Signal?", "input": "", "output": "Get trading signal from Q-values.", "source": "core\\features\\rl_algorithms.py", "category": "alpha"}
{"instruction": "Explain the Get Action Signal function", "input": "", "output": "Function: get_action_signal\n\nGet trading signal from Q-values.", "source": "core\\features\\rl_algorithms.py", "category": "alpha"}
{"instruction": "Explain the Sample Action function", "input": "", "output": "Function: sample_action\n\nThompson Sampling: sample from posterior and select best.\n\nReturns (selected action, sampled probabilities).", "source": "core\\features\\rl_algorithms.py", "category": "general"}
{"instruction": "What is the formula for Update?", "input": "", "output": "Update posterior based on observed reward.\n\nArgs:\n    action: Action taken\n    reward: Binary reward (1 = success, 0 = failure)\n            or continuous reward (normalized to [0, 1])", "source": "core\\features\\rl_algorithms.py", "category": "general"}
{"instruction": "Explain the Update function", "input": "", "output": "Function: update\n\nUpdate posterior based on observed reward.\n\nArgs:\n    action: Action taken\n    reward: Binary reward (1 = success, 0 = failure)\n            or continuous reward (normalized to [0, 1])", "source": "core\\features\\rl_algorithms.py", "category": "general"}
{"instruction": "What is the formula for Get Action Signal?", "input": "", "output": "Get trading signal based on expected values.\n\nReturns weighted signal in [-1, 1].", "source": "core\\features\\rl_algorithms.py", "category": "alpha"}
{"instruction": "Explain the Get Action Signal function", "input": "", "output": "Function: get_action_signal\n\nGet trading signal based on expected values.\n\nReturns weighted signal in [-1, 1].", "source": "core\\features\\rl_algorithms.py", "category": "alpha"}
{"instruction": "Explain the Get Uncertainty function", "input": "", "output": "Function: get_uncertainty\n\nGet uncertainty (variance) for each action.", "source": "core\\features\\rl_algorithms.py", "category": "risk"}
{"instruction": "Explain the Optimal Trajectory function", "input": "", "output": "Function: optimal_trajectory\n\nCalculate optimal execution trajectory.\n\nArgs:\n    total_shares: Total shares to execute\n    n_periods: Number of trading periods\n    volatility: Price volatility (σ)\n\nReturns:\n    Array of shares to trade in each period", "source": "core\\features\\rl_algorithms.py", "category": "volatility"}
{"instruction": "Explain the Expected Cost function", "input": "", "output": "Function: expected_cost\n\nCalculate expected execution cost and variance.\n\nReturns (expected_cost, variance).", "source": "core\\features\\rl_algorithms.py", "category": "risk"}
{"instruction": "What is the formula for Execution Urgency?", "input": "", "output": "Calculate execution urgency signal.\n\nHigh urgency = execute faster (market moving against us)\nLow urgency = execute slower (favorable conditions)", "source": "core\\features\\rl_algorithms.py", "category": "alpha"}
{"instruction": "Explain the Execution Urgency function", "input": "", "output": "Function: execution_urgency\n\nCalculate execution urgency signal.\n\nHigh urgency = execute faster (market moving against us)\nLow urgency = execute slower (favorable conditions)", "source": "core\\features\\rl_algorithms.py", "category": "alpha"}
{"instruction": "What is the formula for Generate All?", "input": "", "output": "Generate all RL-based features.\n\nArgs:\n    df: DataFrame with OHLCV data\n\nReturns:\n    DataFrame with 35 RL features", "source": "core\\features\\rl_algorithms.py", "category": "rl"}
{"instruction": "Explain the Generate All function", "input": "", "output": "Function: generate_all\n\nGenerate all RL-based features.\n\nArgs:\n    df: DataFrame with OHLCV data\n\nReturns:\n    DataFrame with 35 RL features", "source": "core\\features\\rl_algorithms.py", "category": "rl"}
{"instruction": "Explain the Get Feature Names function", "input": "", "output": "Function: get_feature_names\n\nGet list of all feature names.", "source": "core\\features\\rl_algorithms.py", "category": "general"}
{"instruction": "Explain the purpose of Reinforcement Learning Research Module for Forex Trading", "input": "", "output": "Reinforcement Learning Research Module for Forex Trading\n\nUSA Quant-Level Peer-Reviewed RL Methods with Full Academic Citations.\n\n══════════════════════════════════════════════════════════════════════════════\nACADEMIC CITATIONS (22 Papers):\n══════════════════════════════════════════════════════════════════════════════\n\nFOUNDATIONAL RL ALGORITHMS:\n1. Schulman, J., Wolski, F., Dhariwal, P., Radford, A., & Klimov, O. (2017).\n   \"Proximal Policy Optimization Algorithms.\" arXiv:1707.06347. OpenAI.\n\n2. Haarnoja, T., Zhou, A., Abbeel, P., & Levine, S. (2018).\n   \"Soft Actor-Critic: Off-Policy Maximum Entropy Deep RL with a Stochastic Actor.\"\n   ICML 2018. UC Berkeley.\n\n3. Lillicrap, T. P., Hunt, J. J., Pritzel, A., et al. (2015).\n   \"Continuous Control with Deep Reinforcement Learning.\" arXiv:1509.02971. DeepMind.\n\n4. Fujimoto, S., Hoof, H., & Meger, D. (2018).\n   \"Addressing Function Approximation Error in Actor-Critic Methods.\" ICML 2018. McGill.\n\nREWARD SHAPING:\n5. Moody, J., & Saffell, M. (2001).\n   \"Learning to Trade via Direct Reinforcement.\"\n   IEEE Transactions on Neural Networks, 12(4), 875-889. [1,400+ citations]\n\n6. Moody, J., Wu, L., Liao, Y., & Saffell, M. (1998).\n   \"Performance Functions and Reinforcement Learning for Trading Systems.\"\n   Journal of Forecasting, 17(5-6), 441-470.\n\nRISK-SENSITIVE RL:\n7. Tamar, A., Glassner, Y., & Mannor, S. (2015).\n   \"Optimizing the CVaR via Sampling.\" AAAI 2015.\n\n8. Chow, Y., Ghavamzadeh, M., Janson, L., & Pavone, M. (2017).\n   \"Risk-Constrained Reinforcement Learning with Percentile Risk Criteria.\"\n   Journal of Machine Learning Research, 18(1), 6070-6120.\n\n9. Greenberg, I., Chow, Y., & Ghavamzadeh, M. (2024).\n   \"A Reductions Approach to Risk-Sensitive RL with Optimized Certainty Equivalents.\"\n   arXiv:2403.06323.\n\n10. Lim, S. H., & Malik, A. (2024).\n    \"Risk-Seeking RL via Multi-Timescale EVaR Optimization.\" OpenReview.\n\nPORTFOLIO OPTIMIZATION:\n11. Zhang, Z., Zohren, S., & Roberts, S. (2020).\n    \"Deep Reinforcement Learning for Trading.\" Journal of Financial Data Science.\n\n12. Jiang, Z., Xu, D., & Liang, J. (2017).\n    \"A Deep Reinforcement Learning Framework for the Financial Portfolio Management.\"\n    arXiv:1706.10059. [800+ citations]\n\n13. Yang, H., Liu, X. Y., Zhong, S., & Walid, A. (2020).\n    \"Deep Reinforcement Learning for Automated Stock Trading.\"\n    ACM ICAIF 2020. [FinRL Framework]\n\n14. International Journal of Computational Intelligence Systems (2025).\n    \"Risk-Adjusted Deep Reinforcement Learning for Portfolio Optimization.\"\n    Springer. DOI: 10.1007/s44196-025-00875-8\n\nDISTRIBUTIONAL RL:\n15. Dabney, W., Rowland, M., Bellemare, M. G., & Munos, R. (2018).\n    \"Distributional Reinforcement Learning with Quantile Regression.\" AAAI 2018.\n\n16. Dabney, W., Ostrovski, G., Silver, D., & Munos, R. (2018).\n    \"Implicit Quantile Networks for Distributional RL.\" ICML 2018. DeepMind.\n\n17. Zhou, F., et al. (2020).\n    \"Non-Crossing Quantile Regression for Distributional RL.\" NeurIPS 2020.\n\nOPTIMAL EXECUTION:\n18. Almgren, R., & Chriss, N. (2001).\n    \"Optimal Execution of Portfolio Transactions.\"\n    Journal of Risk, 3(2), 5-39. [2,500+ citations]\n\n19. Nevmyvaka, Y., Feng, Y., & Kearns, M. (2006).\n    \"Reinforcement Learning for Optimized Trade Execution.\" ICML 2006.\n\nMARKET MAKING:\n20. Avellaneda, M., & Stoikov, S. (2008).\n    \"High-frequency Trading in a Limit Order Book.\"\n    Quantitative Finance, 8(3), 217-224. [1,800+ citations]\n\n21. Spooner, T., Fearnley, J., Savani, R., & Koutsoupias, E. (2018).\n    \"Market Making via Reinforcement Learning.\" AAMAS 2018.\n\nMETA-RL:\n22. Finn, C., Abbeel, P., & Levine, S. (2017).\n    \"Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks.\"\n    ICML 2017. [10,000+ citations]\n\n══════════════════════════════════════════════════════════════════════════════", "source": "core\\features\\rl_research.py", "category": "volatility"}
{"instruction": "What is the DifferentialSharpeRatio class and how do I use it?", "input": "", "output": "The DifferentialSharpeRatio class:\n\nDifferential Sharpe Ratio for Online RL Trading.\n\nReference:\n    Moody, J., & Saffell, M. (2001).\n    \"Learning to Trade via Direct Reinforcement.\"\n    IEEE Transactions on Neural Networks, 12(4), 875-889.\n\nThe DSR provides an incremental update to the Sharpe ratio that can be\nused as a reward signal in reinforcement learning. Unlike batch Sharpe,\nit can be computed online as new returns arrive.\n\nMathematical Formulation:\n    A_t = A_{t-1} + η(R_t - A_{t-1})     [EMA of returns]\n    B_t = B_{t-1} + η(R_t² - B_{t-1})   [EMA of squared returns]\n\n    D_t = (B_{t-1} · ΔA_t - 0.5 · A_{t-1} · ΔB_t) / (B_{t-1} - A_{t-1}²)^{3/2}\n\nWhere:\n    η = adaptation rate (typically 0.01-0.1)\n    R_t = return at time t\n    D_t = differential Sharpe ratio at time t", "source": "core\\features\\rl_research.py", "category": "alpha"}
{"instruction": "What is the DifferentialDownsideDeviation class and how do I use it?", "input": "", "output": "The DifferentialDownsideDeviation class:\n\nDifferential Downside Deviation for Sortino-like RL rewards.\n\nReference:\n    Moody, J., Wu, L., Liao, Y., & Saffell, M. (1998).\n    \"Performance Functions and Reinforcement Learning for Trading Systems.\"\n    Journal of Forecasting, 17(5-6), 441-470.\n\nExtension of DSR that only penalizes downside volatility,\naligned with Sortino ratio philosophy.", "source": "core\\features\\rl_research.py", "category": "volatility"}
{"instruction": "What is the MaxDrawdownPenalty class and how do I use it?", "input": "", "output": "The MaxDrawdownPenalty class:\n\nMaximum Drawdown Penalty for RL Reward Shaping.\n\nReference:\n    International Journal of Computational Intelligence Systems (2025).\n    \"Risk-Adjusted Deep Reinforcement Learning for Portfolio Optimization.\"\n\nPenalizes the agent when portfolio value drops from peak,\nencouraging drawdown-aware trading strategies.", "source": "core\\features\\rl_research.py", "category": "risk"}
{"instruction": "What is the RewardConfig class and how do I use it?", "input": "", "output": "The RewardConfig class:\n\nConfiguration for combined reward function.", "source": "core\\features\\rl_research.py", "category": "general"}
{"instruction": "What is the CombinedRewardFunction class and how do I use it?", "input": "", "output": "The CombinedRewardFunction class:\n\nCombined Reward Function for Trading RL.\n\nCombines multiple reward signals:\n- Differential Sharpe Ratio (Moody & Saffell 2001)\n- Differential Downside Deviation (Sortino-like)\n- Maximum Drawdown Penalty\n\nReference:\n    International Journal of Computational Intelligence Systems (2025).\n    \"Risk-Adjusted Deep Reinforcement Learning for Portfolio Optimization:\n    A Multi-reward Approach.\"", "source": "core\\features\\rl_research.py", "category": "alpha"}
{"instruction": "What is the ValueAtRisk class and how do I use it?", "input": "", "output": "The ValueAtRisk class:\n\nValue at Risk (VaR) Calculator.\n\nReference:\n    Jorion, P. (2006). \"Value at Risk: The New Benchmark for Managing\n    Financial Risk.\" McGraw-Hill.\n\nVaR_α = inf{x : P(X ≤ x) ≥ α}\n\nInterpretation: The maximum loss at confidence level (1-α)", "source": "core\\features\\rl_research.py", "category": "risk"}
{"instruction": "What is the ConditionalValueAtRisk class and how do I use it?", "input": "", "output": "The ConditionalValueAtRisk class:\n\nConditional Value at Risk (CVaR) / Expected Shortfall.\n\nReferences:\n    1. Rockafellar, R. T., & Uryasev, S. (2000).\n       \"Optimization of Conditional Value-at-Risk.\"\n       Journal of Risk, 2(3), 21-42.\n\n    2. Tamar, A., Glassner, Y., & Mannor, S. (2015).\n       \"Optimizing the CVaR via Sampling.\" AAAI 2015.\n\nCVaR_α = E[X | X ≤ VaR_α]\n\nInterpretation: Expected loss given we're in worst α% of scenarios.\nCVaR is coherent (satisfies subadditivity) unlike VaR.", "source": "core\\features\\rl_research.py", "category": "risk"}
{"instruction": "What is the EntropicValueAtRisk class and how do I use it?", "input": "", "output": "The EntropicValueAtRisk class:\n\nEntropic Value at Risk (EVaR).\n\nReference:\n    Lim, S. H., & Malik, A. (2024).\n    \"Risk-Seeking RL via Multi-Timescale EVaR Optimization.\"\n    OpenReview.\n\nEVaR is tighter than CVaR and has better mathematical properties.\n\nEVaR_α = inf_{t>0} { (1/t) · log(E[exp(t·X)]) + (1/t)·log(1/α) }\n\nEVaR ≥ CVaR ≥ VaR (EVaR is most conservative)", "source": "core\\features\\rl_research.py", "category": "risk"}
{"instruction": "What is the CVaRConstrainedKelly class and how do I use it?", "input": "", "output": "The CVaRConstrainedKelly class:\n\nKelly Criterion with CVaR Constraint.\n\nReferences:\n    1. Kelly, J. L. (1956). \"A New Interpretation of Information Rate.\"\n       Bell System Technical Journal.\n\n    2. Chow, Y., Ghavamzadeh, M., Janson, L., & Pavone, M. (2017).\n       \"Risk-Constrained RL with Percentile Risk Criteria.\"\n       JMLR, 18(1), 6070-6120.\n\nCombines optimal growth (Kelly) with tail risk constraint (CVaR).", "source": "core\\features\\rl_research.py", "category": "risk"}
{"instruction": "What is the RiskMetricsResult class and how do I use it?", "input": "", "output": "The RiskMetricsResult class:\n\nResults from risk metrics calculation.", "source": "core\\features\\rl_research.py", "category": "risk"}
{"instruction": "What is the formula for Compute Risk Metrics?", "input": "", "output": "Compute comprehensive risk metrics.\n\nArgs:\n    returns: Array of returns\n    risk_free: Risk-free rate for Sortino\n\nReturns:\n    RiskMetricsResult with all metrics", "source": "core\\features\\rl_research.py", "category": "risk"}
{"instruction": "Explain the Compute Risk Metrics function", "input": "", "output": "Function: compute_risk_metrics\n\nCompute comprehensive risk metrics.\n\nArgs:\n    returns: Array of returns\n    risk_free: Risk-free rate for Sortino\n\nReturns:\n    RiskMetricsResult with all metrics", "source": "core\\features\\rl_research.py", "category": "risk"}
{"instruction": "What is the ExecutionConfig class and how do I use it?", "input": "", "output": "The ExecutionConfig class:\n\nConfiguration for optimal execution.", "source": "core\\features\\rl_research.py", "category": "execution"}
{"instruction": "What is the AlmgrenChriss class and how do I use it?", "input": "", "output": "The AlmgrenChriss class:\n\nAlmgren-Chriss Optimal Execution Model.\n\nReference:\n    Almgren, R., & Chriss, N. (2001).\n    \"Optimal Execution of Portfolio Transactions.\"\n    Journal of Risk, 3(2), 5-39. [2,500+ citations]\n\nFinds optimal trading trajectory that minimizes:\nE[Cost] + λ · Var[Cost]\n\nWhere cost includes:\n- Permanent impact: γ · σ² · X² · T\n- Temporary impact: η · X² / T\n- Risk penalty: λ · σ² · ∫ x(t)² dt", "source": "core\\features\\rl_research.py", "category": "risk"}
{"instruction": "What is the RLOptimalExecution class and how do I use it?", "input": "", "output": "The RLOptimalExecution class:\n\nRL-Enhanced Optimal Execution.\n\nReference:\n    Nevmyvaka, Y., Feng, Y., & Kearns, M. (2006).\n    \"Reinforcement Learning for Optimized Trade Execution.\"\n    ICML 2006.\n\nCombines Almgren-Chriss baseline with RL adaptations for:\n- Time-varying volatility\n- Order book state\n- Intraday patterns", "source": "core\\features\\rl_research.py", "category": "volatility"}
{"instruction": "What is the MarketMakingConfig class and how do I use it?", "input": "", "output": "The MarketMakingConfig class:\n\nConfiguration for market making.", "source": "core\\features\\rl_research.py", "category": "general"}
{"instruction": "What is the AvellanedaStoikovRL class and how do I use it?", "input": "", "output": "The AvellanedaStoikovRL class:\n\nAvellaneda-Stoikov Market Making with RL Enhancement.\n\nReferences:\n    1. Avellaneda, M., & Stoikov, S. (2008).\n       \"High-frequency Trading in a Limit Order Book.\"\n       Quantitative Finance, 8(3), 217-224. [1,800+ citations]\n\n    2. Spooner, T., Fearnley, J., Savani, R., & Koutsoupias, E. (2018).\n       \"Market Making via Reinforcement Learning.\" AAMAS 2018.\n\nComputes optimal bid/ask quotes given inventory risk.\n\nKey formulas:\n    Reservation price: r = s - q · γ · σ² · (T - t)\n    Optimal spread: δ = γ · σ² · (T - t) + (2/γ) · log(1 + γ/κ)", "source": "core\\features\\rl_research.py", "category": "risk"}
{"instruction": "What is the QuantileDistribution class and how do I use it?", "input": "", "output": "The QuantileDistribution class:\n\nQuantile Distribution for Distributional RL.\n\nReference:\n    Dabney, W., Rowland, M., Bellemare, M. G., & Munos, R. (2018).\n    \"Distributional Reinforcement Learning with Quantile Regression.\"\n    AAAI 2018.\n\nInstead of learning E[R], learn the full distribution of returns\nvia quantile regression. Enables risk-sensitive decision making.", "source": "core\\features\\rl_research.py", "category": "risk"}
{"instruction": "What is the QuantileHuberLoss class and how do I use it?", "input": "", "output": "The QuantileHuberLoss class:\n\nQuantile Huber Loss for QR-DQN training.\n\nReference:\n    Dabney et al. (2018). \"Distributional RL with Quantile Regression.\"\n\nCombines quantile regression loss with Huber loss for robustness.\n\nρ_τ^κ(u) = |τ - 𝟙(u < 0)| · L_κ(u) / κ\n\nWhere L_κ is Huber loss with threshold κ.", "source": "core\\features\\rl_research.py", "category": "rl"}
{"instruction": "What is the MAMLTrader class and how do I use it?", "input": "", "output": "The MAMLTrader class:\n\nModel-Agnostic Meta-Learning for Trading.\n\nReference:\n    Finn, C., Abbeel, P., & Levine, S. (2017).\n    \"Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks.\"\n    ICML 2017. [10,000+ citations]\n\nMAML learns initialization that enables fast adaptation to new market regimes\nwith only a few gradient steps.\n\nθ* = argmin_θ Σ_i L_i(θ - α∇L_i(θ))\n\nInner loop: Adapt to regime with few samples\nOuter loop: Learn good initialization across regimes", "source": "core\\features\\rl_research.py", "category": "regime"}
{"instruction": "What is the RegimeAwareRL class and how do I use it?", "input": "", "output": "The RegimeAwareRL class:\n\nRegime-Aware RL that combines HMM regime detection with policy switching.\n\nReferences:\n    1. Hamilton, J. D. (1989). \"A New Approach to the Economic Analysis\n       of Nonstationary Time Series and the Business Cycle.\"\n       Econometrica, 57(2), 357-384.\n\n    2. Context-based Meta-RL literature (2020-2024).\n\nUses latent context to identify market regime and selects appropriate policy.", "source": "core\\features\\rl_research.py", "category": "rl"}
{"instruction": "What is the PositionSizerConfig class and how do I use it?", "input": "", "output": "The PositionSizerConfig class:\n\nConfiguration for RL position sizer.", "source": "core\\features\\rl_research.py", "category": "rl"}
{"instruction": "What is the RLPositionSizer class and how do I use it?", "input": "", "output": "The RLPositionSizer class:\n\nRL-Based Position Sizing.\n\nReferences:\n    1. Jiang, Z., Xu, D., & Liang, J. (2017).\n       \"A Deep Reinforcement Learning Framework for Portfolio Management.\"\n\n    2. Yang, H., Liu, X. Y., Zhong, S., & Walid, A. (2020).\n       \"Deep Reinforcement Learning for Automated Stock Trading.\"\n       ACM ICAIF 2020.\n\nUses RL to optimize position sizing based on:\n- Prediction confidence\n- Current regime\n- Risk constraints (CVaR, drawdown)\n- Recent performance", "source": "core\\features\\rl_research.py", "category": "risk"}
{"instruction": "What is the RLFeatureGenerator class and how do I use it?", "input": "", "output": "The RLFeatureGenerator class:\n\nGenerate features specifically designed for RL trading agents.\n\nCombines:\n- Risk metrics (VaR, CVaR, drawdown)\n- Reward statistics (DSR, rolling Sharpe)\n- Execution metrics (slippage, fill rate)\n- Market state (regime, volatility)", "source": "core\\features\\rl_research.py", "category": "volatility"}
{"instruction": "What is the formula for Create Reward Function?", "input": "", "output": "Factory function to create reward functions.\n\nArgs:\n    reward_type: One of 'dsr', 'sortino', 'drawdown', 'combined'\n    **kwargs: Arguments passed to reward function\n\nReturns:\n    Reward function instance", "source": "core\\features\\rl_research.py", "category": "alpha"}
{"instruction": "Explain the Create Reward Function function", "input": "", "output": "Function: create_reward_function\n\nFactory function to create reward functions.\n\nArgs:\n    reward_type: One of 'dsr', 'sortino', 'drawdown', 'combined'\n    **kwargs: Arguments passed to reward function\n\nReturns:\n    Reward function instance", "source": "core\\features\\rl_research.py", "category": "alpha"}
{"instruction": "What is the formula for Create Execution Model?", "input": "", "output": "Factory function to create execution models.\n\nArgs:\n    model_type: One of 'almgren_chriss', 'rl_execution'\n    **kwargs: Arguments passed to model\n\nReturns:\n    Execution model instance", "source": "core\\features\\rl_research.py", "category": "alpha"}
{"instruction": "Explain the Create Execution Model function", "input": "", "output": "Function: create_execution_model\n\nFactory function to create execution models.\n\nArgs:\n    model_type: One of 'almgren_chriss', 'rl_execution'\n    **kwargs: Arguments passed to model\n\nReturns:\n    Execution model instance", "source": "core\\features\\rl_research.py", "category": "alpha"}
{"instruction": "What is Almgren-Chriss in quantitative trading?", "input": "", "output": "Almgren-Chriss (optimal execution model minimizing market impact).\n\nImplementation details:\nFactory function to create execution models.\n\nArgs:\n    model_type: One of 'almgren_chriss', 'rl_execution'\n    **kwargs: Arguments passed to model\n\nReturns:\n    Execution model instance", "source": "core\\features\\rl_research.py", "category": "alpha"}
{"instruction": "What is the formula for Create Market Maker?", "input": "", "output": "Factory function to create market maker.\n\nArgs:\n    mm_type: Currently only 'avellaneda_stoikov'\n    **kwargs: Arguments passed to model\n\nReturns:\n    Market maker instance", "source": "core\\features\\rl_research.py", "category": "alpha"}
{"instruction": "Explain the Create Market Maker function", "input": "", "output": "Function: create_market_maker\n\nFactory function to create market maker.\n\nArgs:\n    mm_type: Currently only 'avellaneda_stoikov'\n    **kwargs: Arguments passed to model\n\nReturns:\n    Market maker instance", "source": "core\\features\\rl_research.py", "category": "alpha"}
{"instruction": "Explain the Generate Rl Features function", "input": "", "output": "Function: generate_rl_features\n\nConvenience function to generate RL features.\n\nArgs:\n    returns: Return series\n    prices: Price series\n    volumes: Volume series (optional)\n    lookback: Lookback period\n\nReturns:\n    Dictionary of RL features", "source": "core\\features\\rl_research.py", "category": "volatility"}
{"instruction": "Explain the Reset function", "input": "", "output": "Function: reset\n\nReset internal state for new episode.", "source": "core\\features\\rl_research.py", "category": "regime"}
{"instruction": "Explain the Update function", "input": "", "output": "Function: update\n\nCompute differential Sharpe ratio for new return.\n\nArgs:\n    return_t: Return at current timestep (can be log return or simple)\n\nReturns:\n    Differential Sharpe ratio (reward signal)", "source": "core\\features\\rl_research.py", "category": "alpha"}
{"instruction": "What is Sharpe Ratio in quantitative trading?", "input": "", "output": "Sharpe Ratio (risk-adjusted return measure).\n\nImplementation details:\nCompute differential Sharpe ratio for new return.\n\nArgs:\n    return_t: Return at current timestep (can be log return or simple)\n\nReturns:\n    Differential Sharpe ratio (reward signal)", "source": "core\\features\\rl_research.py", "category": "alpha"}
{"instruction": "Explain the Compute Batch function", "input": "", "output": "Function: compute_batch\n\nCompute DSR for a batch of returns.\n\nArgs:\n    returns: Array of returns\n\nReturns:\n    Array of differential Sharpe ratios", "source": "core\\features\\rl_research.py", "category": "risk"}
{"instruction": "What is Sharpe Ratio in quantitative trading?", "input": "", "output": "Sharpe Ratio (risk-adjusted return measure).\n\nImplementation details:\nCompute DSR for a batch of returns.\n\nArgs:\n    returns: Array of returns\n\nReturns:\n    Array of differential Sharpe ratios", "source": "core\\features\\rl_research.py", "category": "risk"}
{"instruction": "Explain the Compute Static function", "input": "", "output": "Function: compute_static\n\nStatic method to compute final DSR value.\n\nArgs:\n    returns: Array of returns\n    eta: Adaptation rate\n\nReturns:\n    Final cumulative differential Sharpe ratio", "source": "core\\features\\rl_research.py", "category": "risk"}
{"instruction": "What is Sharpe Ratio in quantitative trading?", "input": "", "output": "Sharpe Ratio (risk-adjusted return measure).\n\nImplementation details:\nStatic method to compute final DSR value.\n\nArgs:\n    returns: Array of returns\n    eta: Adaptation rate\n\nReturns:\n    Final cumulative differential Sharpe ratio", "source": "core\\features\\rl_research.py", "category": "risk"}
{"instruction": "Explain the Update function", "input": "", "output": "Function: update\n\nCompute differential downside deviation reward.", "source": "core\\features\\rl_research.py", "category": "general"}
{"instruction": "What is the formula for Update?", "input": "", "output": "Compute drawdown-penalized reward.\n\nArgs:\n    return_t: Return at current timestep\n\nReturns:\n    Return minus drawdown penalty", "source": "core\\features\\rl_research.py", "category": "risk"}
{"instruction": "Explain the Update function", "input": "", "output": "Function: update\n\nCompute drawdown-penalized reward.\n\nArgs:\n    return_t: Return at current timestep\n\nReturns:\n    Return minus drawdown penalty", "source": "core\\features\\rl_research.py", "category": "risk"}
{"instruction": "Explain the Current Drawdown function", "input": "", "output": "Function: current_drawdown\n\nCurrent drawdown from peak.", "source": "core\\features\\rl_research.py", "category": "risk"}
{"instruction": "Explain the Compute Reward function", "input": "", "output": "Function: compute_reward\n\nCompute combined reward from multiple signals.\n\nArgs:\n    return_t: Return at current timestep\n\nReturns:\n    Combined reward signal", "source": "core\\features\\rl_research.py", "category": "alpha"}
{"instruction": "What is the formula for Historical?", "input": "", "output": "Historical VaR using empirical quantile.\n\nArgs:\n    returns: Array of returns (can be negative for losses)\n    alpha: Significance level (0.05 = 95% confidence)\n\nReturns:\n    VaR value (will be negative for losses)", "source": "core\\features\\rl_research.py", "category": "alpha"}
{"instruction": "Explain the Historical function", "input": "", "output": "Function: historical\n\nHistorical VaR using empirical quantile.\n\nArgs:\n    returns: Array of returns (can be negative for losses)\n    alpha: Significance level (0.05 = 95% confidence)\n\nReturns:\n    VaR value (will be negative for losses)", "source": "core\\features\\rl_research.py", "category": "alpha"}
{"instruction": "Explain the Parametric function", "input": "", "output": "Function: parametric\n\nParametric VaR assuming normal distribution.\n\nArgs:\n    mean: Expected return\n    std: Standard deviation of returns\n    alpha: Significance level\n\nReturns:\n    VaR value", "source": "core\\features\\rl_research.py", "category": "alpha"}
{"instruction": "What is the formula for Cornish Fisher?", "input": "", "output": "Cornish-Fisher VaR with skewness and kurtosis adjustment.\n\nMore accurate for non-normal return distributions (fat tails).\n\nArgs:\n    returns: Array of returns\n    alpha: Significance level\n\nReturns:\n    Adjusted VaR value", "source": "core\\features\\rl_research.py", "category": "alpha"}
{"instruction": "Explain the Cornish Fisher function", "input": "", "output": "Function: cornish_fisher\n\nCornish-Fisher VaR with skewness and kurtosis adjustment.\n\nMore accurate for non-normal return distributions (fat tails).\n\nArgs:\n    returns: Array of returns\n    alpha: Significance level\n\nReturns:\n    Adjusted VaR value", "source": "core\\features\\rl_research.py", "category": "alpha"}
{"instruction": "What is the formula for Historical?", "input": "", "output": "Historical CVaR using empirical distribution.\n\nArgs:\n    returns: Array of returns\n    alpha: Significance level (0.05 = worst 5%)\n\nReturns:\n    CVaR value (expected loss in tail)", "source": "core\\features\\rl_research.py", "category": "alpha"}
{"instruction": "Explain the Historical function", "input": "", "output": "Function: historical\n\nHistorical CVaR using empirical distribution.\n\nArgs:\n    returns: Array of returns\n    alpha: Significance level (0.05 = worst 5%)\n\nReturns:\n    CVaR value (expected loss in tail)", "source": "core\\features\\rl_research.py", "category": "alpha"}
{"instruction": "Explain the Parametric function", "input": "", "output": "Function: parametric\n\nParametric CVaR assuming normal distribution.\n\nArgs:\n    mean: Expected return\n    std: Standard deviation\n    alpha: Significance level\n\nReturns:\n    CVaR value", "source": "core\\features\\rl_research.py", "category": "alpha"}
{"instruction": "Explain the From Quantiles function", "input": "", "output": "Function: from_quantiles\n\nCompute CVaR from quantile distribution (for Distributional RL).\n\nArgs:\n    quantiles: Quantile values from distributional RL\n    probs: Probability weights for each quantile\n    alpha: Significance level\n\nReturns:\n    CVaR value", "source": "core\\features\\rl_research.py", "category": "alpha"}
{"instruction": "Explain the Compute function", "input": "", "output": "Function: compute\n\nCompute EVaR via optimization.\n\nArgs:\n    returns: Array of returns (losses should be negative)\n    alpha: Significance level\n    t_range: Range for optimization parameter t\n\nReturns:\n    EVaR value", "source": "core\\features\\rl_research.py", "category": "alpha"}
{"instruction": "What is the formula for Optimal Position?", "input": "", "output": "Compute CVaR-constrained Kelly position.\n\nArgs:\n    win_prob: Probability of winning trade\n    win_loss_ratio: Average win / Average loss\n    return_std: Standard deviation of returns\n\nReturns:\n    Optimal position size (fraction of capital)", "source": "core\\features\\rl_research.py", "category": "risk"}
{"instruction": "Explain the Optimal Position function", "input": "", "output": "Function: optimal_position\n\nCompute CVaR-constrained Kelly position.\n\nArgs:\n    win_prob: Probability of winning trade\n    win_loss_ratio: Average win / Average loss\n    return_std: Standard deviation of returns\n\nReturns:\n    Optimal position size (fraction of capital)", "source": "core\\features\\rl_research.py", "category": "risk"}
{"instruction": "What is Kelly Criterion in quantitative trading?", "input": "", "output": "Kelly Criterion (position sizing formula that maximizes long-term growth).\n\nImplementation details:\nCompute CVaR-constrained Kelly position.\n\nArgs:\n    win_prob: Probability of winning trade\n    win_loss_ratio: Average win / Average loss\n    return_std: Standard deviation of returns\n\nReturns:\n    Optimal position size (fraction of capital)", "source": "core\\features\\rl_research.py", "category": "risk"}
{"instruction": "Explain the Optimal Trajectory function", "input": "", "output": "Function: optimal_trajectory\n\nCompute optimal execution trajectory.\n\nArgs:\n    shares: Total shares to execute\n    time_horizon: Time to complete execution (in trading days)\n    volatility: Asset volatility (daily)\n    n_steps: Number of time steps\n\nReturns:\n    Array of remaining shares at each time step", "source": "core\\features\\rl_research.py", "category": "volatility"}
{"instruction": "Explain the Expected Cost function", "input": "", "output": "Function: expected_cost\n\nCompute expected execution cost.\n\nArgs:\n    shares: Total shares to execute\n    time_horizon: Time to complete execution\n    volatility: Asset volatility\n\nReturns:\n    Tuple of (total_cost, permanent_cost, temporary_cost)", "source": "core\\features\\rl_research.py", "category": "volatility"}
{"instruction": "What is the formula for Optimal Time Horizon?", "input": "", "output": "Compute optimal execution time given urgency parameter.\n\nArgs:\n    shares: Total shares to execute\n    volatility: Asset volatility\n    urgency: Urgency multiplier (higher = faster execution)\n\nReturns:\n    Optimal time horizon", "source": "core\\features\\rl_research.py", "category": "volatility"}
{"instruction": "Explain the Optimal Time Horizon function", "input": "", "output": "Function: optimal_time_horizon\n\nCompute optimal execution time given urgency parameter.\n\nArgs:\n    shares: Total shares to execute\n    volatility: Asset volatility\n    urgency: Urgency multiplier (higher = faster execution)\n\nReturns:\n    Optimal time horizon", "source": "core\\features\\rl_research.py", "category": "volatility"}
{"instruction": "What is the formula for Compute State?", "input": "", "output": "Compute state vector for RL agent.\n\nArgs:\n    remaining_shares: Shares left to execute\n    time_remaining: Time left (fraction of total)\n    volatility: Current volatility estimate\n    spread: Current bid-ask spread\n    order_imbalance: Current order book imbalance\n\nReturns:\n    State vector for RL", "source": "core\\features\\rl_research.py", "category": "volatility"}
{"instruction": "Explain the Compute State function", "input": "", "output": "Function: compute_state\n\nCompute state vector for RL agent.\n\nArgs:\n    remaining_shares: Shares left to execute\n    time_remaining: Time left (fraction of total)\n    volatility: Current volatility estimate\n    spread: Current bid-ask spread\n    order_imbalance: Current order book imbalance\n\nReturns:\n    State vector for RL", "source": "core\\features\\rl_research.py", "category": "volatility"}
{"instruction": "Explain the Compute Reward function", "input": "", "output": "Function: compute_reward\n\nCompute execution reward (negative cost).\n\nArgs:\n    execution_price: Price at which trade executed\n    mid_price: Mid price at execution time\n    shares_executed: Number of shares executed this step\n    time_elapsed: Time elapsed this step\n\nReturns:\n    Reward (negative of implementation shortfall)", "source": "core\\features\\rl_research.py", "category": "execution"}
{"instruction": "Explain the Reset function", "input": "", "output": "Function: reset\n\nReset market maker state.", "source": "core\\features\\rl_research.py", "category": "regime"}
{"instruction": "What is the formula for Reservation Price?", "input": "", "output": "Compute reservation price (Avellaneda-Stoikov Eq. 8).\n\nThe reservation price is where the market maker is indifferent\nto holding inventory. It adjusts based on current inventory.\n\nArgs:\n    mid_price: Current mid price\n    time_remaining: Time until end of session (fraction)\n\nReturns:\n    Reservation price", "source": "core\\features\\rl_research.py", "category": "general"}
{"instruction": "Explain the Reservation Price function", "input": "", "output": "Function: reservation_price\n\nCompute reservation price (Avellaneda-Stoikov Eq. 8).\n\nThe reservation price is where the market maker is indifferent\nto holding inventory. It adjusts based on current inventory.\n\nArgs:\n    mid_price: Current mid price\n    time_remaining: Time until end of session (fraction)\n\nReturns:\n    Reservation price", "source": "core\\features\\rl_research.py", "category": "general"}
{"instruction": "What is the formula for Optimal Spread?", "input": "", "output": "Compute optimal bid-ask spread (Avellaneda-Stoikov Eq. 10).\n\nArgs:\n    time_remaining: Time until end of session\n\nReturns:\n    Optimal spread (full, not half)", "source": "core\\features\\rl_research.py", "category": "microstructure"}
{"instruction": "Explain the Optimal Spread function", "input": "", "output": "Function: optimal_spread\n\nCompute optimal bid-ask spread (Avellaneda-Stoikov Eq. 10).\n\nArgs:\n    time_remaining: Time until end of session\n\nReturns:\n    Optimal spread (full, not half)", "source": "core\\features\\rl_research.py", "category": "microstructure"}
{"instruction": "Explain the Optimal Quotes function", "input": "", "output": "Function: optimal_quotes\n\nCompute optimal bid and ask prices.\n\nArgs:\n    mid_price: Current mid price\n    time_remaining: Time until end of session\n\nReturns:\n    Tuple of (bid_price, ask_price)", "source": "core\\features\\rl_research.py", "category": "microstructure"}
{"instruction": "Explain the Compute State function", "input": "", "output": "Function: compute_state\n\nCompute state for RL agent.\n\nArgs:\n    mid_price: Current mid price\n    time_remaining: Time until session end\n    volatility: Current volatility estimate\n    order_flow: Recent order flow imbalance\n\nReturns:\n    State vector", "source": "core\\features\\rl_research.py", "category": "volatility"}
{"instruction": "Explain the Step function", "input": "", "output": "Function: step\n\nProcess one time step.\n\nArgs:\n    mid_price: Current mid price\n    time_remaining: Time remaining\n    bid_filled: Whether bid was hit\n    ask_filled: Whether ask was lifted\n\nReturns:\n    Reward for this step", "source": "core\\features\\rl_research.py", "category": "microstructure"}
{"instruction": "What is the formula for Terminal Value?", "input": "", "output": "Compute terminal value including inventory liquidation.\n\nArgs:\n    final_price: Price at session end\n\nReturns:\n    Total PnL including mark-to-market", "source": "core\\features\\rl_research.py", "category": "general"}
{"instruction": "Explain the Terminal Value function", "input": "", "output": "Function: terminal_value\n\nCompute terminal value including inventory liquidation.\n\nArgs:\n    final_price: Price at session end\n\nReturns:\n    Total PnL including mark-to-market", "source": "core\\features\\rl_research.py", "category": "general"}
{"instruction": "Explain the Set Quantiles function", "input": "", "output": "Function: set_quantiles\n\nSet quantile values from model output.", "source": "core\\features\\rl_research.py", "category": "general"}
{"instruction": "Explain the Mean function", "input": "", "output": "Function: mean\n\nExpected value (mean of distribution).", "source": "core\\features\\rl_research.py", "category": "general"}
{"instruction": "Explain the Var function", "input": "", "output": "Function: var\n\nValue at Risk at level alpha.", "source": "core\\features\\rl_research.py", "category": "alpha"}
{"instruction": "Explain the Cvar function", "input": "", "output": "Function: cvar\n\nConditional Value at Risk.", "source": "core\\features\\rl_research.py", "category": "risk"}
{"instruction": "Explain the Std function", "input": "", "output": "Function: std\n\nStandard deviation.", "source": "core\\features\\rl_research.py", "category": "general"}
{"instruction": "Explain the Iqr function", "input": "", "output": "Function: iqr\n\nInterquartile range.", "source": "core\\features\\rl_research.py", "category": "general"}
{"instruction": "What is the formula for Risk Adjusted Value?", "input": "", "output": "Risk-adjusted value: mean - risk_aversion * std.\n\nArgs:\n    risk_aversion: Risk aversion coefficient\n\nReturns:\n    Risk-adjusted expected value", "source": "core\\features\\rl_research.py", "category": "risk"}
{"instruction": "Explain the Risk Adjusted Value function", "input": "", "output": "Function: risk_adjusted_value\n\nRisk-adjusted value: mean - risk_aversion * std.\n\nArgs:\n    risk_aversion: Risk aversion coefficient\n\nReturns:\n    Risk-adjusted expected value", "source": "core\\features\\rl_research.py", "category": "risk"}
{"instruction": "What is the formula for Adapt?", "input": "", "output": "Adapt to new regime using support set.\n\nArgs:\n    support_data: Support set features [n_support, feature_dim]\n    support_labels: Support set labels [n_support]\n\nReturns:\n    Adapted parameters (task-specific)", "source": "core\\features\\rl_research.py", "category": "microstructure"}
{"instruction": "Explain the Adapt function", "input": "", "output": "Function: adapt\n\nAdapt to new regime using support set.\n\nArgs:\n    support_data: Support set features [n_support, feature_dim]\n    support_labels: Support set labels [n_support]\n\nReturns:\n    Adapted parameters (task-specific)", "source": "core\\features\\rl_research.py", "category": "microstructure"}
{"instruction": "What is PPO in quantitative trading?", "input": "", "output": "PPO (Proximal Policy Optimization).\n\nImplementation details:\nAdapt to new regime using support set.\n\nArgs:\n    support_data: Support set features [n_support, feature_dim]\n    support_labels: Support set labels [n_support]\n\nReturns:\n    Adapted parameters (task-specific)", "source": "core\\features\\rl_research.py", "category": "microstructure"}
{"instruction": "What is the formula for Predict?", "input": "", "output": "Make predictions using adapted parameters.\n\nArgs:\n    query_data: Query set features\n    adapted_params: Task-adapted parameters\n\nReturns:\n    Predictions", "source": "core\\features\\rl_research.py", "category": "microstructure"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nMake predictions using adapted parameters.\n\nArgs:\n    query_data: Query set features\n    adapted_params: Task-adapted parameters\n\nReturns:\n    Predictions", "source": "core\\features\\rl_research.py", "category": "microstructure"}
{"instruction": "What is the formula for Meta Update?", "input": "", "output": "Meta-update across multiple tasks (regimes).\n\nArgs:\n    tasks: List of (support_data, query_data) tuples\n\nReturns:\n    Meta-loss", "source": "core\\features\\rl_research.py", "category": "microstructure"}
{"instruction": "Explain the Meta Update function", "input": "", "output": "Function: meta_update\n\nMeta-update across multiple tasks (regimes).\n\nArgs:\n    tasks: List of (support_data, query_data) tuples\n\nReturns:\n    Meta-loss", "source": "core\\features\\rl_research.py", "category": "microstructure"}
{"instruction": "What is PPO in quantitative trading?", "input": "", "output": "PPO (Proximal Policy Optimization).\n\nImplementation details:\nMeta-update across multiple tasks (regimes).\n\nArgs:\n    tasks: List of (support_data, query_data) tuples\n\nReturns:\n    Meta-loss", "source": "core\\features\\rl_research.py", "category": "microstructure"}
{"instruction": "Explain the Update Regime function", "input": "", "output": "Function: update_regime\n\nUpdate regime belief.\n\nArgs:\n    regime_probs: Probability distribution over regimes from HMM\n\nReturns:\n    Most likely regime", "source": "core\\features\\rl_research.py", "category": "regime"}
{"instruction": "What is HMM in quantitative trading?", "input": "", "output": "HMM (Hidden Markov Model for regime detection).\n\nImplementation details:\nUpdate regime belief.\n\nArgs:\n    regime_probs: Probability distribution over regimes from HMM\n\nReturns:\n    Most likely regime", "source": "core\\features\\rl_research.py", "category": "regime"}
{"instruction": "What is the formula for Get Action?", "input": "", "output": "Get action from regime-appropriate policy.\n\nArgs:\n    state: Current state\n\nReturns:\n    Action", "source": "core\\features\\rl_research.py", "category": "regime"}
{"instruction": "Explain the Get Action function", "input": "", "output": "Function: get_action\n\nGet action from regime-appropriate policy.\n\nArgs:\n    state: Current state\n\nReturns:\n    Action", "source": "core\\features\\rl_research.py", "category": "regime"}
{"instruction": "Explain the Compute Context Vector function", "input": "", "output": "Function: compute_context_vector\n\nCompute latent context for regime identification.\n\nArgs:\n    recent_returns: Recent return history\n    recent_volatility: Recent volatility estimates\n\nReturns:\n    Context vector", "source": "core\\features\\rl_research.py", "category": "volatility"}
{"instruction": "Explain the Compute State function", "input": "", "output": "Function: compute_state\n\nCompute state for position sizing RL.\n\nArgs:\n    prediction_confidence: ML model confidence [0, 1]\n    regime_probs: Probability of each regime\n    current_position: Current position (fraction)\n    recent_pnl: Recent PnL (normalized)\n\nReturns:\n    State vector", "source": "core\\features\\rl_research.py", "category": "rl"}
{"instruction": "What is the formula for Kelly Baseline?", "input": "", "output": "Compute CVaR-constrained Kelly as baseline.\n\nArgs:\n    win_prob: Probability of winning\n    win_loss_ratio: Win/loss ratio\n    return_std: Return volatility\n\nReturns:\n    Baseline position size", "source": "core\\features\\rl_research.py", "category": "volatility"}
{"instruction": "Explain the Kelly Baseline function", "input": "", "output": "Function: kelly_baseline\n\nCompute CVaR-constrained Kelly as baseline.\n\nArgs:\n    win_prob: Probability of winning\n    win_loss_ratio: Win/loss ratio\n    return_std: Return volatility\n\nReturns:\n    Baseline position size", "source": "core\\features\\rl_research.py", "category": "volatility"}
{"instruction": "What is Kelly Criterion in quantitative trading?", "input": "", "output": "Kelly Criterion (position sizing formula that maximizes long-term growth).\n\nImplementation details:\nCompute CVaR-constrained Kelly as baseline.\n\nArgs:\n    win_prob: Probability of winning\n    win_loss_ratio: Win/loss ratio\n    return_std: Return volatility\n\nReturns:\n    Baseline position size", "source": "core\\features\\rl_research.py", "category": "volatility"}
{"instruction": "What is the formula for Compute Reward?", "input": "", "output": "Compute reward for position sizing decision.\n\nArgs:\n    position: Position taken\n    realized_return: Actual return\n    transaction_cost: Cost per unit traded\n\nReturns:\n    Reward (risk-adjusted return)", "source": "core\\features\\rl_research.py", "category": "risk"}
{"instruction": "Explain the Compute Reward function", "input": "", "output": "Function: compute_reward\n\nCompute reward for position sizing decision.\n\nArgs:\n    position: Position taken\n    realized_return: Actual return\n    transaction_cost: Cost per unit traded\n\nReturns:\n    Reward (risk-adjusted return)", "source": "core\\features\\rl_research.py", "category": "risk"}
{"instruction": "What is the formula for Generate?", "input": "", "output": "Generate RL-specific features.\n\nArgs:\n    returns: Recent returns\n    prices: Recent prices\n    volumes: Recent volumes (optional)\n\nReturns:\n    Dictionary of feature name -> value", "source": "core\\features\\rl_research.py", "category": "volatility"}
{"instruction": "Explain the Generate function", "input": "", "output": "Function: generate\n\nGenerate RL-specific features.\n\nArgs:\n    returns: Recent returns\n    prices: Recent prices\n    volumes: Recent volumes (optional)\n\nReturns:\n    Dictionary of feature name -> value", "source": "core\\features\\rl_research.py", "category": "volatility"}
{"instruction": "What is the source paper for this technique?", "input": "", "output": "The source is: https://github.com/thuml/Time-Series-Library (11k+ stars). ", "source": "core\\features\\timeseries_features.py", "category": "risk"}
{"instruction": "Explain the purpose of Time-Series-Library Inspired Features", "input": "", "output": "Time-Series-Library Inspired Features\n=====================================\nFeature engineering inspired by state-of-the-art time series models.\n\nSource: https://github.com/thuml/Time-Series-Library (11k+ stars)\n\nInspired by:\n1. iTransformer (ICLR 2024 Spotlight) - Inverted attention on variates\n2. TimeMixer (ICLR 2024) - Multi-scale decomposition\n3. PatchTST (ICLR 2023) - Patch-based representation\n4. TimesNet (ICLR 2023) - 2D temporal variation\n\nThese features capture patterns that deep learning models learn,\nbut in a form usable by gradient boosting models.", "source": "core\\features\\timeseries_features.py", "category": "risk"}
{"instruction": "What is the MultiScaleDecomposition class and how do I use it?", "input": "", "output": "The MultiScaleDecomposition class:\n\nMulti-scale decomposition inspired by TimeMixer.\n\nTimeMixer decomposes series into multiple scales for\nPast-Decomposable-Mixing (PDM).\n\nWe implement similar decomposition using moving averages\nat multiple scales.", "source": "core\\features\\timeseries_features.py", "category": "general"}
{"instruction": "What is the PatchFeatures class and how do I use it?", "input": "", "output": "The PatchFeatures class:\n\nPatch-based features inspired by PatchTST.\n\nPatchTST divides time series into patches and processes them\nindependently before aggregating.\n\nWe create statistics over non-overlapping patches.", "source": "core\\features\\timeseries_features.py", "category": "rl"}
{"instruction": "What is the TemporalVariation2D class and how do I use it?", "input": "", "output": "The TemporalVariation2D class:\n\n2D temporal variation features inspired by TimesNet.\n\nTimesNet reshapes 1D time series into 2D based on\ndetected periods, then applies 2D convolutions.\n\nWe extract period-based features using FFT.", "source": "core\\features\\timeseries_features.py", "category": "volatility"}
{"instruction": "What is the InvertedVariateFeatures class and how do I use it?", "input": "", "output": "The InvertedVariateFeatures class:\n\nInverted variate features inspired by iTransformer.\n\niTransformer applies attention across variates (features)\ninstead of time steps, treating each variate as a token.\n\nWe create cross-variate interaction features.", "source": "core\\features\\timeseries_features.py", "category": "risk"}
{"instruction": "What is the TimeSeriesLibraryFeatures class and how do I use it?", "input": "", "output": "The TimeSeriesLibraryFeatures class:\n\nCombined Time-Series-Library inspired features.\n\nCaptures patterns from:\n- TimeMixer (multi-scale)\n- PatchTST (patch-based)\n- TimesNet (period-based)\n- iTransformer (variate interactions)", "source": "core\\features\\timeseries_features.py", "category": "risk"}
{"instruction": "What is the formula for Generate Timeseries Features?", "input": "", "output": "Generate Time-Series-Library inspired features.\n\nArgs:\n    df: OHLCV DataFrame\n\nReturns:\n    DataFrame with ~45 features", "source": "core\\features\\timeseries_features.py", "category": "general"}
{"instruction": "Explain the Generate Timeseries Features function", "input": "", "output": "Function: generate_timeseries_features\n\nGenerate Time-Series-Library inspired features.\n\nArgs:\n    df: OHLCV DataFrame\n\nReturns:\n    DataFrame with ~45 features", "source": "core\\features\\timeseries_features.py", "category": "general"}
{"instruction": "Explain the Decompose function", "input": "", "output": "Function: decompose\n\nDecompose series into trend and seasonal at multiple scales.\n\nReturns DataFrame with trend_N and seasonal_N for each scale.", "source": "core\\features\\timeseries_features.py", "category": "general"}
{"instruction": "Explain the Extract Patch Features function", "input": "", "output": "Function: extract_patch_features\n\nExtract statistics from patches.\n\nReturns features for each patch: mean, std, trend.", "source": "core\\features\\timeseries_features.py", "category": "general"}
{"instruction": "Explain the Detect Periods function", "input": "", "output": "Function: detect_periods\n\nDetect dominant periods using FFT.", "source": "core\\features\\timeseries_features.py", "category": "general"}
{"instruction": "Explain the Extract Period Features function", "input": "", "output": "Function: extract_period_features\n\nExtract features based on detected periods.", "source": "core\\features\\timeseries_features.py", "category": "general"}
{"instruction": "What is the formula for Extract Variate Interactions?", "input": "", "output": "Extract cross-variate interaction features.\n\nFor OHLCV data, creates interactions between price components.", "source": "core\\features\\timeseries_features.py", "category": "risk"}
{"instruction": "Explain the Extract Variate Interactions function", "input": "", "output": "Function: extract_variate_interactions\n\nExtract cross-variate interaction features.\n\nFor OHLCV data, creates interactions between price components.", "source": "core\\features\\timeseries_features.py", "category": "risk"}
{"instruction": "What is the formula for Generate All?", "input": "", "output": "Generate all Time-Series-Library inspired features.\n\nArgs:\n    df: DataFrame with OHLCV data\n\nReturns:\n    DataFrame with ~45 features", "source": "core\\features\\timeseries_features.py", "category": "general"}
{"instruction": "Explain the Generate All function", "input": "", "output": "Function: generate_all\n\nGenerate all Time-Series-Library inspired features.\n\nArgs:\n    df: DataFrame with OHLCV data\n\nReturns:\n    DataFrame with ~45 features", "source": "core\\features\\timeseries_features.py", "category": "general"}
{"instruction": "Explain the Get Feature Names function", "input": "", "output": "Function: get_feature_names\n\nGet list of feature names.", "source": "core\\features\\timeseries_features.py", "category": "general"}
{"instruction": "Explain the purpose of Universal Mathematical Finance Factors", "input": "", "output": "Universal Mathematical Finance Factors\n======================================\nCross-regional mathematical formulas used across all quantitative finance.\n\nThese are foundational mathematical models that transcend regional boundaries\nand are used by quantitative traders worldwide.\n\nSources:\n1. arXiv:1811.09312 - \"Statistical Arbitrage with Pairs Trading\"\n   - Ornstein-Uhlenbeck process for mean reversion\n   - Optimal entry/exit thresholds\n\n2. Engle-Granger (1987) - \"Cointegration and Error Correction\"\n   Nobel Prize-winning methodology for pairs trading\n\n3. Avellaneda & Stoikov (2008) - \"High-frequency trading in a limit order book\"\n   - Market making optimal quotes\n   - Inventory risk management\n\n4. Kelly (1956) - \"A New Interpretation of Information Rate\"\n   - Optimal position sizing\n   - Growth rate maximization\n\n5. arXiv:2404.00424 - \"Quantformer: Transformer-based Trading\" (2024)\n   - Attention mechanisms for time series\n   - Feature importance weighting\n\n6. Lopez de Prado (2018) - \"Advances in Financial Machine Learning\"\n   - Triple barrier labeling\n   - Feature importance (MDA, MDI)\n   - Structural breaks detection\n\n7. Hamilton (1989) - \"Regime Switching Models\"\n   - Markov regime detection\n   - State probability estimation\n\nTotal: 30 factors organized into:\n- Ornstein-Uhlenbeck (5): Mean reversion spread trading\n- Cointegration (5): Statistical arbitrage signals\n- Market Making (5): Avellaneda-Stoikov framework\n- Kelly Criterion (5): Position sizing signals\n- Attention Weights (5): Transformer-inspired features\n- Regime Detection (5): Markov switching signals", "source": "core\\features\\universal_math.py", "category": "alpha"}
{"instruction": "What is the UniversalMathFeatures class and how do I use it?", "input": "", "output": "The UniversalMathFeatures class:\n\nUniversal Mathematical Finance Features.\n\nFoundational quantitative models used worldwide:\n- Ornstein-Uhlenbeck mean reversion\n- Engle-Granger cointegration\n- Avellaneda-Stoikov market making\n- Kelly criterion position sizing\n- Attention-based feature weighting\n- Markov regime detection\n\nThese models form the mathematical backbone of systematic trading\nacross all asset classes and regions.\n\nUsage:\n    features = UniversalMathFeatures()\n    df_features = features.generate_all(ohlcv_df)", "source": "core\\features\\universal_math.py", "category": "risk"}
{"instruction": "Show me a code example for UniversalMathFeatures", "input": "", "output": "features = UniversalMathFeatures()\n    df_features = features.generate_all(ohlcv_df)", "source": "core\\features\\universal_math.py", "category": "risk"}
{"instruction": "Explain the Generate Universal Math Features function", "input": "", "output": "Function: generate_universal_math_features\n\nGenerate Universal Mathematical features.\n\nArgs:\n    df: OHLCV DataFrame\n\nReturns:\n    DataFrame with 30 mathematical finance factors", "source": "core\\features\\universal_math.py", "category": "alpha"}
{"instruction": "Explain the Generate All function", "input": "", "output": "Function: generate_all\n\nGenerate all Universal Math features.\n\nArgs:\n    df: DataFrame with columns: open, high, low, close, volume\n\nReturns:\n    DataFrame with 30 factor columns", "source": "core\\features\\universal_math.py", "category": "alpha"}
{"instruction": "Explain the Get Feature Names function", "input": "", "output": "Function: get_feature_names\n\nGet list of all feature names.", "source": "core\\features\\universal_math.py", "category": "general"}
{"instruction": "Explain the Get Factor Category function", "input": "", "output": "Function: get_factor_category\n\nGet the category of a factor by name.", "source": "core\\features\\universal_math.py", "category": "alpha"}
{"instruction": "What is the formula for Attention Weights?", "input": "", "output": "Compute attention-weighted average.", "source": "core\\features\\universal_math.py", "category": "general"}
{"instruction": "Explain the Attention Weights function", "input": "", "output": "Function: attention_weights\n\nCompute attention-weighted average.", "source": "core\\features\\universal_math.py", "category": "general"}
{"instruction": "Explain the Regime Duration function", "input": "", "output": "Function: regime_duration\n\nCount consecutive periods in same regime.", "source": "core\\features\\universal_math.py", "category": "regime"}
{"instruction": "Explain the purpose of US Academic Forex Factors", "input": "", "output": "US Academic Forex Factors\n=========================\nGold standard peer-reviewed factors from US academia.\n\nSources:\n1. Lustig, Roussanov, Verdelhan (2011) - \"Common Risk Factors in Currency Markets\"\n   Review of Financial Studies - DOL (Dollar), HML_FX (Carry)\n\n2. Menkhoff et al (2012) - \"Currency Momentum Strategies\"\n   BIS Working Papers No 366 - MOM (Momentum)\n\n3. Asness, Moskowitz, Pedersen (2013) - \"Value and Momentum Everywhere\"\n   Journal of Financial Economics - VAL (Value)\n\n4. Bybee, Gomes, Valente (2023) - \"Macro-Based Factors for Currency Returns\"\n   SSRN - Macro factors\n\n5. AQR Research - Time Series Momentum\n   TSM (Time Series Momentum)\n\nTotal: 50+ factors organized into:\n- Carry factors (8)\n- Momentum factors (10)\n- Value factors (8)\n- Volatility factors (8)\n- Macro-proxy factors (8)\n- Technical factors (8)", "source": "core\\features\\us_academic_factors.py", "category": "alpha"}
{"instruction": "What is the USAcademicFactors class and how do I use it?", "input": "", "output": "The USAcademicFactors class:\n\nUS Academic Forex Factors - Gold Standard.\n\nBased on peer-reviewed research from:\n- Review of Financial Studies\n- Journal of Financial Economics\n- BIS Working Papers\n- NBER Working Papers\n- SSRN\n\nUsage:\n    factors = USAcademicFactors()\n    features = factors.generate_all(ohlcv_df)", "source": "core\\features\\us_academic_factors.py", "category": "alpha"}
{"instruction": "Show me a code example for USAcademicFactors", "input": "", "output": "factors = USAcademicFactors()\n    features = factors.generate_all(ohlcv_df)", "source": "core\\features\\us_academic_factors.py", "category": "alpha"}
{"instruction": "Explain the Generate Us Academic Factors function", "input": "", "output": "Function: generate_us_academic_factors\n\nGenerate US Academic forex factors.\n\nArgs:\n    df: OHLCV DataFrame\n\nReturns:\n    DataFrame with 50 academic factors", "source": "core\\features\\us_academic_factors.py", "category": "alpha"}
{"instruction": "Explain the Generate All function", "input": "", "output": "Function: generate_all\n\nGenerate all US Academic factors.\n\nArgs:\n    df: DataFrame with columns: open, high, low, close, volume\n\nReturns:\n    DataFrame with 50 factor columns", "source": "core\\features\\us_academic_factors.py", "category": "alpha"}
{"instruction": "Explain the Get Feature Names function", "input": "", "output": "Function: get_feature_names\n\nGet list of all feature names.", "source": "core\\features\\us_academic_factors.py", "category": "general"}
{"instruction": "Explain the Get Factor Category function", "input": "", "output": "Function: get_factor_category\n\nGet the category of a factor by name.", "source": "core\\features\\us_academic_factors.py", "category": "alpha"}
{"instruction": "What is the source paper for due to stealth trading?", "input": "", "output": "The source is: Retail and Institutional Investor Trading Behaviors: Evidence. ", "source": "core\\features\\vpin_production.py", "category": "volatility"}
{"instruction": "Explain the purpose of VPIN: Volume-Synchronized Probability of Informed Trading (Production)", "input": "", "output": "VPIN: Volume-Synchronized Probability of Informed Trading (Production)\n=======================================================================\n\nACADEMIC CITATIONS:\n===================\n\nPrimary Papers:\n    Easley, D., López de Prado, M., & O'Hara, M. (2012)\n    \"Flow Toxicity and Liquidity in a High Frequency World\"\n    Review of Financial Studies, Vol. 25, No. 5, pp. 1457-1493\n    SSRN: https://papers.ssrn.com/sol3/papers.cfm?abstract_id=1695596\n\n    Key Innovation: VPIN as real-time indicator of order flow toxicity,\n    predictive of volatility and liquidity crashes.\n\n    Easley, D., López de Prado, M., & O'Hara, M. (2011)\n    \"The Microstructure of the 'Flash Crash': Flow Toxicity, Liquidity\n    Crashes and the Probability of Informed Trading\"\n    The Journal of Portfolio Management, Vol. 37, No. 2, pp. 118-128\n    SSRN: https://papers.ssrn.com/sol3/papers.cfm?abstract_id=1695041\n\n    Application: VPIN spiked before May 6, 2010 Flash Crash, demonstrating\n    early warning capability.\n\nRelated Work:\n    Easley, D., López de Prado, M., & O'Hara, M. (2011)\n    \"The Exchange of Flow Toxicity\"\n    The Journal of Trading, Vol. 6, No. 2, pp. 8-13\n    SSRN: https://papers.ssrn.com/sol3/papers.cfm?abstract_id=1748633\n\nMETHODOLOGY:\n============\n\nOrder Flow Toxicity measures trader's exposure to risk that counterparties\npossess private information or other informational advantages.\n\nVPIN Calculation:\n    1. Partition volume into equal-sized buckets\n    2. Classify each trade as buy or sell (BVC algorithm)\n    3. Calculate volume imbalance in each bucket\n    4. VPIN = average |V_buy - V_sell| / (V_buy + V_sell) over n buckets\n\nProperties:\n    - Updated in volume-time (not clock-time)\n    - Volume-time reflects speed of information arrival\n    - High VPIN → High toxicity → Volatility incoming\n    - Low VPIN → Low toxicity → Stable market\n\nBVC (Bulk Volume Classification):\n    Aggregates trades over short intervals before classification\n    More robust than tick rule in high-frequency environments\n\nINTERPRETATION:\n===============\n\nVPIN Regimes:\n    0.0 - 0.3: Low toxicity (safe to provide liquidity)\n    0.3 - 0.7: Normal toxicity (standard market making)\n    0.7 - 1.0: High toxicity (informed traders active, reduce exposure)\n\nFlash Crash Evidence:\n    \"VPIN reached unprecedented levels in the days and hours before\n    the Flash Crash\" - Easley et al. (2011)\n\nTrading Applications:\n    - Market making: Widen spreads when VPIN high\n    - Directional trading: Fade moves when VPIN low (noise traders)\n    - Risk management: Reduce position size when VPIN high\n\nCHINESE QUANT APPLICATION:\n==========================\n\n90% retail vs 10% institutional in Chinese markets (distinct from US 50/50).\nVPIN helps distinguish informed institutional flow from retail noise.\n\nRetail Flow Characteristics:\n    - Momentum-driven\n    - Incorrect return predictions\n    - Higher VPIN when entering\n\nInstitutional Flow Characteristics:\n    - Contrarian\n    - Correct return predictions\n    - Lower VPIN due to stealth trading\n\nSource: \"Retail and Institutional Investor Trading Behaviors: Evidence\nfrom China\" (Financial Management, 2024)\nhttps://www.sciencedirect.com/science/article/abs/pii/S1042443125000368\n\nUSAGE:\n======\n\n    from core.features.vpin_production import VPINCalculator, VPINConfig\n\n    config = VPINConfig(\n        bucket_size=50000,  # 50k volume per bucket\n        n_buckets=50,       # Rolling window\n        low_threshold=0.3,\n        high_threshold=0.7\n    )\n\n    vpin_calc = VPINCalculator(config)\n\n    # Process tick by tick\n    for tick in price_stream:\n        result = vpin_calc.update(\n            price=tick.price,\n            prev_price=prev_tick.price,\n            volume=tick.volume\n        )\n\n        if result.toxicity_regime == 2:  # High toxicity\n            # Reduce exposure, widen spreads\n\nINTEGRATION WITH EXISTING SYSTEM:\n=================================\n\nYour system already has order flow features (OFI, OEI). VPIN complements:\n    - OFI: Directional flow (buy pressure - sell pressure)\n    - VPIN: Toxicity of flow (informed vs uninformed)\n    - Together: Complete order flow picture\n\nAdd VPIN as feature to ML models for better predictions.", "source": "core\\features\\vpin_production.py", "category": "volatility"}
{"instruction": "What is the VPINConfig class and how do I use it?", "input": "", "output": "The VPINConfig class:\n\nConfiguration for VPIN calculator.\n\nBased on Easley, López de Prado, O'Hara (2012) RFS.", "source": "core\\features\\vpin_production.py", "category": "general"}
{"instruction": "What is the VPINResult class and how do I use it?", "input": "", "output": "The VPINResult class:\n\nResult from VPIN calculation.", "source": "core\\features\\vpin_production.py", "category": "general"}
{"instruction": "What is the VPINCalculator class and how do I use it?", "input": "", "output": "The VPINCalculator class:\n\nVolume-Synchronized Probability of Informed Trading.\n\nImplementation based on:\n    Easley, López de Prado, O'Hara (2012) Review of Financial Studies\n    Easley, López de Prado, O'Hara (2011) Journal of Portfolio Management\n\nAcademic validation:\n    - Predicted 2010 Flash Crash\n    - Correlated with future volatility\n    - Used by institutional traders for risk management", "source": "core\\features\\vpin_production.py", "category": "volatility"}
{"instruction": "What is the VPINRegimeDetector class and how do I use it?", "input": "", "output": "The VPINRegimeDetector class:\n\nDetect market regimes using VPIN.\n\nCombines VPIN with volatility and volume for comprehensive regime detection.", "source": "core\\features\\vpin_production.py", "category": "volatility"}
{"instruction": "Explain the Create Vpin Calculator function", "input": "", "output": "Function: create_vpin_calculator\n\nCreate VPIN calculator with standard parameters.\n\nArgs:\n    bucket_size: Volume per bucket (default 50k from Easley et al.)\n    n_buckets: Rolling window size (default 50)\n\nReturns:\n    VPINCalculator instance", "source": "core\\features\\vpin_production.py", "category": "volatility"}
{"instruction": "What is VPIN in quantitative trading?", "input": "", "output": "VPIN (Volume-Synchronized Probability of Informed Trading).\n\nImplementation details:\nCreate VPIN calculator with standard parameters.\n\nArgs:\n    bucket_size: Volume per bucket (default 50k from Easley et al.)\n    n_buckets: Rolling window size (default 50)\n\nReturns:\n    VPINCalculator instance", "source": "core\\features\\vpin_production.py", "category": "volatility"}
{"instruction": "Explain the Update function", "input": "", "output": "Function: update\n\nUpdate VPIN with new tick.\n\nArgs:\n    price: Current price\n    prev_price: Previous price\n    volume: Volume of current trade\n\nReturns:\n    VPINResult with current VPIN and toxicity regime", "source": "core\\features\\vpin_production.py", "category": "volatility"}
{"instruction": "What is VPIN in quantitative trading?", "input": "", "output": "VPIN (Volume-Synchronized Probability of Informed Trading).\n\nImplementation details:\nUpdate VPIN with new tick.\n\nArgs:\n    price: Current price\n    prev_price: Previous price\n    volume: Volume of current trade\n\nReturns:\n    VPINResult with current VPIN and toxicity regime", "source": "core\\features\\vpin_production.py", "category": "volatility"}
{"instruction": "Explain the Get Stats function", "input": "", "output": "Function: get_stats\n\nGet statistics for monitoring.", "source": "core\\features\\vpin_production.py", "category": "general"}
{"instruction": "Explain the Reset function", "input": "", "output": "Function: reset\n\nReset calculator to initial state.", "source": "core\\features\\vpin_production.py", "category": "regime"}
{"instruction": "Explain the Update function", "input": "", "output": "Function: update\n\nUpdate and detect regime.\n\nArgs:\n    price: Current price\n    prev_price: Previous price\n    volume: Trade volume\n\nReturns:\n    Dict with VPIN, volatility, and regime classification", "source": "core\\features\\vpin_production.py", "category": "volatility"}
{"instruction": "What is VPIN in quantitative trading?", "input": "", "output": "VPIN (Volume-Synchronized Probability of Informed Trading).\n\nImplementation details:\nUpdate and detect regime.\n\nArgs:\n    price: Current price\n    prev_price: Previous price\n    volume: Trade volume\n\nReturns:\n    Dict with VPIN, volatility, and regime classification", "source": "core\\features\\vpin_production.py", "category": "volatility"}
{"instruction": "Explain the purpose of Adaptive HFT Engine - Renaissance Level Mathematical Framework", "input": "", "output": "Adaptive HFT Engine - Renaissance Level Mathematical Framework\n==============================================================\n\nAchieves 66%+ win rate at tick-level speed using:\n1. Signal decay modeling (Amihud & Mendelson 1986)\n2. Master profitability equation (Kyle 1985, Almgren-Chriss 2000)\n3. Dynamic parameter adjustment (GARCH, HMM, Hawkes)\n4. Regime-adjusted Kelly criterion (Thorp 1962)\n5. 4-Layer Ultra-Selective Filter (Renaissance approach)\n\nAcademic References:\n- Kyle (1985) - \"Continuous Auctions and Insider Trading\"\n- Bollerslev (1986) - \"GARCH\"\n- Hamilton (1989) - \"Regime Switching\"\n- Hawkes (1971) - \"Self-Exciting Point Processes\"\n- Amihud & Mendelson (1986) - \"Bid-Ask Spread\"\n- De Prado (2018) - \"Advances in Financial Machine Learning\"\n- Avellaneda & Stoikov (2008) - \"HFT in Limit Order Book\"", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "alpha"}
{"instruction": "What is the TradeDecision class and how do I use it?", "input": "", "output": "The TradeDecision class:\n\nResult of trade evaluation.", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "general"}
{"instruction": "What is the SignalDecayModel class and how do I use it?", "input": "", "output": "The SignalDecayModel class:\n\nFormulas 1-2: Exponential signal decay with regime adjustment.\n\nBased on Amihud & Mendelson (1986) information decay model.\n\nA(h) = A_base + (A_0 - A_base) * exp(-lambda * h)\n\nWhere:\n- A(h) = Accuracy at horizon h ticks\n- A_0 = Initial accuracy (fitted from data)\n- A_base = Asymptotic baseline (0.50 = random)\n- lambda = Decay rate (fitted: 0.213)", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "alpha"}
{"instruction": "What is the ProfitabilityCalculator class and how do I use it?", "input": "", "output": "The ProfitabilityCalculator class:\n\nFormulas 3-4: Master profitability equation.\n\nBased on Kyle (1985) and Almgren-Chriss (2000).\n\nE[Profit] = A(h) * R_win - (1 - A(h)) * R_loss - S - lambda_kyle * Q - alpha * sigma * sqrt(h)\n\nWhere:\n- A(h) = Decay-adjusted accuracy\n- R_win = Expected return if correct (bps)\n- R_loss = Expected loss if incorrect (bps)\n- S = Spread cost (bps)\n- lambda_kyle = Kyle's lambda (price impact)\n- Q = Order size\n- alpha = Slippage coefficient\n- sigma = Tick volatility", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "alpha"}
{"instruction": "What is the AdaptiveParameterManager class and how do I use it?", "input": "", "output": "The AdaptiveParameterManager class:\n\nFormulas 5-8: Real-time parameter estimation.\n\nManages dynamic estimation of:\n- Kyle's lambda (Formula 5) - Kyle (1985)\n- GARCH volatility (Formula 6) - Bollerslev (1986)\n- HMM regime (Formula 7) - Hamilton (1989)\n- Hawkes intensity (Formula 8) - Hawkes (1971)", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "volatility"}
{"instruction": "What is the RegimeAwareKelly class and how do I use it?", "input": "", "output": "The RegimeAwareKelly class:\n\nFormulas 9-10: Position sizing with regime adjustment.\n\nBased on Kelly Criterion (Thorp 1962) with modifications for:\n- Fractional Kelly (safety)\n- Regime-based adjustment\n- Confidence scaling\n- Drawdown control", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "risk"}
{"instruction": "What is the UltraSelectiveFilter class and how do I use it?", "input": "", "output": "The UltraSelectiveFilter class:\n\n4-Layer Filter Stack for 66%+ Accuracy\n======================================\n\nRenaissance achieved 66% by extreme trade selection.\nThis filter ensures only the highest-probability trades are taken.\n\nLayer 1: Confidence threshold (top 10%)\nLayer 2: Multi-model agreement (3/3 unanimous)\nLayer 3: Regime filter (favorable conditions)\nLayer 4: Order flow confirmation\n\nMathematical basis (3 independent models at 59.3%):\nP(correct | all_agree) = 0.593^3 / (0.593^3 + 0.407^3)\n                       = 0.209 / 0.276 = 75.7%", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "regime"}
{"instruction": "What is the AdaptiveHFTEngine class and how do I use it?", "input": "", "output": "The AdaptiveHFTEngine class:\n\nMain Coordinator - The Brain of Adaptive Trading\n=================================================\n\nCombines all components:\n- Signal decay modeling\n- Profitability calculation\n- Dynamic parameter estimation\n- Kelly position sizing\n- Ultra-selective filtering", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "alpha"}
{"instruction": "Explain the Create Adaptive Engine function", "input": "", "output": "Function: create_adaptive_engine\n\nCreate a configured AdaptiveHFTEngine instance.", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "general"}
{"instruction": "Explain the Evaluate Profitability function", "input": "", "output": "Function: evaluate_profitability\n\nQuick profitability check.", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "general"}
{"instruction": "What is OFI in quantitative trading?", "input": "", "output": "OFI (Order Flow Imbalance).\n\nImplementation details:\nQuick profitability check.", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "general"}
{"instruction": "What is the formula for Accuracy?", "input": "", "output": "Calculate expected accuracy at given horizon and regime.\n\nArgs:\n    horizon: Prediction horizon in ticks\n    regime: Market regime (0=low vol, 1=normal, 2=high vol)\n\nReturns:\n    Expected accuracy (0.5 to A_0)", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "volatility"}
{"instruction": "Explain the Accuracy function", "input": "", "output": "Function: accuracy\n\nCalculate expected accuracy at given horizon and regime.\n\nArgs:\n    horizon: Prediction horizon in ticks\n    regime: Market regime (0=low vol, 1=normal, 2=high vol)\n\nReturns:\n    Expected accuracy (0.5 to A_0)", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "volatility"}
{"instruction": "What is the formula for Half Life?", "input": "", "output": "Calculate signal half-life in ticks.\n\nHalf-life = ln(2) / lambda", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "alpha"}
{"instruction": "Explain the Half Life function", "input": "", "output": "Function: half_life\n\nCalculate signal half-life in ticks.\n\nHalf-life = ln(2) / lambda", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "alpha"}
{"instruction": "Explain the Optimal Horizon function", "input": "", "output": "Function: optimal_horizon\n\nFind longest horizon where A(h) > min_accuracy.\n\nArgs:\n    regime: Market regime\n    min_accuracy: Minimum required accuracy\n\nReturns:\n    Optimal horizon in ticks (1 minimum)", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "microstructure"}
{"instruction": "What is the formula for Fit From Data?", "input": "", "output": "Fit lambda parameter from observed accuracy at different horizons.\n\nUses least squares fitting on log-transformed decay equation.", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "general"}
{"instruction": "Explain the Fit From Data function", "input": "", "output": "Function: fit_from_data\n\nFit lambda parameter from observed accuracy at different horizons.\n\nUses least squares fitting on log-transformed decay equation.", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "general"}
{"instruction": "Explain the Expected Profit function", "input": "", "output": "Function: expected_profit\n\nCalculate expected profit per trade.\n\nArgs:\n    accuracy: Predicted win probability\n    R_win: Expected return if correct (bps)\n    R_loss: Expected loss if incorrect (bps)\n    kyle_lambda: Price impact coefficient\n    order_size: Trade size (units)\n    volatility: Current volatility\n    horizon: Holding period (ticks)\n\nReturns:\n    Expected profit in bps", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "volatility"}
{"instruction": "What is OFI in quantitative trading?", "input": "", "output": "OFI (Order Flow Imbalance).\n\nImplementation details:\nCalculate expected profit per trade.\n\nArgs:\n    accuracy: Predicted win probability\n    R_win: Expected return if correct (bps)\n    R_loss: Expected loss if incorrect (bps)\n    kyle_lambda: Price impact coefficient\n    order_size: Trade size (units)\n    volatility: Current volatility\n    horizon: Holding period (ticks)\n\nReturns:\n    Expected profit in bps", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "volatility"}
{"instruction": "What is the formula for Min Accuracy?", "input": "", "output": "Formula 4: Calculate minimum accuracy required for profitability.\n\nA_min = (R_loss + costs) / (R_win + R_loss)\n\nONLY TRADE WHEN: A(h) > A_min", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "general"}
{"instruction": "Explain the Min Accuracy function", "input": "", "output": "Function: min_accuracy\n\nFormula 4: Calculate minimum accuracy required for profitability.\n\nA_min = (R_loss + costs) / (R_win + R_loss)\n\nONLY TRADE WHEN: A(h) > A_min", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "general"}
{"instruction": "What is OFI in quantitative trading?", "input": "", "output": "OFI (Order Flow Imbalance).\n\nImplementation details:\nFormula 4: Calculate minimum accuracy required for profitability.\n\nA_min = (R_loss + costs) / (R_win + R_loss)\n\nONLY TRADE WHEN: A(h) > A_min", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "general"}
{"instruction": "Explain the Is Profitable function", "input": "", "output": "Function: is_profitable\n\nCheck if trade is profitable and return expected profit.\n\nReturns:\n    (is_profitable, expected_profit)", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "general"}
{"instruction": "What is OFI in quantitative trading?", "input": "", "output": "OFI (Order Flow Imbalance).\n\nImplementation details:\nCheck if trade is profitable and return expected profit.\n\nReturns:\n    (is_profitable, expected_profit)", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "general"}
{"instruction": "Explain the Break Even Spread function", "input": "", "output": "Function: break_even_spread\n\nCalculate maximum spread that allows profitability.\n\nUseful for determining if institutional spreads are required.", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "microstructure"}
{"instruction": "What is OFI in quantitative trading?", "input": "", "output": "OFI (Order Flow Imbalance).\n\nImplementation details:\nCalculate maximum spread that allows profitability.\n\nUseful for determining if institutional spreads are required.", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "microstructure"}
{"instruction": "Explain the Update function", "input": "", "output": "Function: update\n\nUpdate all parameter estimates with new data.\n\nArgs:\n    price: Current price\n    volume: Current volume\n    timestamp: Unix timestamp (for Hawkes)", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "volatility"}
{"instruction": "Explain the Get Regime function", "input": "", "output": "Function: get_regime\n\nGet current market regime (0, 1, 2).", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "regime"}
{"instruction": "Explain the Get Volatility function", "input": "", "output": "Function: get_volatility\n\nGet GARCH volatility forecast.", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "volatility"}
{"instruction": "What is GARCH in quantitative trading?", "input": "", "output": "GARCH (volatility forecasting model).\n\nImplementation details:\nGet GARCH volatility forecast.", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "volatility"}
{"instruction": "Explain the Get Kyle Lambda function", "input": "", "output": "Function: get_kyle_lambda\n\nGet current Kyle's lambda estimate.", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "general"}
{"instruction": "Explain the Get Hawkes Intensity function", "input": "", "output": "Function: get_hawkes_intensity\n\nGet current Hawkes intensity.", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "general"}
{"instruction": "Explain the Set Vol Percentiles function", "input": "", "output": "Function: set_vol_percentiles\n\nUpdate volatility percentile thresholds for regime detection.", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "volatility"}
{"instruction": "What is the formula for Base Kelly?", "input": "", "output": "Formula 9: Base Kelly fraction.\n\nf* = (p * b - q) / b\n\nFor symmetric payoffs (b=1): f* = 2p - 1", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "risk"}
{"instruction": "Explain the Base Kelly function", "input": "", "output": "Function: base_kelly\n\nFormula 9: Base Kelly fraction.\n\nf* = (p * b - q) / b\n\nFor symmetric payoffs (b=1): f* = 2p - 1", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "risk"}
{"instruction": "What is Kelly Criterion in quantitative trading?", "input": "", "output": "Kelly Criterion (position sizing formula that maximizes long-term growth).\n\nImplementation details:\nFormula 9: Base Kelly fraction.\n\nf* = (p * b - q) / b\n\nFor symmetric payoffs (b=1): f* = 2p - 1", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "risk"}
{"instruction": "What is the formula for Position Size?", "input": "", "output": "Formula 10: Full position size with all adjustments.\n\nPosition = f_frac * regime_mult * confidence_mult * drawdown_factor * capital", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "alpha"}
{"instruction": "Explain the Position Size function", "input": "", "output": "Function: position_size\n\nFormula 10: Full position size with all adjustments.\n\nPosition = f_frac * regime_mult * confidence_mult * drawdown_factor * capital", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "alpha"}
{"instruction": "Explain the Max Position function", "input": "", "output": "Function: max_position\n\nMaximum position size as fraction of capital.", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "general"}
{"instruction": "Explain the Update Confidence History function", "input": "", "output": "Function: update_confidence_history\n\nAdd confidence to history for percentile calculation.", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "general"}
{"instruction": "What is the formula for Should Trade?", "input": "", "output": "Apply all 4 filter layers.\n\nArgs:\n    predictions: Dict of model predictions {'xgboost': {'direction': 1, 'prob': 0.6}, ...}\n    regime: Current market regime (0, 1, 2)\n    ofi: Order flow imbalance (positive = buy pressure)\n    confidence: Ensemble confidence score\n\nReturns:\n    (should_trade, reason, filters_passed)", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "regime"}
{"instruction": "Explain the Should Trade function", "input": "", "output": "Function: should_trade\n\nApply all 4 filter layers.\n\nArgs:\n    predictions: Dict of model predictions {'xgboost': {'direction': 1, 'prob': 0.6}, ...}\n    regime: Current market regime (0, 1, 2)\n    ofi: Order flow imbalance (positive = buy pressure)\n    confidence: Ensemble confidence score\n\nReturns:\n    (should_trade, reason, filters_passed)", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "regime"}
{"instruction": "What is OFI in quantitative trading?", "input": "", "output": "OFI (Order Flow Imbalance).\n\nImplementation details:\nApply all 4 filter layers.\n\nArgs:\n    predictions: Dict of model predictions {'xgboost': {'direction': 1, 'prob': 0.6}, ...}\n    regime: Current market regime (0, 1, 2)\n    ofi: Order flow imbalance (positive = buy pressure)\n    confidence: Ensemble confidence score\n\nReturns:\n    (should_trade, reason, filters_passed)", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "regime"}
{"instruction": "What is the formula for Theoretical Accuracy?", "input": "", "output": "Calculate theoretical accuracy when all models agree.\n\nP(correct | all_agree) = p^n / (p^n + (1-p)^n)", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "general"}
{"instruction": "Explain the Theoretical Accuracy function", "input": "", "output": "Function: theoretical_accuracy\n\nCalculate theoretical accuracy when all models agree.\n\nP(correct | all_agree) = p^n / (p^n + (1-p)^n)", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "general"}
{"instruction": "Explain the Update State function", "input": "", "output": "Function: update_state\n\nUpdate trading state.", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "regime"}
{"instruction": "Explain the Process Tick function", "input": "", "output": "Function: process_tick\n\nProcess incoming tick data.", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "microstructure"}
{"instruction": "Explain the Evaluate Trade function", "input": "", "output": "Function: evaluate_trade\n\nMaster decision function.\n\nArgs:\n    features: Feature array for models\n    model_predictions: Dict of predictions from each model\n        {'xgboost': {'direction': 1, 'prob': 0.62, 'confidence': 0.24}, ...}\n    ofi: Order flow imbalance\n\nReturns:\n    TradeDecision with all details", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "general"}
{"instruction": "What is OFI in quantitative trading?", "input": "", "output": "OFI (Order Flow Imbalance).\n\nImplementation details:\nMaster decision function.\n\nArgs:\n    features: Feature array for models\n    model_predictions: Dict of predictions from each model\n        {'xgboost': {'direction': 1, 'prob': 0.62, 'confidence': 0.24}, ...}\n    ofi: Order flow imbalance\n\nReturns:\n    TradeDecision with all details", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "general"}
{"instruction": "Explain the Get Statistics function", "input": "", "output": "Function: get_statistics\n\nGet current engine statistics.", "source": "core\\_experimental\\adaptive_hft_engine.py", "category": "general"}
{"instruction": "Explain the purpose of Advanced Kalman Filters for HFT Forex", "input": "", "output": "Advanced Kalman Filters for HFT Forex\n=====================================\nRenaissance Technologies inference: Speech recognition experts (Mercer, Brown)\nbrought Hidden Markov Model / state-space expertise. Extended and Unscented\nKalman Filters handle nonlinear price dynamics better than basic Kalman.\n\nImplemented Filters:\n- Extended Kalman Filter (EKF): Linearizes nonlinear dynamics\n- Unscented Kalman Filter (UKF): Sigma-point propagation (more accurate)\n- Adaptive Kalman Filter: Auto-tunes process/measurement noise\n\nSources:\n- Bar-Shalom & Rong Li \"Estimation with Applications to Tracking and Navigation\"\n- Julier & Uhlmann (1997) \"A New Extension of the Kalman Filter to Nonlinear Systems\"\n- Wan & van der Merwe (2000) \"The Unscented Kalman Filter for Nonlinear Estimation\"\n\nWhy Renaissance Uses This:\n- Price = TrueValue + MicrostructureNoise\n- EKF/UKF better captures mean-reversion with time-varying volatility\n- Handles transaction costs as nonlinear state transition", "source": "core\\_experimental\\advanced_kalman_filters.py", "category": "volatility"}
{"instruction": "What is the KalmanState class and how do I use it?", "input": "", "output": "The KalmanState class:\n\nState estimate from Kalman filter.", "source": "core\\_experimental\\advanced_kalman_filters.py", "category": "regime"}
{"instruction": "What is the ExtendedKalmanFilter class and how do I use it?", "input": "", "output": "The ExtendedKalmanFilter class:\n\nExtended Kalman Filter (EKF) for nonlinear state estimation.\n\nRenaissance Application:\n- Estimates \"true\" price from noisy observations\n- Handles mean-reversion with time-varying parameters\n- Accounts for bid-ask bounce (microstructure noise)\n\nState Model:\n    x_t = f(x_{t-1}) + w_t  (nonlinear state transition)\n    z_t = h(x_t) + v_t      (observation)\n\nFor forex HFT:\n    x = [price, velocity, volatility]  (latent state)\n    z = mid_price                       (observed)\n\nSource: Bar-Shalom \"Estimation with Applications to Tracking\"", "source": "core\\_experimental\\advanced_kalman_filters.py", "category": "volatility"}
{"instruction": "What is the UnscentedKalmanFilter class and how do I use it?", "input": "", "output": "The UnscentedKalmanFilter class:\n\nUnscented Kalman Filter (UKF) - more accurate than EKF for nonlinear systems.\n\nRenaissance Application:\n- Better uncertainty propagation through nonlinear dynamics\n- Handles heavy-tailed distributions better\n- More robust to model misspecification\n\nKey Idea: Instead of linearizing, propagate \"sigma points\" through\nnonlinear function and compute statistics from transformed points.\n\nSource: Julier & Uhlmann (1997) \"A New Extension of the Kalman Filter\"", "source": "core\\_experimental\\advanced_kalman_filters.py", "category": "time_series"}
{"instruction": "What is the AdaptiveKalmanFilter class and how do I use it?", "input": "", "output": "The AdaptiveKalmanFilter class:\n\nAdaptive Kalman Filter with online noise estimation.\n\nRenaissance Application:\n- Auto-tunes to changing market conditions\n- Detects regime changes via innovation sequence\n- Adjusts process/measurement noise dynamically\n\nKey Insight: Monitor innovation sequence. If innovations are\nconsistently larger than expected, increase process noise.\nIf smaller, decrease it.\n\nSource: Mehra (1970) \"On the Identification of Variances and Adaptive Kalman Filtering\"", "source": "core\\_experimental\\advanced_kalman_filters.py", "category": "risk"}
{"instruction": "What is the KalmanFilterEnsemble class and how do I use it?", "input": "", "output": "The KalmanFilterEnsemble class:\n\nEnsemble of Kalman Filters with different parameters.\n\nRenaissance Philosophy: \"Many weak signals combined\"\n- Run multiple filters with different mean-reversion speeds\n- Combine via likelihood weighting\n- More robust to parameter misspecification", "source": "core\\_experimental\\advanced_kalman_filters.py", "category": "alpha"}
{"instruction": "Explain the Compute Kalman Features function", "input": "", "output": "Function: compute_kalman_features\n\nCompute Kalman filter features for HFT.\n\nArgs:\n    prices: Price series\n    filter_type: 'ekf', 'ukf', 'adaptive_ukf', or 'ensemble'\n\nReturns:\n    DataFrame with Kalman features", "source": "core\\_experimental\\advanced_kalman_filters.py", "category": "ensemble"}
{"instruction": "What is Kalman Filter in quantitative trading?", "input": "", "output": "Kalman Filter (state estimation and signal filtering).\n\nImplementation details:\nCompute Kalman filter features for HFT.\n\nArgs:\n    prices: Price series\n    filter_type: 'ekf', 'ukf', 'adaptive_ukf', or 'ensemble'\n\nReturns:\n    DataFrame with Kalman features", "source": "core\\_experimental\\advanced_kalman_filters.py", "category": "ensemble"}
{"instruction": "What is the formula for Create Kalman Filter?", "input": "", "output": "Factory function to create Kalman filter.\n\nArgs:\n    filter_type: 'ekf', 'ukf', 'adaptive_ukf', 'adaptive_ekf', 'ensemble'\n    **kwargs: Additional arguments for specific filter\n\nReturns:\n    Kalman filter instance", "source": "core\\_experimental\\advanced_kalman_filters.py", "category": "alpha"}
{"instruction": "Explain the Create Kalman Filter function", "input": "", "output": "Function: create_kalman_filter\n\nFactory function to create Kalman filter.\n\nArgs:\n    filter_type: 'ekf', 'ukf', 'adaptive_ukf', 'adaptive_ekf', 'ensemble'\n    **kwargs: Additional arguments for specific filter\n\nReturns:\n    Kalman filter instance", "source": "core\\_experimental\\advanced_kalman_filters.py", "category": "alpha"}
{"instruction": "What is Kalman Filter in quantitative trading?", "input": "", "output": "Kalman Filter (state estimation and signal filtering).\n\nImplementation details:\nFactory function to create Kalman filter.\n\nArgs:\n    filter_type: 'ekf', 'ukf', 'adaptive_ukf', 'adaptive_ekf', 'ensemble'\n    **kwargs: Additional arguments for specific filter\n\nReturns:\n    Kalman filter instance", "source": "core\\_experimental\\advanced_kalman_filters.py", "category": "alpha"}
{"instruction": "What is the formula for State Transition?", "input": "", "output": "Nonlinear state transition function f(x).\n\nModel: Ornstein-Uhlenbeck with stochastic volatility\n    price_t = price_{t-1} + velocity_{t-1} * dt\n    velocity_t = -kappa * velocity_{t-1}  (mean-reverting velocity)\n    volatility_t = volatility_{t-1}  (random walk)", "source": "core\\_experimental\\advanced_kalman_filters.py", "category": "volatility"}
{"instruction": "Explain the State Transition function", "input": "", "output": "Function: state_transition\n\nNonlinear state transition function f(x).\n\nModel: Ornstein-Uhlenbeck with stochastic volatility\n    price_t = price_{t-1} + velocity_{t-1} * dt\n    velocity_t = -kappa * velocity_{t-1}  (mean-reverting velocity)\n    volatility_t = volatility_{t-1}  (random walk)", "source": "core\\_experimental\\advanced_kalman_filters.py", "category": "volatility"}
{"instruction": "What is the formula for State Jacobian?", "input": "", "output": "Jacobian of state transition F = df/dx.", "source": "core\\_experimental\\advanced_kalman_filters.py", "category": "regime"}
{"instruction": "Explain the State Jacobian function", "input": "", "output": "Function: state_jacobian\n\nJacobian of state transition F = df/dx.", "source": "core\\_experimental\\advanced_kalman_filters.py", "category": "regime"}
{"instruction": "Explain the Observation Function function", "input": "", "output": "Function: observation_function\n\nObservation function h(x).\nWe observe price directly.", "source": "core\\_experimental\\advanced_kalman_filters.py", "category": "general"}
{"instruction": "What is the formula for Observation Jacobian?", "input": "", "output": "Jacobian of observation H = dh/dx.", "source": "core\\_experimental\\advanced_kalman_filters.py", "category": "general"}
{"instruction": "Explain the Observation Jacobian function", "input": "", "output": "Function: observation_jacobian\n\nJacobian of observation H = dh/dx.", "source": "core\\_experimental\\advanced_kalman_filters.py", "category": "general"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nPrediction step: propagate state through nonlinear dynamics.", "source": "core\\_experimental\\advanced_kalman_filters.py", "category": "regime"}
{"instruction": "Explain the Update function", "input": "", "output": "Function: update\n\nUpdate step: incorporate new observation.\n\nArgs:\n    z: Observed price (mid price)\n    dt: Time step\n\nReturns:\n    Updated state estimate", "source": "core\\_experimental\\advanced_kalman_filters.py", "category": "regime"}
{"instruction": "Explain the Get Filtered Price function", "input": "", "output": "Function: get_filtered_price\n\nGet filtered price estimate (true value).", "source": "core\\_experimental\\advanced_kalman_filters.py", "category": "general"}
{"instruction": "Explain the Get Velocity function", "input": "", "output": "Function: get_velocity\n\nGet price velocity (momentum).", "source": "core\\_experimental\\advanced_kalman_filters.py", "category": "general"}
{"instruction": "Explain the Get Volatility function", "input": "", "output": "Function: get_volatility\n\nGet volatility estimate.", "source": "core\\_experimental\\advanced_kalman_filters.py", "category": "volatility"}
{"instruction": "Explain the Get Prediction Interval function", "input": "", "output": "Function: get_prediction_interval\n\nGet prediction interval for price.", "source": "core\\_experimental\\advanced_kalman_filters.py", "category": "general"}
{"instruction": "What is the formula for Smooth?", "input": "", "output": "Rauch-Tung-Striebel smoother for offline analysis.\nUses forward-backward pass for optimal estimates.", "source": "core\\_experimental\\advanced_kalman_filters.py", "category": "general"}
{"instruction": "Explain the Smooth function", "input": "", "output": "Function: smooth\n\nRauch-Tung-Striebel smoother for offline analysis.\nUses forward-backward pass for optimal estimates.", "source": "core\\_experimental\\advanced_kalman_filters.py", "category": "general"}
{"instruction": "Explain the Generate Sigma Points function", "input": "", "output": "Function: generate_sigma_points\n\nGenerate sigma points around state estimate.", "source": "core\\_experimental\\advanced_kalman_filters.py", "category": "regime"}
{"instruction": "Explain the State Transition function", "input": "", "output": "Function: state_transition\n\nNonlinear state transition (same as EKF).", "source": "core\\_experimental\\advanced_kalman_filters.py", "category": "regime"}
{"instruction": "Explain the Observation Function function", "input": "", "output": "Function: observation_function\n\nObservation function.", "source": "core\\_experimental\\advanced_kalman_filters.py", "category": "general"}
{"instruction": "Explain the Update function", "input": "", "output": "Function: update\n\nUKF update with sigma point propagation.", "source": "core\\_experimental\\advanced_kalman_filters.py", "category": "general"}
{"instruction": "Explain the Update function", "input": "", "output": "Function: update\n\nUpdate with noise adaptation.", "source": "core\\_experimental\\advanced_kalman_filters.py", "category": "general"}
{"instruction": "What is the formula for Get Regime Indicator?", "input": "", "output": "Get regime indicator based on innovation sequence.\nHigh values indicate high uncertainty / regime change.", "source": "core\\_experimental\\advanced_kalman_filters.py", "category": "regime"}
{"instruction": "Explain the Get Regime Indicator function", "input": "", "output": "Function: get_regime_indicator\n\nGet regime indicator based on innovation sequence.\nHigh values indicate high uncertainty / regime change.", "source": "core\\_experimental\\advanced_kalman_filters.py", "category": "regime"}
{"instruction": "Explain the Update function", "input": "", "output": "Function: update\n\nUpdate all filters and combine estimates.", "source": "core\\_experimental\\advanced_kalman_filters.py", "category": "general"}
{"instruction": "What is the source paper for this technique?", "input": "", "output": "The source is: 国泰君安 (Guotai Junan Securities) Research Report. ", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the purpose of 国泰君安 Alpha191 - 191 Short-Period Technical Factors", "input": "", "output": "国泰君安 Alpha191 - 191 Short-Period Technical Factors\n=======================================================\nSource: 国泰君安 (Guotai Junan Securities) Research Report\n\"基于短周期价量特征的多因子选股体系——数量化专题之九十三\" (2017)\n\nVerified from:\n- Zhihu (知乎): https://zhuanlan.zhihu.com/p/58595574\n- GitHub: https://github.com/Daic115/alpha191\n- GitHub: https://github.com/popbo/alphas\n\nAdapted for forex from original equity implementation.", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the Alpha191GuotaiJunan class and how do I use it?", "input": "", "output": "The Alpha191GuotaiJunan class:\n\nComplete implementation of all 191 国泰君安 short-period alphas.\n\nUsage:\n    alpha = Alpha191GuotaiJunan()\n    df = alpha.generate_all_alphas(ohlcv_data)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Show me a code example for Alpha191GuotaiJunan", "input": "", "output": "alpha = Alpha191GuotaiJunan()\n    df = alpha.generate_all_alphas(ohlcv_data)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Rank?", "input": "", "output": "Cross-sectional rank (percentile).", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "general"}
{"instruction": "Explain the Rank function", "input": "", "output": "Function: rank\n\nCross-sectional rank (percentile).", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "general"}
{"instruction": "Explain the Delta function", "input": "", "output": "Function: delta\n\nDifference from d periods ago.", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "general"}
{"instruction": "Explain the Delay function", "input": "", "output": "Function: delay\n\nLag by d periods.", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "general"}
{"instruction": "Explain the Correlation function", "input": "", "output": "Function: correlation\n\nRolling correlation.", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "general"}
{"instruction": "Explain the Covariance function", "input": "", "output": "Function: covariance\n\nRolling covariance.", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "risk"}
{"instruction": "What is the formula for Ts Rank?", "input": "", "output": "Time-series rank over d periods.", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "general"}
{"instruction": "Explain the Ts Rank function", "input": "", "output": "Function: ts_rank\n\nTime-series rank over d periods.", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "general"}
{"instruction": "Explain the Ts Max function", "input": "", "output": "Function: ts_max\n\nRolling maximum.", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "general"}
{"instruction": "Explain the Ts Min function", "input": "", "output": "Function: ts_min\n\nRolling minimum.", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "general"}
{"instruction": "Explain the Ts Argmax function", "input": "", "output": "Function: ts_argmax\n\nDays since maximum (HIGHDAY).", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "general"}
{"instruction": "Explain the Ts Argmin function", "input": "", "output": "Function: ts_argmin\n\nDays since minimum (LOWDAY).", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "general"}
{"instruction": "Explain the Ts Sum function", "input": "", "output": "Function: ts_sum\n\nRolling sum (SUM).", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "general"}
{"instruction": "Explain the Ts Mean function", "input": "", "output": "Function: ts_mean\n\nRolling mean (MEAN).", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "general"}
{"instruction": "Explain the Ts Std function", "input": "", "output": "Function: ts_std\n\nRolling standard deviation (STD).", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "general"}
{"instruction": "Explain the Ts Count function", "input": "", "output": "Function: ts_count\n\nCount True values in rolling window.", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "general"}
{"instruction": "Explain the Decay Linear function", "input": "", "output": "Function: decay_linear\n\nLinear decay weighted average (DECAYLINEAR).", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "general"}
{"instruction": "What is the formula for Sma?", "input": "", "output": "SMA(A, n, m) = (A * m + DELAY(SMA, 1) * (n - m)) / n\nExponential moving average variant.", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "risk"}
{"instruction": "Explain the Sma function", "input": "", "output": "Function: sma\n\nSMA(A, n, m) = (A * m + DELAY(SMA, 1) * (n - m)) / n\nExponential moving average variant.", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "risk"}
{"instruction": "Explain the Wma function", "input": "", "output": "Function: wma\n\nWeighted moving average.", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "general"}
{"instruction": "Explain the Sign function", "input": "", "output": "Function: sign\n\nSign function.", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "general"}
{"instruction": "Explain the Log function", "input": "", "output": "Function: log\n\nNatural log.", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "general"}
{"instruction": "Explain the Abs  function", "input": "", "output": "Function: abs_\n\nAbsolute value.", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "general"}
{"instruction": "Explain the Regbeta function", "input": "", "output": "Function: regbeta\n\nRolling regression beta coefficient.", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "general"}
{"instruction": "What is the formula for Alpha 1?", "input": "", "output": "(-1 * CORR(RANK(DELTA(LOG(VOLUME), 1)), RANK((CLOSE - OPEN) / OPEN), 6))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 1 function", "input": "", "output": "Function: alpha001\n\n(-1 * CORR(RANK(DELTA(LOG(VOLUME), 1)), RANK((CLOSE - OPEN) / OPEN), 6))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 2?", "input": "", "output": "(-1 * DELTA((((CLOSE - LOW) - (HIGH - CLOSE)) / (HIGH - LOW)), 1))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 2 function", "input": "", "output": "Function: alpha002\n\n(-1 * DELTA((((CLOSE - LOW) - (HIGH - CLOSE)) / (HIGH - LOW)), 1))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 3 function", "input": "", "output": "Function: alpha003\n\nSUM(conditional spread adjustments based on CLOSE vs DELAY)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 4?", "input": "", "output": "Complex conditional based on 8-day vs 2-day averages and volume ratios", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 4 function", "input": "", "output": "Function: alpha004\n\nComplex conditional based on 8-day vs 2-day averages and volume ratios", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 5?", "input": "", "output": "(-1 * TSMAX(CORR(TSRANK(VOLUME, 5), TSRANK(HIGH, 5), 5), 3))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 5 function", "input": "", "output": "Function: alpha005\n\n(-1 * TSMAX(CORR(TSRANK(VOLUME, 5), TSRANK(HIGH, 5), 5), 3))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 6?", "input": "", "output": "(-1 * RANK(SIGN(DELTA((OPEN * 0.85 + HIGH * 0.15), 4))))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 6 function", "input": "", "output": "Function: alpha006\n\n(-1 * RANK(SIGN(DELTA((OPEN * 0.85 + HIGH * 0.15), 4))))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 7?", "input": "", "output": "(RANK(TSMAX(VWAP - CLOSE, 3)) + RANK(TSMIN(VWAP - CLOSE, 3))) * RANK(DELTA(VOLUME, 3))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 7 function", "input": "", "output": "Function: alpha007\n\n(RANK(TSMAX(VWAP - CLOSE, 3)) + RANK(TSMIN(VWAP - CLOSE, 3))) * RANK(DELTA(VOLUME, 3))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is VWAP in quantitative trading?", "input": "", "output": "VWAP (Volume-Weighted Average Price execution).\n\nImplementation details:\n(RANK(TSMAX(VWAP - CLOSE, 3)) + RANK(TSMIN(VWAP - CLOSE, 3))) * RANK(DELTA(VOLUME, 3))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 8?", "input": "", "output": "RANK(DELTA(((HIGH + LOW) / 2 * 0.2 + VWAP * 0.8), 4) * -1)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 8 function", "input": "", "output": "Function: alpha008\n\nRANK(DELTA(((HIGH + LOW) / 2 * 0.2 + VWAP * 0.8), 4) * -1)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is VWAP in quantitative trading?", "input": "", "output": "VWAP (Volume-Weighted Average Price execution).\n\nImplementation details:\nRANK(DELTA(((HIGH + LOW) / 2 * 0.2 + VWAP * 0.8), 4) * -1)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 9?", "input": "", "output": "SMA(((HIGH + LOW) / 2 - DELAY((HIGH + LOW) / 2, 1)) * (HIGH - LOW) / VOLUME, 7, 2)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 9 function", "input": "", "output": "Function: alpha009\n\nSMA(((HIGH + LOW) / 2 - DELAY((HIGH + LOW) / 2, 1)) * (HIGH - LOW) / VOLUME, 7, 2)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 10?", "input": "", "output": "RANK(TSMAX((if RET < 0 then STD(RET, 20) else CLOSE)^2, 5))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 10 function", "input": "", "output": "Function: alpha010\n\nRANK(TSMAX((if RET < 0 then STD(RET, 20) else CLOSE)^2, 5))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 11?", "input": "", "output": "SUM(((CLOSE - LOW) - (HIGH - CLOSE)) / (HIGH - LOW) * VOLUME, 6)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 11 function", "input": "", "output": "Function: alpha011\n\nSUM(((CLOSE - LOW) - (HIGH - CLOSE)) / (HIGH - LOW) * VOLUME, 6)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 12?", "input": "", "output": "RANK(OPEN - SUM(VWAP, 10) / 10) * -1 * RANK(ABS(CLOSE - VWAP))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 12 function", "input": "", "output": "Function: alpha012\n\nRANK(OPEN - SUM(VWAP, 10) / 10) * -1 * RANK(ABS(CLOSE - VWAP))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is VWAP in quantitative trading?", "input": "", "output": "VWAP (Volume-Weighted Average Price execution).\n\nImplementation details:\nRANK(OPEN - SUM(VWAP, 10) / 10) * -1 * RANK(ABS(CLOSE - VWAP))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 13?", "input": "", "output": "(HIGH * LOW)^0.5 - VWAP", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 13 function", "input": "", "output": "Function: alpha013\n\n(HIGH * LOW)^0.5 - VWAP", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is VWAP in quantitative trading?", "input": "", "output": "VWAP (Volume-Weighted Average Price execution).\n\nImplementation details:\n(HIGH * LOW)^0.5 - VWAP", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 14?", "input": "", "output": "CLOSE - DELAY(CLOSE, 5)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 14 function", "input": "", "output": "Function: alpha014\n\nCLOSE - DELAY(CLOSE, 5)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 15?", "input": "", "output": "OPEN / DELAY(CLOSE, 1) - 1", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 15 function", "input": "", "output": "Function: alpha015\n\nOPEN / DELAY(CLOSE, 1) - 1", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 16?", "input": "", "output": "(-1 * TSMAX(RANK(CORR(RANK(VOLUME), RANK(VWAP), 5)), 5))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 16 function", "input": "", "output": "Function: alpha016\n\n(-1 * TSMAX(RANK(CORR(RANK(VOLUME), RANK(VWAP), 5)), 5))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is VWAP in quantitative trading?", "input": "", "output": "VWAP (Volume-Weighted Average Price execution).\n\nImplementation details:\n(-1 * TSMAX(RANK(CORR(RANK(VOLUME), RANK(VWAP), 5)), 5))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 17?", "input": "", "output": "RANK(VWAP - TSMAX(VWAP, 15))^DELTA(CLOSE, 5)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 17 function", "input": "", "output": "Function: alpha017\n\nRANK(VWAP - TSMAX(VWAP, 15))^DELTA(CLOSE, 5)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is VWAP in quantitative trading?", "input": "", "output": "VWAP (Volume-Weighted Average Price execution).\n\nImplementation details:\nRANK(VWAP - TSMAX(VWAP, 15))^DELTA(CLOSE, 5)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 18?", "input": "", "output": "CLOSE / DELAY(CLOSE, 5)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 18 function", "input": "", "output": "Function: alpha018\n\nCLOSE / DELAY(CLOSE, 5)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 19?", "input": "", "output": "Conditional: if CLOSE < DELAY then ratio1, elif CLOSE = DELAY then 0, else ratio2", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 19 function", "input": "", "output": "Function: alpha019\n\nConditional: if CLOSE < DELAY then ratio1, elif CLOSE = DELAY then 0, else ratio2", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 20?", "input": "", "output": "(CLOSE - DELAY(CLOSE, 6)) / DELAY(CLOSE, 6) * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 20 function", "input": "", "output": "Function: alpha020\n\n(CLOSE - DELAY(CLOSE, 6)) / DELAY(CLOSE, 6) * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 21 function", "input": "", "output": "Function: alpha021\n\nREGBETA(MEAN(CLOSE, 6), SEQUENCE(6))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 22?", "input": "", "output": "SMA(((CLOSE - MEAN(CLOSE, 6)) / MEAN(CLOSE, 6) - DELAY(..., 3)), 12, 1)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 22 function", "input": "", "output": "Function: alpha022\n\nSMA(((CLOSE - MEAN(CLOSE, 6)) / MEAN(CLOSE, 6) - DELAY(..., 3)), 12, 1)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 23?", "input": "", "output": "Ratio of up-volatility to total volatility, scaled to 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 23 function", "input": "", "output": "Function: alpha023\n\nRatio of up-volatility to total volatility, scaled to 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 24?", "input": "", "output": "SMA(CLOSE - DELAY(CLOSE, 5), 5, 1)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 24 function", "input": "", "output": "Function: alpha024\n\nSMA(CLOSE - DELAY(CLOSE, 5), 5, 1)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 25?", "input": "", "output": "Complex: (-1 * RANK(DELTA(CLOSE, 7) * (1 - RANK(DECAYLINEAR(...))))) * (1 + RANK(SUM(RET, 250)))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 25 function", "input": "", "output": "Function: alpha025\n\nComplex: (-1 * RANK(DELTA(CLOSE, 7) * (1 - RANK(DECAYLINEAR(...))))) * (1 + RANK(SUM(RET, 250)))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 26?", "input": "", "output": "(SUM(CLOSE, 7) / 7 - CLOSE) + CORR(VWAP, DELAY(CLOSE, 5), 230)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 26 function", "input": "", "output": "Function: alpha026\n\n(SUM(CLOSE, 7) / 7 - CLOSE) + CORR(VWAP, DELAY(CLOSE, 5), 230)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is VWAP in quantitative trading?", "input": "", "output": "VWAP (Volume-Weighted Average Price execution).\n\nImplementation details:\n(SUM(CLOSE, 7) / 7 - CLOSE) + CORR(VWAP, DELAY(CLOSE, 5), 230)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 27 function", "input": "", "output": "Function: alpha027\n\nWMA of price change percentages over 3 and 6 days", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 28?", "input": "", "output": "Triple EMA-based Stochastic variant", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 28 function", "input": "", "output": "Function: alpha028\n\nTriple EMA-based Stochastic variant", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 29?", "input": "", "output": "(CLOSE - DELAY(CLOSE, 6)) / DELAY(CLOSE, 6) * VOLUME", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 29 function", "input": "", "output": "Function: alpha029\n\n(CLOSE - DELAY(CLOSE, 6)) / DELAY(CLOSE, 6) * VOLUME", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 30?", "input": "", "output": "Regression-based - simplified", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 30 function", "input": "", "output": "Function: alpha030\n\nRegression-based - simplified", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 31?", "input": "", "output": "(CLOSE - MEAN(CLOSE, 12)) / MEAN(CLOSE, 12) * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 31 function", "input": "", "output": "Function: alpha031\n\n(CLOSE - MEAN(CLOSE, 12)) / MEAN(CLOSE, 12) * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 32?", "input": "", "output": "(-1 * SUM(RANK(CORR(RANK(HIGH), RANK(VOLUME), 3)), 3))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 32 function", "input": "", "output": "Function: alpha032\n\n(-1 * SUM(RANK(CORR(RANK(HIGH), RANK(VOLUME), 3)), 3))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 33?", "input": "", "output": "Multi-component formula with returns range ratios", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 33 function", "input": "", "output": "Function: alpha033\n\nMulti-component formula with returns range ratios", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 34?", "input": "", "output": "MEAN(CLOSE, 12) / CLOSE", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 34 function", "input": "", "output": "Function: alpha034\n\nMEAN(CLOSE, 12) / CLOSE", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 35?", "input": "", "output": "MIN of decay-linear ranks", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 35 function", "input": "", "output": "Function: alpha035\n\nMIN of decay-linear ranks", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 36 function", "input": "", "output": "Function: alpha036\n\nRANK(SUM(CORR(RANK(VOLUME), RANK(VWAP), 6), 2))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is VWAP in quantitative trading?", "input": "", "output": "VWAP (Volume-Weighted Average Price execution).\n\nImplementation details:\nRANK(SUM(CORR(RANK(VOLUME), RANK(VWAP), 6), 2))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 37?", "input": "", "output": "(-1 * RANK(SUM(OPEN, 5) * SUM(RET, 5) - DELAY(..., 10)))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 37 function", "input": "", "output": "Function: alpha037\n\n(-1 * RANK(SUM(OPEN, 5) * SUM(RET, 5) - DELAY(..., 10)))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 38?", "input": "", "output": "Conditional: if MA(HIGH, 20) < HIGH then -1 * DELTA(HIGH, 2) else 0", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 38 function", "input": "", "output": "Function: alpha038\n\nConditional: if MA(HIGH, 20) < HIGH then -1 * DELTA(HIGH, 2) else 0", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 39?", "input": "", "output": "Difference of decay-linear correlations with negation", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 39 function", "input": "", "output": "Function: alpha039\n\nDifference of decay-linear correlations with negation", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 40?", "input": "", "output": "SUM(up volume, 26) / SUM(down volume, 26) * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 40 function", "input": "", "output": "Function: alpha040\n\nSUM(up volume, 26) / SUM(down volume, 26) * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 41?", "input": "", "output": "RANK(TSMAX(DELTA(VWAP, 3), 5)) * -1", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 41 function", "input": "", "output": "Function: alpha041\n\nRANK(TSMAX(DELTA(VWAP, 3), 5)) * -1", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is VWAP in quantitative trading?", "input": "", "output": "VWAP (Volume-Weighted Average Price execution).\n\nImplementation details:\nRANK(TSMAX(DELTA(VWAP, 3), 5)) * -1", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 42?", "input": "", "output": "(-1 * RANK(STD(HIGH, 10))) * CORR(HIGH, VOLUME, 10)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 42 function", "input": "", "output": "Function: alpha042\n\n(-1 * RANK(STD(HIGH, 10))) * CORR(HIGH, VOLUME, 10)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 43 function", "input": "", "output": "Function: alpha043\n\nDirectional volume accumulation over 6 days", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 44?", "input": "", "output": "Sum of decay-linear Tsrank measures", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 44 function", "input": "", "output": "Function: alpha044\n\nSum of decay-linear Tsrank measures", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 45?", "input": "", "output": "RANK(DELTA(...)) * RANK(CORR(VWAP, MEAN(VOLUME, 150), 15))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 45 function", "input": "", "output": "Function: alpha045\n\nRANK(DELTA(...)) * RANK(CORR(VWAP, MEAN(VOLUME, 150), 15))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is VWAP in quantitative trading?", "input": "", "output": "VWAP (Volume-Weighted Average Price execution).\n\nImplementation details:\nRANK(DELTA(...)) * RANK(CORR(VWAP, MEAN(VOLUME, 150), 15))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 46?", "input": "", "output": "(MEAN(CLOSE, 3) + MEAN(CLOSE, 6) + MEAN(CLOSE, 12) + MEAN(CLOSE, 24)) / (4 * CLOSE)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 46 function", "input": "", "output": "Function: alpha046\n\n(MEAN(CLOSE, 3) + MEAN(CLOSE, 6) + MEAN(CLOSE, 12) + MEAN(CLOSE, 24)) / (4 * CLOSE)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 47?", "input": "", "output": "SMA(stochastic-like formula, 9, 1)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 47 function", "input": "", "output": "Function: alpha047\n\nSMA(stochastic-like formula, 9, 1)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 48 function", "input": "", "output": "Function: alpha048\n\nComplex ranking of momentum and volume patterns", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 49?", "input": "", "output": "Ratio measuring uptrend dominance - DTM/DBM calculation", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 49 function", "input": "", "output": "Function: alpha049\n\nRatio measuring uptrend dominance - DTM/DBM calculation", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 50 function", "input": "", "output": "Function: alpha050\n\nNet difference between uptrend and downtrend measures", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 51 function", "input": "", "output": "Function: alpha051\n\nUptrend strength ratio", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 52?", "input": "", "output": "SUM(MAX(HIGH - delayed midpoint, 0), 26) / SUM(MAX(...), 26)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 52 function", "input": "", "output": "Function: alpha052\n\nSUM(MAX(HIGH - delayed midpoint, 0), 26) / SUM(MAX(...), 26)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 53?", "input": "", "output": "COUNT(CLOSE > DELAY(CLOSE, 1), 12) / 12 * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 53 function", "input": "", "output": "Function: alpha053\n\nCOUNT(CLOSE > DELAY(CLOSE, 1), 12) / 12 * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 54?", "input": "", "output": "-1 * RANK(STD(ABS(CLOSE - OPEN)) + (CLOSE - OPEN) + CORR(CLOSE, OPEN, 10))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 54 function", "input": "", "output": "Function: alpha054\n\n-1 * RANK(STD(ABS(CLOSE - OPEN)) + (CLOSE - OPEN) + CORR(CLOSE, OPEN, 10))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 55 function", "input": "", "output": "Function: alpha055\n\nComplex true range and momentum normalization", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 56 function", "input": "", "output": "Function: alpha056\n\nConditional rank comparison", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 57 function", "input": "", "output": "Function: alpha057\n\nSMA(stochastic formula, 3, 1)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 58?", "input": "", "output": "COUNT(CLOSE > DELAY(CLOSE, 1), 20) / 20 * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 58 function", "input": "", "output": "Function: alpha058\n\nCOUNT(CLOSE > DELAY(CLOSE, 1), 20) / 20 * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 59 function", "input": "", "output": "Function: alpha059\n\nSUM of conditional spread adjustments, 20", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 60?", "input": "", "output": "SUM(normalized volume-weighted spread, 20)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 60 function", "input": "", "output": "Function: alpha060\n\nSUM(normalized volume-weighted spread, 20)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 61?", "input": "", "output": "MAX(RANK(DECAYLINEAR(...)), RANK(...)) * -1", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 61 function", "input": "", "output": "Function: alpha061\n\nMAX(RANK(DECAYLINEAR(...)), RANK(...)) * -1", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 62?", "input": "", "output": "(-1 * CORR(HIGH, RANK(VOLUME), 5))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 62 function", "input": "", "output": "Function: alpha062\n\n(-1 * CORR(HIGH, RANK(VOLUME), 5))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 63?", "input": "", "output": "SMA(MAX(delta, 0), 6, 1) / SMA(ABS(delta), 6, 1) * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 63 function", "input": "", "output": "Function: alpha063\n\nSMA(MAX(delta, 0), 6, 1) / SMA(ABS(delta), 6, 1) * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 64?", "input": "", "output": "Complex decay-linear correlation ranks", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 64 function", "input": "", "output": "Function: alpha064\n\nComplex decay-linear correlation ranks", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 65?", "input": "", "output": "MEAN(CLOSE, 6) / CLOSE", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 65 function", "input": "", "output": "Function: alpha065\n\nMEAN(CLOSE, 6) / CLOSE", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 66?", "input": "", "output": "(CLOSE - MEAN(CLOSE, 6)) / MEAN(CLOSE, 6) * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 66 function", "input": "", "output": "Function: alpha066\n\n(CLOSE - MEAN(CLOSE, 6)) / MEAN(CLOSE, 6) * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 67?", "input": "", "output": "SMA(MAX(delta, 0), 24, 1) / SMA(ABS(delta), 24, 1) * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 67 function", "input": "", "output": "Function: alpha067\n\nSMA(MAX(delta, 0), 24, 1) / SMA(ABS(delta), 24, 1) * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 68?", "input": "", "output": "SMA(midpoint change * range / volume, 15, 2)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 68 function", "input": "", "output": "Function: alpha068\n\nSMA(midpoint change * range / volume, 15, 2)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 69 function", "input": "", "output": "Function: alpha069\n\nDirectional trend measurement (DTM vs DBM)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 70 function", "input": "", "output": "Function: alpha070\n\nSTD(AMOUNT, 6)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 71?", "input": "", "output": "(CLOSE - MEAN(CLOSE, 24)) / MEAN(CLOSE, 24) * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 71 function", "input": "", "output": "Function: alpha071\n\n(CLOSE - MEAN(CLOSE, 24)) / MEAN(CLOSE, 24) * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 72 function", "input": "", "output": "Function: alpha072\n\nSMA(stochastic formula, 15, 1)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 73?", "input": "", "output": "Nested decay-linear correlation ranks", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 73 function", "input": "", "output": "Function: alpha073\n\nNested decay-linear correlation ranks", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 74 function", "input": "", "output": "Function: alpha074\n\nSum of correlation ranks", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 75?", "input": "", "output": "COUNT(matched direction with index, 50) / COUNT(index down, 50)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 75 function", "input": "", "output": "Function: alpha075\n\nCOUNT(matched direction with index, 50) / COUNT(index down, 50)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 76?", "input": "", "output": "STD(normalized volume-price, 20) / MEAN(normalized volume-price, 20)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 76 function", "input": "", "output": "Function: alpha076\n\nSTD(normalized volume-price, 20) / MEAN(normalized volume-price, 20)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 77 function", "input": "", "output": "Function: alpha077\n\nMIN(RANK(DECAYLINEAR(...)), RANK(...))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 78?", "input": "", "output": "((midpoint - MA(midpoint, 12)) / (normalized range))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 78 function", "input": "", "output": "Function: alpha078\n\n((midpoint - MA(midpoint, 12)) / (normalized range))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 79?", "input": "", "output": "SMA(MAX(delta, 0), 12, 1) / SMA(ABS(delta), 12, 1) * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 79 function", "input": "", "output": "Function: alpha079\n\nSMA(MAX(delta, 0), 12, 1) / SMA(ABS(delta), 12, 1) * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 80?", "input": "", "output": "(VOLUME - DELAY(VOLUME, 5)) / DELAY(VOLUME, 5) * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 80 function", "input": "", "output": "Function: alpha080\n\n(VOLUME - DELAY(VOLUME, 5)) / DELAY(VOLUME, 5) * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 81 function", "input": "", "output": "Function: alpha081\n\nSMA(VOLUME, 21, 2)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 82 function", "input": "", "output": "Function: alpha082\n\nSMA(stochastic formula, 20, 1)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 83?", "input": "", "output": "(-1 * RANK(COV(RANK(HIGH), RANK(VOLUME), 5)))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 83 function", "input": "", "output": "Function: alpha083\n\n(-1 * RANK(COV(RANK(HIGH), RANK(VOLUME), 5)))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 84 function", "input": "", "output": "Function: alpha084\n\nDirectional volume accumulation over 20 days", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 85?", "input": "", "output": "TSRANK(volume normalized, 20) * TSRANK(-delta, 8)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 85 function", "input": "", "output": "Function: alpha085\n\nTSRANK(volume normalized, 20) * TSRANK(-delta, 8)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 86 function", "input": "", "output": "Function: alpha086\n\nConditional momentum adjustment logic", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 87?", "input": "", "output": "Complex decay-linear VWAP-based formula", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 87 function", "input": "", "output": "Function: alpha087\n\nComplex decay-linear VWAP-based formula", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is VWAP in quantitative trading?", "input": "", "output": "VWAP (Volume-Weighted Average Price execution).\n\nImplementation details:\nComplex decay-linear VWAP-based formula", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 88?", "input": "", "output": "(CLOSE - DELAY(CLOSE, 20)) / DELAY(CLOSE, 20) * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 88 function", "input": "", "output": "Function: alpha088\n\n(CLOSE - DELAY(CLOSE, 20)) / DELAY(CLOSE, 20) * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 89?", "input": "", "output": "MACD-like: 2 * (SMA13 - SMA27 - SMA(SMA13 - SMA27, 10))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 89 function", "input": "", "output": "Function: alpha089\n\nMACD-like: 2 * (SMA13 - SMA27 - SMA(SMA13 - SMA27, 10))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 90?", "input": "", "output": "RANK(CORR(RANK(VWAP), RANK(VOLUME), 5)) * -1", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 90 function", "input": "", "output": "Function: alpha090\n\nRANK(CORR(RANK(VWAP), RANK(VOLUME), 5)) * -1", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is VWAP in quantitative trading?", "input": "", "output": "VWAP (Volume-Weighted Average Price execution).\n\nImplementation details:\nRANK(CORR(RANK(VWAP), RANK(VOLUME), 5)) * -1", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 91?", "input": "", "output": "RANK((CLOSE - TSMAX(CLOSE, 5))) * RANK(CORR(...)) * -1", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 91 function", "input": "", "output": "Function: alpha091\n\nRANK((CLOSE - TSMAX(CLOSE, 5))) * RANK(CORR(...)) * -1", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 92?", "input": "", "output": "MAX(RANK(DECAYLINEAR(...)), TSRANK(...)) * -1", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 92 function", "input": "", "output": "Function: alpha092\n\nMAX(RANK(DECAYLINEAR(...)), TSRANK(...)) * -1", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 93?", "input": "", "output": "SUM(conditional open-low spreads, 20)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 93 function", "input": "", "output": "Function: alpha093\n\nSUM(conditional open-low spreads, 20)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 94 function", "input": "", "output": "Function: alpha094\n\nDirectional volume accumulation over 30 days", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 95 function", "input": "", "output": "Function: alpha095\n\nSTD(AMOUNT, 20)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 96 function", "input": "", "output": "Function: alpha096\n\nDouble SMA of stochastic formula", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 97 function", "input": "", "output": "Function: alpha097\n\nSTD(VOLUME, 10)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 98 function", "input": "", "output": "Function: alpha098\n\nConditional: if MA change < 5% then MIN spread else DELTA(CLOSE, 3)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 99?", "input": "", "output": "(-1 * RANK(COV(RANK(CLOSE), RANK(VOLUME), 5)))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 99 function", "input": "", "output": "Function: alpha099\n\n(-1 * RANK(COV(RANK(CLOSE), RANK(VOLUME), 5)))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 100 function", "input": "", "output": "Function: alpha100\n\nSTD(VOLUME, 20)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 101 function", "input": "", "output": "Function: alpha101\n\nConditional comparison of correlation ranks", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 102?", "input": "", "output": "SMA(MAX(vol delta, 0), 6, 1) / SMA(ABS(vol delta), 6, 1) * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 102 function", "input": "", "output": "Function: alpha102\n\nSMA(MAX(vol delta, 0), 6, 1) / SMA(ABS(vol delta), 6, 1) * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 103?", "input": "", "output": "((20 - LOWDAY(LOW, 20)) / 20) * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 103 function", "input": "", "output": "Function: alpha103\n\n((20 - LOWDAY(LOW, 20)) / 20) * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 104?", "input": "", "output": "(-1 * (DELTA(CORR(HIGH, VOLUME, 5), 5) * RANK(STD(CLOSE, 20))))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 104 function", "input": "", "output": "Function: alpha104\n\n(-1 * (DELTA(CORR(HIGH, VOLUME, 5), 5) * RANK(STD(CLOSE, 20))))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 105?", "input": "", "output": "(-1 * CORR(RANK(OPEN), RANK(VOLUME), 10))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 105 function", "input": "", "output": "Function: alpha105\n\n(-1 * CORR(RANK(OPEN), RANK(VOLUME), 10))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 106?", "input": "", "output": "CLOSE - DELAY(CLOSE, 20)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 106 function", "input": "", "output": "Function: alpha106\n\nCLOSE - DELAY(CLOSE, 20)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 107?", "input": "", "output": "(-1 * RANK(OPEN - DELAY(HIGH, 1)) * RANK(...) * RANK(...))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 107 function", "input": "", "output": "Function: alpha107\n\n(-1 * RANK(OPEN - DELAY(HIGH, 1)) * RANK(...) * RANK(...))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 108?", "input": "", "output": "(RANK(HIGH - TSMIN(HIGH, 2))^RANK(CORR(...))) * -1", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 108 function", "input": "", "output": "Function: alpha108\n\n(RANK(HIGH - TSMIN(HIGH, 2))^RANK(CORR(...))) * -1", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 109?", "input": "", "output": "SMA(HIGH - LOW, 10, 2) / SMA(SMA(...), 10, 2)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 109 function", "input": "", "output": "Function: alpha109\n\nSMA(HIGH - LOW, 10, 2) / SMA(SMA(...), 10, 2)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 110?", "input": "", "output": "SUM(MAX(HIGH - delayed close, 0), 20) / SUM(MAX(...), 20) * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 110 function", "input": "", "output": "Function: alpha110\n\nSUM(MAX(HIGH - delayed close, 0), 20) / SUM(MAX(...), 20) * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 111?", "input": "", "output": "Difference of volume-weighted stochastic SMAs", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 111 function", "input": "", "output": "Function: alpha111\n\nDifference of volume-weighted stochastic SMAs", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 112 function", "input": "", "output": "Function: alpha112\n\nUp momentum ratio to total momentum", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 113?", "input": "", "output": "(-1 * RANK(delayed average) * CORR(...) * RANK(CORR(...)))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 113 function", "input": "", "output": "Function: alpha113\n\n(-1 * RANK(delayed average) * CORR(...) * RANK(CORR(...)))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 114 function", "input": "", "output": "Function: alpha114\n\nComplex normalization of ranked ranges and volume", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 115?", "input": "", "output": "RANK(correlation)^RANK(correlation)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 115 function", "input": "", "output": "Function: alpha115\n\nRANK(correlation)^RANK(correlation)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 116 function", "input": "", "output": "Function: alpha116\n\nREGBETA(CLOSE, SEQUENCE(20))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 117 function", "input": "", "output": "Function: alpha117\n\nProduct of three Tsrank components", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 118?", "input": "", "output": "SUM(HIGH - OPEN, 20) / SUM(OPEN - LOW, 20) * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 118 function", "input": "", "output": "Function: alpha118\n\nSUM(HIGH - OPEN, 20) / SUM(OPEN - LOW, 20) * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 119?", "input": "", "output": "Difference of complex decay-linear measures", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 119 function", "input": "", "output": "Function: alpha119\n\nDifference of complex decay-linear measures", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 120?", "input": "", "output": "RANK(VWAP - CLOSE) / RANK(VWAP + CLOSE)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 120 function", "input": "", "output": "Function: alpha120\n\nRANK(VWAP - CLOSE) / RANK(VWAP + CLOSE)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is VWAP in quantitative trading?", "input": "", "output": "VWAP (Volume-Weighted Average Price execution).\n\nImplementation details:\nRANK(VWAP - CLOSE) / RANK(VWAP + CLOSE)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 121?", "input": "", "output": "(RANK(VWAP - TSMIN(VWAP, 12))^TSRANK(...)) * -1", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 121 function", "input": "", "output": "Function: alpha121\n\n(RANK(VWAP - TSMIN(VWAP, 12))^TSRANK(...)) * -1", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is VWAP in quantitative trading?", "input": "", "output": "VWAP (Volume-Weighted Average Price execution).\n\nImplementation details:\n(RANK(VWAP - TSMIN(VWAP, 12))^TSRANK(...)) * -1", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 122 function", "input": "", "output": "Function: alpha122\n\nTriple SMA log derivative normalized", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 123?", "input": "", "output": "Conditional: if correlation rank1 < rank2 then -1 else 0", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 123 function", "input": "", "output": "Function: alpha123\n\nConditional: if correlation rank1 < rank2 then -1 else 0", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 124?", "input": "", "output": "(CLOSE - VWAP) / DECAYLINEAR(RANK(TSMAX(CLOSE, 30)), 2)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 124 function", "input": "", "output": "Function: alpha124\n\n(CLOSE - VWAP) / DECAYLINEAR(RANK(TSMAX(CLOSE, 30)), 2)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is VWAP in quantitative trading?", "input": "", "output": "VWAP (Volume-Weighted Average Price execution).\n\nImplementation details:\n(CLOSE - VWAP) / DECAYLINEAR(RANK(TSMAX(CLOSE, 30)), 2)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 125?", "input": "", "output": "Ratio of decay-linear correlation to decay-linear delta", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 125 function", "input": "", "output": "Function: alpha125\n\nRatio of decay-linear correlation to decay-linear delta", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 126?", "input": "", "output": "(CLOSE + HIGH + LOW) / 3", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 126 function", "input": "", "output": "Function: alpha126\n\n(CLOSE + HIGH + LOW) / 3", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 127?", "input": "", "output": "sqrt(MEAN((100 * price deviation / TSMAX)^2, 12))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 127 function", "input": "", "output": "Function: alpha127\n\nsqrt(MEAN((100 * price deviation / TSMAX)^2, 12))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 128?", "input": "", "output": "RSI-like formula using volume-weighted midpoints", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 128 function", "input": "", "output": "Function: alpha128\n\nRSI-like formula using volume-weighted midpoints", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 129 function", "input": "", "output": "Function: alpha129\n\nSUM(ABS(negative deltas), 12)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 130?", "input": "", "output": "Ratio of correlation-based decay-linear ranks", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 130 function", "input": "", "output": "Function: alpha130\n\nRatio of correlation-based decay-linear ranks", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 131?", "input": "", "output": "RANK(DELTA(VWAP, 1))^TSRANK(CORR(...), 18)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 131 function", "input": "", "output": "Function: alpha131\n\nRANK(DELTA(VWAP, 1))^TSRANK(CORR(...), 18)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is VWAP in quantitative trading?", "input": "", "output": "VWAP (Volume-Weighted Average Price execution).\n\nImplementation details:\nRANK(DELTA(VWAP, 1))^TSRANK(CORR(...), 18)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 132 function", "input": "", "output": "Function: alpha132\n\nMEAN(AMOUNT, 20)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 133?", "input": "", "output": "((20 - HIGHDAY(HIGH, 20)) / 20) * 100 - ((20 - LOWDAY(LOW, 20)) / 20) * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 133 function", "input": "", "output": "Function: alpha133\n\n((20 - HIGHDAY(HIGH, 20)) / 20) * 100 - ((20 - LOWDAY(LOW, 20)) / 20) * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 134?", "input": "", "output": "(CLOSE - DELAY(CLOSE, 12)) / DELAY(CLOSE, 12) * VOLUME", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 134 function", "input": "", "output": "Function: alpha134\n\n(CLOSE - DELAY(CLOSE, 12)) / DELAY(CLOSE, 12) * VOLUME", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 135 function", "input": "", "output": "Function: alpha135\n\nSMA(DELAY(price ratio, 1), 20, 1)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 136?", "input": "", "output": "(-1 * RANK(DELTA(RET, 3))) * CORR(OPEN, VOLUME, 10)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 136 function", "input": "", "output": "Function: alpha136\n\n(-1 * RANK(DELTA(RET, 3))) * CORR(OPEN, VOLUME, 10)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 137 function", "input": "", "output": "Function: alpha137\n\nComplex true range normalization with volume", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 138?", "input": "", "output": "Complex nested decay-linear and Tsrank formula", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 138 function", "input": "", "output": "Function: alpha138\n\nComplex nested decay-linear and Tsrank formula", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 139?", "input": "", "output": "(-1 * CORR(OPEN, VOLUME, 10))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 139 function", "input": "", "output": "Function: alpha139\n\n(-1 * CORR(OPEN, VOLUME, 10))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 140 function", "input": "", "output": "Function: alpha140\n\nMIN(RANK(DECAYLINEAR(...)), TSRANK(...))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 141?", "input": "", "output": "RANK(CORR(RANK(HIGH), RANK(MEAN(VOLUME, 15)), 9)) * -1", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 141 function", "input": "", "output": "Function: alpha141\n\nRANK(CORR(RANK(HIGH), RANK(MEAN(VOLUME, 15)), 9)) * -1", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 142?", "input": "", "output": "(-1 * RANK(TSRANK(CLOSE, 10))) * RANK(second delta) * RANK(...)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 142 function", "input": "", "output": "Function: alpha142\n\n(-1 * RANK(TSRANK(CLOSE, 10))) * RANK(second delta) * RANK(...)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 143 function", "input": "", "output": "Function: alpha143\n\nReturns 0 (unimplemented)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 144?", "input": "", "output": "SUMIF(normalized volume-price, 20, condition) / COUNT(condition, 20)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 144 function", "input": "", "output": "Function: alpha144\n\nSUMIF(normalized volume-price, 20, condition) / COUNT(condition, 20)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 145?", "input": "", "output": "(MEAN(VOL, 9) - MEAN(VOL, 26)) / MEAN(VOL, 12) * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 145 function", "input": "", "output": "Function: alpha145\n\n(MEAN(VOL, 9) - MEAN(VOL, 26)) / MEAN(VOL, 12) * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 146 function", "input": "", "output": "Function: alpha146\n\nComplex deviation from SMA normalized ratio", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 147 function", "input": "", "output": "Function: alpha147\n\nREGBETA(MEAN(CLOSE, 12), SEQUENCE(12))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 148?", "input": "", "output": "Conditional: if correlation rank < open rank then -1 else 0", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 148 function", "input": "", "output": "Function: alpha148\n\nConditional: if correlation rank < open rank then -1 else 0", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 149?", "input": "", "output": "Returns 0 (filter-based, incomplete)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 149 function", "input": "", "output": "Function: alpha149\n\nReturns 0 (filter-based, incomplete)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 150?", "input": "", "output": "(CLOSE + HIGH + LOW) / 3 * VOLUME", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 150 function", "input": "", "output": "Function: alpha150\n\n(CLOSE + HIGH + LOW) / 3 * VOLUME", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 151?", "input": "", "output": "SMA(CLOSE - DELAY(CLOSE, 20), 20, 1)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 151 function", "input": "", "output": "Function: alpha151\n\nSMA(CLOSE - DELAY(CLOSE, 20), 20, 1)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 152 function", "input": "", "output": "Function: alpha152\n\nComplex nested SMA and delayed formulas", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 153?", "input": "", "output": "(MEAN(CLOSE, 3) + MEAN(CLOSE, 6) + MEAN(CLOSE, 12) + MEAN(CLOSE, 24)) / 4", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 153 function", "input": "", "output": "Function: alpha153\n\n(MEAN(CLOSE, 3) + MEAN(CLOSE, 6) + MEAN(CLOSE, 12) + MEAN(CLOSE, 24)) / 4", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 154?", "input": "", "output": "Conditional: if (VWAP - TSMIN) < CORR then 1 else 0", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 154 function", "input": "", "output": "Function: alpha154\n\nConditional: if (VWAP - TSMIN) < CORR then 1 else 0", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is VWAP in quantitative trading?", "input": "", "output": "VWAP (Volume-Weighted Average Price execution).\n\nImplementation details:\nConditional: if (VWAP - TSMIN) < CORR then 1 else 0", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 155?", "input": "", "output": "MACD-like volume formula", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 155 function", "input": "", "output": "Function: alpha155\n\nMACD-like volume formula", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 156?", "input": "", "output": "MAX(RANK(DECAYLINEAR(...)), RANK(...)) * -1", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 156 function", "input": "", "output": "Function: alpha156\n\nMAX(RANK(DECAYLINEAR(...)), RANK(...)) * -1", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 157 function", "input": "", "output": "Function: alpha157\n\nComplex nested products and log transformations", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 158?", "input": "", "output": "((HIGH - SMA(CLOSE, 15, 2)) - (LOW - SMA(CLOSE, 15, 2))) / CLOSE", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 158 function", "input": "", "output": "Function: alpha158\n\n((HIGH - SMA(CLOSE, 15, 2)) - (LOW - SMA(CLOSE, 15, 2))) / CLOSE", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 159?", "input": "", "output": "Weighted multi-period Stochastic formula", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 159 function", "input": "", "output": "Function: alpha159\n\nWeighted multi-period Stochastic formula", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 160 function", "input": "", "output": "Function: alpha160\n\nSMA(conditional STD, 20, 1)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 161 function", "input": "", "output": "Function: alpha161\n\nMEAN(MAX series, 12)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 162 function", "input": "", "output": "Function: alpha162\n\nNormalized oscillator ratio formula", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 163?", "input": "", "output": "RANK(return * volume * VWAP * spread)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 163 function", "input": "", "output": "Function: alpha163\n\nRANK(return * volume * VWAP * spread)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is VWAP in quantitative trading?", "input": "", "output": "VWAP (Volume-Weighted Average Price execution).\n\nImplementation details:\nRANK(return * volume * VWAP * spread)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 164?", "input": "", "output": "Complex inverse-price stochastic formula", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 164 function", "input": "", "output": "Function: alpha164\n\nComplex inverse-price stochastic formula", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 165?", "input": "", "output": "(ROWMAX - ROWMIN) / STD scaling", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 165 function", "input": "", "output": "Function: alpha165\n\n(ROWMAX - ROWMIN) / STD scaling", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 166?", "input": "", "output": "Skewness-like calculation", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 166 function", "input": "", "output": "Function: alpha166\n\nSkewness-like calculation", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 167 function", "input": "", "output": "Function: alpha167\n\nSUM(positive deltas, 12)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 168?", "input": "", "output": "(-1 * VOLUME) / MEAN(VOLUME, 20)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 168 function", "input": "", "output": "Function: alpha168\n\n(-1 * VOLUME) / MEAN(VOLUME, 20)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 169 function", "input": "", "output": "Function: alpha169\n\nComplex nested delayed SMA differences", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 170?", "input": "", "output": "Multi-component ranked formula", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 170 function", "input": "", "output": "Function: alpha170\n\nMulti-component ranked formula", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 171?", "input": "", "output": "(-1 * (LOW - CLOSE) * (OPEN^5)) / ((CLOSE - HIGH) * (CLOSE^5))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 171 function", "input": "", "output": "Function: alpha171\n\n(-1 * (LOW - CLOSE) * (OPEN^5)) / ((CLOSE - HIGH) * (CLOSE^5))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 172?", "input": "", "output": "ADX-like directional measurement", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 172 function", "input": "", "output": "Function: alpha172\n\nADX-like directional measurement", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 173 function", "input": "", "output": "Function: alpha173\n\nTriple SMA triple log formula", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 174?", "input": "", "output": "SMA(conditional STD, 20, 1) - variant", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 174 function", "input": "", "output": "Function: alpha174\n\nSMA(conditional STD, 20, 1) - variant", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 175 function", "input": "", "output": "Function: alpha175\n\nMEAN(MAX series, 6)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 176 function", "input": "", "output": "Function: alpha176\n\nCORR(RANK(Stochastic), RANK(VOLUME), 6)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 177?", "input": "", "output": "((20 - HIGHDAY(HIGH, 20)) / 20) * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 177 function", "input": "", "output": "Function: alpha177\n\n((20 - HIGHDAY(HIGH, 20)) / 20) * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 178?", "input": "", "output": "(CLOSE - DELAY(CLOSE, 1)) / DELAY(CLOSE, 1) * VOLUME", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 178 function", "input": "", "output": "Function: alpha178\n\n(CLOSE - DELAY(CLOSE, 1)) / DELAY(CLOSE, 1) * VOLUME", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 179?", "input": "", "output": "Product of volume and volume-based correlation ranks", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 179 function", "input": "", "output": "Function: alpha179\n\nProduct of volume and volume-based correlation ranks", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 180?", "input": "", "output": "Conditional: if MA(VOL, 20) < VOL then Tsrank else -VOL", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 180 function", "input": "", "output": "Function: alpha180\n\nConditional: if MA(VOL, 20) < VOL then Tsrank else -VOL", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 181 function", "input": "", "output": "Function: alpha181\n\nReturn deviation correlation versus benchmark", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 182?", "input": "", "output": "COUNT(matched directions, 20) / 20", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 182 function", "input": "", "output": "Function: alpha182\n\nCOUNT(matched directions, 20) / 20", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 183?", "input": "", "output": "(ROWMAX - ROWMIN) / STD with 24-period window", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 183 function", "input": "", "output": "Function: alpha183\n\n(ROWMAX - ROWMIN) / STD with 24-period window", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 184?", "input": "", "output": "RANK(CORR(delayed spread, CLOSE, 200)) + RANK(spread)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 184 function", "input": "", "output": "Function: alpha184\n\nRANK(CORR(delayed spread, CLOSE, 200)) + RANK(spread)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 185?", "input": "", "output": "RANK((-1 * ((1 - OPEN / CLOSE)^2)))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 185 function", "input": "", "output": "Function: alpha185\n\nRANK((-1 * ((1 - OPEN / CLOSE)^2)))", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 186?", "input": "", "output": "ADX-like measurement (averaged with delay)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 186 function", "input": "", "output": "Function: alpha186\n\nADX-like measurement (averaged with delay)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 187 function", "input": "", "output": "Function: alpha187\n\nSUM(conditional open spreads, 20)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 188?", "input": "", "output": "((HIGH - LOW - SMA(HIGH - LOW, 11, 2)) / SMA(HIGH - LOW, 11, 2)) * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 188 function", "input": "", "output": "Function: alpha188\n\n((HIGH - LOW - SMA(HIGH - LOW, 11, 2)) / SMA(HIGH - LOW, 11, 2)) * 100", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 189?", "input": "", "output": "MEAN(ABS(CLOSE - MEAN(CLOSE, 6)), 6)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 189 function", "input": "", "output": "Function: alpha189\n\nMEAN(ABS(CLOSE - MEAN(CLOSE, 6)), 6)", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 190?", "input": "", "output": "Log-ratio calculation", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 190 function", "input": "", "output": "Function: alpha190\n\nLog-ratio calculation", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 191?", "input": "", "output": "(CORR(MEAN(VOL, 20), LOW, 5) + ((HIGH + LOW) / 2)) - CLOSE", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Alpha 191 function", "input": "", "output": "Function: alpha191\n\n(CORR(MEAN(VOL, 20), LOW, 5) + ((HIGH + LOW) / 2)) - CLOSE", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the Generate All Alphas function", "input": "", "output": "Function: generate_all_alphas\n\nGenerate all 191 Alpha signals.\n\nArgs:\n    df: DataFrame with OHLCV columns (open, high, low, close, volume)\n\nReturns:\n    DataFrame with alpha191_001 through alpha191_191 columns added", "source": "core\\_experimental\\alpha191_guotaijunan.py", "category": "alpha"}
{"instruction": "Explain the purpose of ARIMA/GARCH Models for HFT Forex Volatility", "input": "", "output": "ARIMA/GARCH Models for HFT Forex Volatility\n============================================\nRenaissance Technologies inference: Volatility clustering is fundamental\nto market microstructure. GARCH captures \"volatility of volatility\"\nwhich is critical for position sizing.\n\nImplemented Models:\n- ARIMA(p,d,q): Autoregressive Integrated Moving Average\n- GARCH(1,1): Generalized Autoregressive Conditional Heteroskedasticity\n- EGARCH: Exponential GARCH (asymmetric leverage effect)\n- GJR-GARCH: Threshold GARCH (news impact asymmetry)\n- Regime-Switching GARCH: HMM + GARCH combination\n\nSources:\n- Box & Jenkins (1970) \"Time Series Analysis\"\n- Bollerslev (1986) \"Generalized Autoregressive Conditional Heteroskedasticity\"\n- Nelson (1991) \"Conditional Heteroskedasticity in Asset Returns: A New Approach\"\n- Glosten, Jagannathan, Runkle (1993) \"On the Relation between Expected Value and Volatility\"\n\nWhy Renaissance Uses This:\n- Volatility clustering: High vol followed by high vol\n- Leverage effect: Negative returns increase vol more than positive\n- Position sizing: Kelly criterion needs accurate vol forecast\n- Risk management: VaR/CVaR requires conditional volatility", "source": "core\\_experimental\\arima_garch_models.py", "category": "volatility"}
{"instruction": "What is the GARCHResult class and how do I use it?", "input": "", "output": "The GARCHResult class:\n\nResult from GARCH model fitting.", "source": "core\\_experimental\\arima_garch_models.py", "category": "volatility"}
{"instruction": "What is the ARIMAResult class and how do I use it?", "input": "", "output": "The ARIMAResult class:\n\nResult from ARIMA model fitting.", "source": "core\\_experimental\\arima_garch_models.py", "category": "time_series"}
{"instruction": "What is the GARCH class and how do I use it?", "input": "", "output": "The GARCH class:\n\nGARCH(1,1) Model for conditional volatility.\n\nσ²_t = ω + α·ε²_{t-1} + β·σ²_{t-1}\n\nwhere:\n- ω > 0 (ensures positive variance)\n- α ≥ 0 (ARCH effect: shock impact)\n- β ≥ 0 (GARCH effect: persistence)\n- α + β < 1 (stationarity condition)\n\nUnconditional variance: σ² = ω / (1 - α - β)\n\nSource: Bollerslev (1986) \"Generalized Autoregressive Conditional Heteroskedasticity\"", "source": "core\\_experimental\\arima_garch_models.py", "category": "volatility"}
{"instruction": "What is the EGARCH class and how do I use it?", "input": "", "output": "The EGARCH class:\n\nExponential GARCH for asymmetric volatility.\n\nlog(σ²_t) = ω + α·[|z_{t-1}| - E|z|] + γ·z_{t-1} + β·log(σ²_{t-1})\n\nwhere z_t = ε_t / σ_t (standardized residuals)\nγ captures leverage effect: negative returns increase volatility more\n\nSource: Nelson (1991) \"Conditional Heteroskedasticity in Asset Returns\"\n\nWhy Renaissance Uses This:\n- Captures \"bad news increases volatility more than good news\"\n- No positivity constraints needed (log transformation)\n- Better fits financial return distributions", "source": "core\\_experimental\\arima_garch_models.py", "category": "volatility"}
{"instruction": "What is the GJRGARCH class and how do I use it?", "input": "", "output": "The GJRGARCH class:\n\nGJR-GARCH (Threshold GARCH) for asymmetric news impact.\n\nσ²_t = ω + α·ε²_{t-1} + γ·ε²_{t-1}·I_{t-1} + β·σ²_{t-1}\n\nwhere I_t = 1 if ε_t < 0 (bad news indicator)\n\nγ > 0 means negative returns have greater impact on volatility\n\nSource: Glosten, Jagannathan, Runkle (1993)\n\nWhy Renaissance Uses This:\n- Simpler interpretation than EGARCH\n- Directly measures \"leverage effect\"\n- Better out-of-sample forecasts in some cases", "source": "core\\_experimental\\arima_garch_models.py", "category": "volatility"}
{"instruction": "What is the RegimeSwitchingGARCH class and how do I use it?", "input": "", "output": "The RegimeSwitchingGARCH class:\n\nRegime-Switching GARCH combining HMM with GARCH.\n\nTwo regimes with different GARCH parameters:\n- Low volatility regime: low omega, high beta (persistent)\n- High volatility regime: high omega, low beta (jumpy)\n\nRenaissance Application:\n- Different market conditions need different volatility models\n- Regime detection + appropriate GARCH = better forecasts\n- Improves position sizing accuracy\n\nSource: Hamilton & Susmel (1994) \"Autoregressive Conditional Heteroskedasticity and Changes in Regime\"", "source": "core\\_experimental\\arima_garch_models.py", "category": "volatility"}
{"instruction": "What is the VolatilityForecaster class and how do I use it?", "input": "", "output": "The VolatilityForecaster class:\n\nEnsemble volatility forecaster combining multiple GARCH models.\n\nRenaissance Philosophy: \"Many weak signals combined\"\n- Run GARCH, EGARCH, GJR-GARCH in parallel\n- Combine via BIC weighting (model confidence)\n- More robust to model misspecification", "source": "core\\_experimental\\arima_garch_models.py", "category": "alpha"}
{"instruction": "What is the formula for Compute Garch Features?", "input": "", "output": "Compute GARCH-based features for HFT.\n\nArgs:\n    returns: Return series\n    annualize: Whether to annualize volatility\n    ann_factor: Annualization factor\n\nReturns:\n    DataFrame with GARCH features", "source": "core\\_experimental\\arima_garch_models.py", "category": "alpha"}
{"instruction": "Explain the Compute Garch Features function", "input": "", "output": "Function: compute_garch_features\n\nCompute GARCH-based features for HFT.\n\nArgs:\n    returns: Return series\n    annualize: Whether to annualize volatility\n    ann_factor: Annualization factor\n\nReturns:\n    DataFrame with GARCH features", "source": "core\\_experimental\\arima_garch_models.py", "category": "alpha"}
{"instruction": "What is GARCH in quantitative trading?", "input": "", "output": "GARCH (volatility forecasting model).\n\nImplementation details:\nCompute GARCH-based features for HFT.\n\nArgs:\n    returns: Return series\n    annualize: Whether to annualize volatility\n    ann_factor: Annualization factor\n\nReturns:\n    DataFrame with GARCH features", "source": "core\\_experimental\\arima_garch_models.py", "category": "alpha"}
{"instruction": "Explain the Create Garch Model function", "input": "", "output": "Function: create_garch_model\n\nCreate GARCH model.\n\nArgs:\n    model_type: 'garch', 'egarch', 'gjr', 'regime_switching', 'ensemble'", "source": "core\\_experimental\\arima_garch_models.py", "category": "volatility"}
{"instruction": "What is GARCH in quantitative trading?", "input": "", "output": "GARCH (volatility forecasting model).\n\nImplementation details:\nCreate GARCH model.\n\nArgs:\n    model_type: 'garch', 'egarch', 'gjr', 'regime_switching', 'ensemble'", "source": "core\\_experimental\\arima_garch_models.py", "category": "volatility"}
{"instruction": "Explain the Fit function", "input": "", "output": "Function: fit\n\nFit GARCH model to returns.\n\nArgs:\n    returns: Return series (not prices!)\n\nReturns:\n    GARCHResult with fitted parameters", "source": "core\\_experimental\\arima_garch_models.py", "category": "volatility"}
{"instruction": "What is GARCH in quantitative trading?", "input": "", "output": "GARCH (volatility forecasting model).\n\nImplementation details:\nFit GARCH model to returns.\n\nArgs:\n    returns: Return series (not prices!)\n\nReturns:\n    GARCHResult with fitted parameters", "source": "core\\_experimental\\arima_garch_models.py", "category": "volatility"}
{"instruction": "Explain the Forecast function", "input": "", "output": "Function: forecast\n\nForecast volatility h steps ahead.\n\nArgs:\n    horizon: Number of periods ahead\n\nReturns:\n    Array of forecasted volatilities", "source": "core\\_experimental\\arima_garch_models.py", "category": "volatility"}
{"instruction": "Explain the Fit function", "input": "", "output": "Function: fit\n\nFit EGARCH model.", "source": "core\\_experimental\\arima_garch_models.py", "category": "volatility"}
{"instruction": "What is GARCH in quantitative trading?", "input": "", "output": "GARCH (volatility forecasting model).\n\nImplementation details:\nFit EGARCH model.", "source": "core\\_experimental\\arima_garch_models.py", "category": "volatility"}
{"instruction": "Explain the Forecast function", "input": "", "output": "Function: forecast\n\nForecast volatility.", "source": "core\\_experimental\\arima_garch_models.py", "category": "volatility"}
{"instruction": "What is the formula for Fit?", "input": "", "output": "Fit GJR-GARCH model.", "source": "core\\_experimental\\arima_garch_models.py", "category": "volatility"}
{"instruction": "Explain the Fit function", "input": "", "output": "Function: fit\n\nFit GJR-GARCH model.", "source": "core\\_experimental\\arima_garch_models.py", "category": "volatility"}
{"instruction": "What is GARCH in quantitative trading?", "input": "", "output": "GARCH (volatility forecasting model).\n\nImplementation details:\nFit GJR-GARCH model.", "source": "core\\_experimental\\arima_garch_models.py", "category": "volatility"}
{"instruction": "What is the formula for Fit?", "input": "", "output": "Fit regime-switching GARCH.\n\nTwo-step approach:\n1. Detect regimes using volatility clustering\n2. Fit separate GARCH for each regime", "source": "core\\_experimental\\arima_garch_models.py", "category": "volatility"}
{"instruction": "Explain the Fit function", "input": "", "output": "Function: fit\n\nFit regime-switching GARCH.\n\nTwo-step approach:\n1. Detect regimes using volatility clustering\n2. Fit separate GARCH for each regime", "source": "core\\_experimental\\arima_garch_models.py", "category": "volatility"}
{"instruction": "What is GARCH in quantitative trading?", "input": "", "output": "GARCH (volatility forecasting model).\n\nImplementation details:\nFit regime-switching GARCH.\n\nTwo-step approach:\n1. Detect regimes using volatility clustering\n2. Fit separate GARCH for each regime", "source": "core\\_experimental\\arima_garch_models.py", "category": "volatility"}
{"instruction": "Explain the Forecast function", "input": "", "output": "Function: forecast\n\nForecast volatility given current regime.", "source": "core\\_experimental\\arima_garch_models.py", "category": "volatility"}
{"instruction": "Explain the Fit function", "input": "", "output": "Function: fit\n\nFit all models and compute weights.", "source": "core\\_experimental\\arima_garch_models.py", "category": "general"}
{"instruction": "Explain the Forecast function", "input": "", "output": "Function: forecast\n\nWeighted ensemble forecast.", "source": "core\\_experimental\\arima_garch_models.py", "category": "ensemble"}
{"instruction": "Explain the Get Current Volatility function", "input": "", "output": "Function: get_current_volatility\n\nGet weighted current volatility estimate.", "source": "core\\_experimental\\arima_garch_models.py", "category": "volatility"}
{"instruction": "What is the source paper for this technique?", "input": "", "output": "The source is: arXiv:2510.11616 (2025). ", "source": "core\\_experimental\\attention_factors.py", "category": "alpha"}
{"instruction": "Explain the purpose of Attention Factors for Statistical Arbitrage", "input": "", "output": "Attention Factors for Statistical Arbitrage\n============================================\nSource: arXiv:2510.11616 (2025)\n\"Attention Factors for Statistical Arbitrage\"\n\nKey Innovation:\n- Jointly learns tradable arbitrage factors from characteristic embeddings\n- Uses attention mechanism to combine weak signals\n- Achieved Sharpe 4.0+ on U.S. equities (24-year backtest)\n- Net of transaction costs: Sharpe 2.3\n\nFor HFT Forex:\n- Learn factors from price patterns across pairs\n- Attention weights reveal which patterns matter\n- Statistical arbitrage on correlated pairs", "source": "core\\_experimental\\attention_factors.py", "category": "alpha"}
{"instruction": "What is the AttentionFactorConfig class and how do I use it?", "input": "", "output": "The AttentionFactorConfig class:\n\nAttention Factor model configuration.", "source": "core\\_experimental\\attention_factors.py", "category": "alpha"}
{"instruction": "What is the CharacteristicEmbedding class and how do I use it?", "input": "", "output": "The CharacteristicEmbedding class:\n\nEmbed price characteristics into latent space.\n\nCharacteristics (inspired by Fama-French for equities, adapted for forex):\n- Returns at multiple horizons\n- Volatility measures\n- Momentum scores\n- Mean reversion scores\n- Relative strength", "source": "core\\_experimental\\attention_factors.py", "category": "volatility"}
{"instruction": "What is the FactorAttention class and how do I use it?", "input": "", "output": "The FactorAttention class:\n\nLearn factor portfolios via attention.\n\nFactor loadings = attention weights over characteristics.\nEach factor captures a different pattern.", "source": "core\\_experimental\\attention_factors.py", "category": "alpha"}
{"instruction": "What is the AttentionFactorModel class and how do I use it?", "input": "", "output": "The AttentionFactorModel class:\n\nAttention-based factor model for statistical arbitrage.\n\nArchitecture:\n1. Embed characteristics\n2. Temporal attention for time-varying factors\n3. Factor attention to learn portfolio weights\n4. Output: expected return signal", "source": "core\\_experimental\\attention_factors.py", "category": "alpha"}
{"instruction": "What is the AttentionFactorsForex class and how do I use it?", "input": "", "output": "The AttentionFactorsForex class:\n\nAttention Factors adapted for HFT Forex.\n\nCharacteristics (20 total):\n- Returns: 1, 5, 10, 20, 50 ticks\n- Volatility: 10, 20, 50 windows\n- Momentum: 5, 10, 20, 50 windows\n- Mean reversion: z-scores at 20, 50\n- RSI: 14, 28\n- MACD histogram\n- Spread ratio\n- Volume ratio", "source": "core\\_experimental\\attention_factors.py", "category": "alpha"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nArgs:\n    x: [B, T, C] characteristics\n\nReturns:\n    [B, T, D] embeddings", "source": "core\\_experimental\\attention_factors.py", "category": "general"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nArgs:\n    x: [B, T, D] characteristic embeddings\n\nReturns:\n    (factor_values, attention_weights)\n    factor_values: [B, T, num_factors]\n    attention_weights: [B, num_factors, T]", "source": "core\\_experimental\\attention_factors.py", "category": "alpha"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nArgs:\n    x: [B, T, C] characteristics\n\nReturns:\n    (predicted_return, factor_values, attention_weights)", "source": "core\\_experimental\\attention_factors.py", "category": "alpha"}
{"instruction": "Explain the Prepare Characteristics function", "input": "", "output": "Function: prepare_characteristics\n\nPrepare 20 characteristics from price data.", "source": "core\\_experimental\\attention_factors.py", "category": "general"}
{"instruction": "Explain the Fit function", "input": "", "output": "Function: fit\n\nTrain attention factor model.", "source": "core\\_experimental\\attention_factors.py", "category": "alpha"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nPredict return and get factor exposures.\n\nReturns:\n    Dict with predicted return, factors, and top characteristics", "source": "core\\_experimental\\attention_factors.py", "category": "alpha"}
{"instruction": "Explain the Get Factor Loadings function", "input": "", "output": "Function: get_factor_loadings\n\nGet factor loadings (for interpretability).", "source": "core\\_experimental\\attention_factors.py", "category": "alpha"}
{"instruction": "Explain the purpose of Chinese HFT Factors - Gold Standard Algorithms", "input": "", "output": "Chinese HFT Factors - Gold Standard Algorithms\n===============================================\nSources:\n- QuantsPlaybook (hugo2046) - 券商金工研报复现\n- QUANTAXIS (yutiansut) - 中国最大量化开源框架\n- WonderTrader - UFT 175ns延迟引擎\n- HftBacktest - 队列位置/微观价格\n\nVerified algorithms used by 幻方量化, 九坤投资, 明汯投资\n\nKey Factors:\n1. Smart Money Factor 2.0 (聪明钱因子) - 开源证券\n2. Chip Distribution (筹码分布因子) - 成交量分布\n3. Integrated OFI (集成订单流不平衡) - Cont 2014 extended\n4. Microprice - Better mid estimation\n5. Kyle Lambda - Market impact\n6. Amihud Illiquidity - 非流动性因子\n7. Trade Imbalance (Lee-Ready) - Tick分类\n8. Penny Jump Detection - 大单跟随\n9. Volume Clock Sampling - VPIN预处理\n10. LOB Pressure Factors - 订单簿压力", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "alpha"}
{"instruction": "What is the MicropriceResult class and how do I use it?", "input": "", "output": "The MicropriceResult class:\n\nMicroprice calculation result.", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "general"}
{"instruction": "What is the Microprice class and how do I use it?", "input": "", "output": "The Microprice class:\n\nMicroprice - Better mid-price estimation.\n\nSource: HftBacktest, Stoikov 2018\n\nFormula:\nmicroprice = mid + spread * imbalance / 2\n\nWhere:\nimbalance = (bid_size - ask_size) / (bid_size + ask_size)\n\nFor Forex HFT:\n- Better entry/exit price estimation\n- Reduces adverse selection\n- Improves fill simulation", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "microstructure"}
{"instruction": "What is the SmartMoneyFactor class and how do I use it?", "input": "", "output": "The SmartMoneyFactor class:\n\nSmart Money Factor 2.0 (聪明钱因子).\n\nSource: 开源证券 《市场微观结构研究系列（3）》\nReproduced in: QuantsPlaybook (hugo2046)\n\nKey insight:\n- Track large orders that move price\n- Institutional flow vs retail flow\n- Volume-weighted price impact\n\nFormula:\nS = sum(sign(ret) * volume * |ret|) / sum(volume * |ret|)\n\nFor Forex HFT:\n- Detect institutional positioning\n- Follow smart money flow\n- Avoid toxic flow", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "alpha"}
{"instruction": "What is the ChipDistributionFactor class and how do I use it?", "input": "", "output": "The ChipDistributionFactor class:\n\nChip Distribution Factor (筹码分布因子).\n\nSource: 券商金工研报, QuantsPlaybook\n\nConcept:\n- Track where volume accumulated at different prices\n- Identify support/resistance from volume profile\n- Calculate average cost basis of holders\n\nFor Forex HFT:\n- Volume-at-price analysis\n- Mean reversion to VWAP levels\n- Breakout probability estimation", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "alpha"}
{"instruction": "What is the KyleLambda class and how do I use it?", "input": "", "output": "The KyleLambda class:\n\nKyle Lambda - Market Impact Estimation.\n\nSource: Kyle (1985), verified in Chinese quant research\n\nLambda measures price impact per unit of order flow:\nDelta_P = lambda * (Buy_volume - Sell_volume)\n\nFor Forex HFT:\n- Estimate execution cost\n- Optimal order sizing\n- Detect low-impact windows", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "volatility"}
{"instruction": "What is the AmihudIlliquidity class and how do I use it?", "input": "", "output": "The AmihudIlliquidity class:\n\nAmihud Illiquidity Factor.\n\nSource: Amihud (2002), widely used in Chinese quant\n\nILLIQ = |Return| / Dollar_Volume\n\nFor Forex HFT:\n- Detect illiquid periods\n- Adjust position sizing\n- Avoid trading in low liquidity", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "alpha"}
{"instruction": "What is the IntegratedOFI class and how do I use it?", "input": "", "output": "The IntegratedOFI class:\n\nIntegrated Order Flow Imbalance.\n\nSource: Cont et al. (2014), extended in Chinese research\n\nStandard OFI:\nOFI_t = (bid_size * I(bid_up) - ask_size * I(ask_down))\n\nIntegrated version adds:\n- Multi-level aggregation\n- Decay weighting\n- Normalization by spread\n\nFor Forex HFT:\n- Primary alpha signal\n- Short-term direction prediction\n- Queue priority estimation", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "alpha"}
{"instruction": "What is the PennyJumpDetector class and how do I use it?", "input": "", "output": "The PennyJumpDetector class:\n\nPenny Jump Detection (大单跟随).\n\nSource: 知乎 HFT策略, FMZ量化\n\nStrategy:\n- Detect large \"elephant\" orders\n- Jump ahead by 1 tick\n- Profit from price impact\n\nFor Forex HFT:\n- Identify large order flow\n- Front-run when legal/ethical\n- Avoid being jumped", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "execution"}
{"instruction": "What is the VolumeClockSampler class and how do I use it?", "input": "", "output": "The VolumeClockSampler class:\n\nVolume Clock Sampling.\n\nSource: Easley et al. (VPIN paper), Chinese HFT research\n\nInstead of time-based bars, create volume-based bars.\nBenefits:\n- More samples during active periods\n- Fewer samples during quiet periods\n- Better for VPIN calculation\n\nFor Forex HFT:\n- Normalize activity across sessions\n- Improve factor calculation\n- Better regime detection", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "alpha"}
{"instruction": "What is the ChineseHFTFactorEngine class and how do I use it?", "input": "", "output": "The ChineseHFTFactorEngine class:\n\nUnified Chinese HFT Factor Engine.\n\nCombines all factors from:\n- QuantsPlaybook (券商金工)\n- QUANTAXIS\n- WonderTrader research\n- HftBacktest", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "alpha"}
{"instruction": "What is the ChineseHFTFactors class and how do I use it?", "input": "", "output": "The ChineseHFTFactors class:\n\nWrapper class for HFT Feature Engine integration.\nProvides compute_all_features() interface.", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "alpha"}
{"instruction": "Explain the Calculate function", "input": "", "output": "Function: calculate\n\nCalculate microprice from L2 data.\n\nArgs:\n    bid: Best bid price\n    ask: Best ask price\n    bid_size: Volume at best bid\n    ask_size: Volume at best ask\n\nReturns:\n    MicropriceResult with all components", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "volatility"}
{"instruction": "What is the formula for Multi Level Microprice?", "input": "", "output": "Multi-level microprice with exponential decay.\n\nArgs:\n    bids: List of (price, size) tuples\n    asks: List of (price, size) tuples\n    decay: Weight decay for deeper levels\n\nReturns:\n    Multi-level microprice", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "microstructure"}
{"instruction": "Explain the Multi Level Microprice function", "input": "", "output": "Function: multi_level_microprice\n\nMulti-level microprice with exponential decay.\n\nArgs:\n    bids: List of (price, size) tuples\n    asks: List of (price, size) tuples\n    decay: Weight decay for deeper levels\n\nReturns:\n    Multi-level microprice", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "microstructure"}
{"instruction": "Explain the Calculate function", "input": "", "output": "Function: calculate\n\nCalculate Smart Money Factor.\n\nArgs:\n    df: DataFrame with 'close', 'volume' columns\n\nReturns:\n    Series of smart money factor values", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "alpha"}
{"instruction": "What is the formula for Calculate V2?", "input": "", "output": "Smart Money Factor 2.0 - Enhanced version.\n\nImprovements:\n- Separate large vs small trades\n- Time-weighted decay\n- Volatility normalization", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "alpha"}
{"instruction": "Explain the Calculate V2 function", "input": "", "output": "Function: calculate_v2\n\nSmart Money Factor 2.0 - Enhanced version.\n\nImprovements:\n- Separate large vs small trades\n- Time-weighted decay\n- Volatility normalization", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "alpha"}
{"instruction": "What is the formula for Calculate Vwap Distance?", "input": "", "output": "Calculate distance from VWAP (Volume Weighted Average Price).\n\nReturns z-score of price relative to VWAP.", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "volatility"}
{"instruction": "Explain the Calculate Vwap Distance function", "input": "", "output": "Function: calculate_vwap_distance\n\nCalculate distance from VWAP (Volume Weighted Average Price).\n\nReturns z-score of price relative to VWAP.", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "volatility"}
{"instruction": "What is VWAP in quantitative trading?", "input": "", "output": "VWAP (Volume-Weighted Average Price execution).\n\nImplementation details:\nCalculate distance from VWAP (Volume Weighted Average Price).\n\nReturns z-score of price relative to VWAP.", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "volatility"}
{"instruction": "Explain the Calculate Volume Profile function", "input": "", "output": "Function: calculate_volume_profile\n\nCalculate volume profile metrics.\n\nReturns:\n    Dict with poc (point of control), value_area_high, value_area_low", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "volatility"}
{"instruction": "What is OFI in quantitative trading?", "input": "", "output": "OFI (Order Flow Imbalance).\n\nImplementation details:\nCalculate volume profile metrics.\n\nReturns:\n    Dict with poc (point of control), value_area_high, value_area_low", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "volatility"}
{"instruction": "What is the formula for Calculate Chip Concentration?", "input": "", "output": "Calculate chip concentration ratio.\n\nHigh concentration = potential breakout\nLow concentration = mean reversion likely", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "general"}
{"instruction": "Explain the Calculate Chip Concentration function", "input": "", "output": "Function: calculate_chip_concentration\n\nCalculate chip concentration ratio.\n\nHigh concentration = potential breakout\nLow concentration = mean reversion likely", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "general"}
{"instruction": "What is the formula for Estimate Lambda?", "input": "", "output": "Estimate Kyle's Lambda using regression.\n\nLambda = Cov(ret, signed_volume) / Var(signed_volume)", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "volatility"}
{"instruction": "Explain the Estimate Lambda function", "input": "", "output": "Function: estimate_lambda\n\nEstimate Kyle's Lambda using regression.\n\nLambda = Cov(ret, signed_volume) / Var(signed_volume)", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "volatility"}
{"instruction": "What is the formula for Estimate Permanent Impact?", "input": "", "output": "Estimate permanent price impact (information content).\n\nPermanent impact = portion of price change that doesn't revert", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "execution"}
{"instruction": "Explain the Estimate Permanent Impact function", "input": "", "output": "Function: estimate_permanent_impact\n\nEstimate permanent price impact (information content).\n\nPermanent impact = portion of price change that doesn't revert", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "execution"}
{"instruction": "Explain the Calculate function", "input": "", "output": "Function: calculate\n\nCalculate Amihud illiquidity ratio.", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "general"}
{"instruction": "Explain the Calculate Tick function", "input": "", "output": "Function: calculate_tick\n\nCalculate integrated OFI for single tick.\n\nArgs:\n    bids: List of (price, size) at each level\n    asks: List of (price, size) at each level\n\nReturns:\n    Integrated OFI value", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "microstructure"}
{"instruction": "What is OFI in quantitative trading?", "input": "", "output": "OFI (Order Flow Imbalance).\n\nImplementation details:\nCalculate integrated OFI for single tick.\n\nArgs:\n    bids: List of (price, size) at each level\n    asks: List of (price, size) at each level\n\nReturns:\n    Integrated OFI value", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "microstructure"}
{"instruction": "What is the formula for Calculate Series?", "input": "", "output": "Calculate integrated OFI from DataFrame with bid/ask data.", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "microstructure"}
{"instruction": "Explain the Calculate Series function", "input": "", "output": "Function: calculate_series\n\nCalculate integrated OFI from DataFrame with bid/ask data.", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "microstructure"}
{"instruction": "What is OFI in quantitative trading?", "input": "", "output": "OFI (Order Flow Imbalance).\n\nImplementation details:\nCalculate integrated OFI from DataFrame with bid/ask data.", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "microstructure"}
{"instruction": "What is the formula for Detect Elephant?", "input": "", "output": "Detect large orders (elephants).\n\nReturns:\n    Series with 1 (buy elephant), -1 (sell elephant), 0 (none)", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "general"}
{"instruction": "Explain the Detect Elephant function", "input": "", "output": "Function: detect_elephant\n\nDetect large orders (elephants).\n\nReturns:\n    Series with 1 (buy elephant), -1 (sell elephant), 0 (none)", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "general"}
{"instruction": "What is the formula for Calculate Jump Signal?", "input": "", "output": "Calculate penny jump trading signal.\n\nSignal = Follow elephants with tight stop.", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "alpha"}
{"instruction": "Explain the Calculate Jump Signal function", "input": "", "output": "Function: calculate_jump_signal\n\nCalculate penny jump trading signal.\n\nSignal = Follow elephants with tight stop.", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "alpha"}
{"instruction": "What is the formula for Resample?", "input": "", "output": "Resample data to volume clock.\n\nReturns:\n    DataFrame with volume-based bars", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "volatility"}
{"instruction": "Explain the Resample function", "input": "", "output": "Function: resample\n\nResample data to volume clock.\n\nReturns:\n    DataFrame with volume-based bars", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "volatility"}
{"instruction": "Explain the Generate All Factors function", "input": "", "output": "Function: generate_all_factors\n\nGenerate all Chinese HFT factors.\n\nReturns:\n    DataFrame with factor columns added", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "alpha"}
{"instruction": "Explain the Get Factor Names function", "input": "", "output": "Function: get_factor_names\n\nReturn list of factor names.", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "alpha"}
{"instruction": "Explain the Compute All Features function", "input": "", "output": "Function: compute_all_features\n\nCompute all Chinese HFT features.\nInterface compatible with HFT Feature Engine.", "source": "core\\_experimental\\chinese_hft_factors.py", "category": "general"}
{"instruction": "Explain the purpose of Deep Learning Volatility Models", "input": "", "output": "Deep Learning Volatility Models\n===============================\nHybrid GARCH + Deep Learning for volatility forecasting.\n\nSources:\n- \"A Hybrid GARCH and Deep Learning Method for Volatility Prediction\" (Wiley 2024)\n- \"Multi-scale GARCH information\" (ScienceDirect 2025)\n\nModels:\n1. GARCH-LSTM Hybrid: GARCH for regime, LSTM for dynamics\n2. GRU-LSTM Hybrid: GRU features + LSTM temporal\n3. Simple RNN for real-time (ultra-fast inference)\n\nWhy these matter for HFT:\n- Better volatility forecasts = better Kelly sizing\n- Better sizing = higher Sharpe, lower drawdowns", "source": "core\\_experimental\\deep_volatility.py", "category": "volatility"}
{"instruction": "What is the VolatilityPrediction class and how do I use it?", "input": "", "output": "The VolatilityPrediction class:\n\nVolatility prediction result.", "source": "core\\_experimental\\deep_volatility.py", "category": "volatility"}
{"instruction": "What is the GARCHLSTMHybrid class and how do I use it?", "input": "", "output": "The GARCHLSTMHybrid class:\n\nGARCH-LSTM Hybrid Volatility Model.\n\nArchitecture:\n1. GARCH(1,1) for baseline volatility\n2. LSTM processes GARCH residuals to capture nonlinear dynamics\n3. Final prediction = GARCH baseline + LSTM adjustment\n\nThis captures:\n- GARCH: Volatility clustering, mean reversion\n- LSTM: Regime shifts, nonlinear patterns", "source": "core\\_experimental\\deep_volatility.py", "category": "volatility"}
{"instruction": "What is the GRULSTMHybrid class and how do I use it?", "input": "", "output": "The GRULSTMHybrid class:\n\nGRU-LSTM Hybrid for price direction prediction.\n\nSource: \"GRU-LSTM Hybrid Network\" (ScienceDirect 2020)\nValidated on EUR/USD, GBP/USD, USD/CAD, USD/CHF\n\nArchitecture:\n1. GRU: Fast feature extraction (cheaper than LSTM)\n2. LSTM: Capture long-term dependencies\n3. Dense: Final prediction\n\nGRU is ~30% faster than LSTM with similar performance.", "source": "core\\_experimental\\deep_volatility.py", "category": "general"}
{"instruction": "What is the DeepVolatilityFeatures class and how do I use it?", "input": "", "output": "The DeepVolatilityFeatures class:\n\nGenerate deep learning volatility features for HFT.", "source": "core\\_experimental\\deep_volatility.py", "category": "volatility"}
{"instruction": "What is the formula for Fit?", "input": "", "output": "Fit GARCH-LSTM model.\n\nArgs:\n    returns: Return series (in decimal, not percentage)\n    epochs: Training epochs\n    lr: Learning rate", "source": "core\\_experimental\\deep_volatility.py", "category": "volatility"}
{"instruction": "Explain the Fit function", "input": "", "output": "Function: fit\n\nFit GARCH-LSTM model.\n\nArgs:\n    returns: Return series (in decimal, not percentage)\n    epochs: Training epochs\n    lr: Learning rate", "source": "core\\_experimental\\deep_volatility.py", "category": "volatility"}
{"instruction": "What is GARCH in quantitative trading?", "input": "", "output": "GARCH (volatility forecasting model).\n\nImplementation details:\nFit GARCH-LSTM model.\n\nArgs:\n    returns: Return series (in decimal, not percentage)\n    epochs: Training epochs\n    lr: Learning rate", "source": "core\\_experimental\\deep_volatility.py", "category": "volatility"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nPredict volatility.\n\nArgs:\n    returns: Recent return series (at least lookback periods)\n\nReturns:\n    VolatilityPrediction with forecasts", "source": "core\\_experimental\\deep_volatility.py", "category": "volatility"}
{"instruction": "What is the formula for Prepare Features?", "input": "", "output": "Prepare features for GRU-LSTM.\n\nStandard features for forex:\n- Returns at multiple lags\n- Volatility\n- Momentum\n- Mean reversion signals", "source": "core\\_experimental\\deep_volatility.py", "category": "alpha"}
{"instruction": "Explain the Prepare Features function", "input": "", "output": "Function: prepare_features\n\nPrepare features for GRU-LSTM.\n\nStandard features for forex:\n- Returns at multiple lags\n- Volatility\n- Momentum\n- Mean reversion signals", "source": "core\\_experimental\\deep_volatility.py", "category": "alpha"}
{"instruction": "What is the formula for Fit?", "input": "", "output": "Fit GRU-LSTM model.\n\nArgs:\n    df: DataFrame with features and target\n    target_col: Target column name\n    epochs: Training epochs\n    lr: Learning rate", "source": "core\\_experimental\\deep_volatility.py", "category": "general"}
{"instruction": "Explain the Fit function", "input": "", "output": "Function: fit\n\nFit GRU-LSTM model.\n\nArgs:\n    df: DataFrame with features and target\n    target_col: Target column name\n    epochs: Training epochs\n    lr: Learning rate", "source": "core\\_experimental\\deep_volatility.py", "category": "general"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nPredict direction probabilities.", "source": "core\\_experimental\\deep_volatility.py", "category": "general"}
{"instruction": "Explain the Fit function", "input": "", "output": "Function: fit\n\nFit volatility models.", "source": "core\\_experimental\\deep_volatility.py", "category": "volatility"}
{"instruction": "Explain the Compute Features function", "input": "", "output": "Function: compute_features\n\nCompute deep volatility features.", "source": "core\\_experimental\\deep_volatility.py", "category": "volatility"}
{"instruction": "What is the source paper for this technique?", "input": "", "output": "The source is: Stable-Baselines3 (12.5k+ stars). ", "source": "core\\_experimental\\dqn_position_sizing.py", "category": "volatility"}
{"instruction": "Explain the purpose of Deep Q-Network (DQN) for Adaptive Position Sizing", "input": "", "output": "Deep Q-Network (DQN) for Adaptive Position Sizing\n==================================================\nSource: Stable-Baselines3 (12.5k+ stars)\nFinRL framework concepts (13.7k+ stars)\n\nKey Innovation:\n- Learn optimal position sizes from state (features, portfolio, risk)\n- Adapt to market regimes automatically\n- Balance risk/reward through experience replay\n- Handle transaction costs in reward function\n\nFor HFT Forex:\n- State: price features, current position, volatility regime\n- Actions: position sizes (0%, 25%, 50%, 75%, 100%)\n- Reward: risk-adjusted returns (Sharpe-like)", "source": "core\\_experimental\\dqn_position_sizing.py", "category": "volatility"}
{"instruction": "What is the DQNConfig class and how do I use it?", "input": "", "output": "The DQNConfig class:\n\nDQN configuration.", "source": "core\\_experimental\\dqn_position_sizing.py", "category": "rl"}
{"instruction": "What is the ReplayBuffer class and how do I use it?", "input": "", "output": "The ReplayBuffer class:\n\nExperience replay buffer for DQN.", "source": "core\\_experimental\\dqn_position_sizing.py", "category": "rl"}
{"instruction": "What is the DuelingDQN class and how do I use it?", "input": "", "output": "The DuelingDQN class:\n\nDueling DQN Architecture.\n\nSeparates value and advantage streams for better learning.\nQ(s,a) = V(s) + A(s,a) - mean(A(s,a))", "source": "core\\_experimental\\dqn_position_sizing.py", "category": "rl"}
{"instruction": "What is the NoisyLinear class and how do I use it?", "input": "", "output": "The NoisyLinear class:\n\nNoisy Linear layer for exploration.\n\nAdds learnable noise to weights for exploration instead of epsilon-greedy.", "source": "core\\_experimental\\dqn_position_sizing.py", "category": "general"}
{"instruction": "What is the NoisyDuelingDQN class and how do I use it?", "input": "", "output": "The NoisyDuelingDQN class:\n\nDueling DQN with Noisy layers for exploration.", "source": "core\\_experimental\\dqn_position_sizing.py", "category": "rl"}
{"instruction": "What is the PrioritizedReplayBuffer class and how do I use it?", "input": "", "output": "The PrioritizedReplayBuffer class:\n\nPrioritized Experience Replay.\n\nSamples important transitions more frequently based on TD error.", "source": "core\\_experimental\\dqn_position_sizing.py", "category": "general"}
{"instruction": "What is the DQNPositionSizer class and how do I use it?", "input": "", "output": "The DQNPositionSizer class:\n\nDQN-based Position Sizing for Forex Trading.\n\nState:\n- Price features (returns, volatility, momentum)\n- Current position\n- Account metrics (drawdown, recent PnL)\n- Risk indicators\n\nActions (discrete position sizes):\n- 0: 0% (no position)\n- 1: 25% of max position\n- 2: 50% of max position\n- 3: 75% of max position\n- 4: 100% of max position\n\nReward:\n- Risk-adjusted return (Sharpe-like)\n- Penalty for drawdown\n- Penalty for transaction costs", "source": "core\\_experimental\\dqn_position_sizing.py", "category": "volatility"}
{"instruction": "What is the PPOPositionSizer class and how do I use it?", "input": "", "output": "The PPOPositionSizer class:\n\nPPO-based Position Sizing (alternative to DQN).\n\nUses Proximal Policy Optimization for continuous action space.\nMore stable training than DQN for some environments.", "source": "core\\_experimental\\dqn_position_sizing.py", "category": "rl"}
{"instruction": "What is the formula for Create Position Sizer?", "input": "", "output": "Factory function for position sizers.\n\nArgs:\n    method: 'dqn' or 'ppo'\n    **kwargs: Configuration parameters\n\nReturns:\n    Position sizer instance", "source": "core\\_experimental\\dqn_position_sizing.py", "category": "alpha"}
{"instruction": "Explain the Create Position Sizer function", "input": "", "output": "Function: create_position_sizer\n\nFactory function for position sizers.\n\nArgs:\n    method: 'dqn' or 'ppo'\n    **kwargs: Configuration parameters\n\nReturns:\n    Position sizer instance", "source": "core\\_experimental\\dqn_position_sizing.py", "category": "alpha"}
{"instruction": "What is DQN in quantitative trading?", "input": "", "output": "DQN (Deep Q-Network for trading).\n\nImplementation details:\nFactory function for position sizers.\n\nArgs:\n    method: 'dqn' or 'ppo'\n    **kwargs: Configuration parameters\n\nReturns:\n    Position sizer instance", "source": "core\\_experimental\\dqn_position_sizing.py", "category": "alpha"}
{"instruction": "What is PPO in quantitative trading?", "input": "", "output": "PPO (Proximal Policy Optimization).\n\nImplementation details:\nFactory function for position sizers.\n\nArgs:\n    method: 'dqn' or 'ppo'\n    **kwargs: Configuration parameters\n\nReturns:\n    Position sizer instance", "source": "core\\_experimental\\dqn_position_sizing.py", "category": "alpha"}
{"instruction": "Explain the Push function", "input": "", "output": "Function: push\n\nAdd experience to buffer.", "source": "core\\_experimental\\dqn_position_sizing.py", "category": "general"}
{"instruction": "Explain the Sample function", "input": "", "output": "Function: sample\n\nSample batch of experiences.", "source": "core\\_experimental\\dqn_position_sizing.py", "category": "general"}
{"instruction": "Explain the Push function", "input": "", "output": "Function: push\n\nAdd experience with max priority.", "source": "core\\_experimental\\dqn_position_sizing.py", "category": "general"}
{"instruction": "Explain the Sample function", "input": "", "output": "Function: sample\n\nSample batch with priorities.", "source": "core\\_experimental\\dqn_position_sizing.py", "category": "general"}
{"instruction": "Explain the Update Priorities function", "input": "", "output": "Function: update_priorities\n\nUpdate priorities based on TD errors.", "source": "core\\_experimental\\dqn_position_sizing.py", "category": "general"}
{"instruction": "What is the formula for Prepare State?", "input": "", "output": "Prepare state vector from market data and account state.\n\nReturns 20-dimensional state:\n- 10 price features\n- 5 volatility/risk features\n- 5 account/position features", "source": "core\\_experimental\\dqn_position_sizing.py", "category": "volatility"}
{"instruction": "Explain the Prepare State function", "input": "", "output": "Function: prepare_state\n\nPrepare state vector from market data and account state.\n\nReturns 20-dimensional state:\n- 10 price features\n- 5 volatility/risk features\n- 5 account/position features", "source": "core\\_experimental\\dqn_position_sizing.py", "category": "volatility"}
{"instruction": "What is the formula for Select Action?", "input": "", "output": "Select action using epsilon-greedy or noisy exploration.", "source": "core\\_experimental\\dqn_position_sizing.py", "category": "general"}
{"instruction": "Explain the Select Action function", "input": "", "output": "Function: select_action\n\nSelect action using epsilon-greedy or noisy exploration.", "source": "core\\_experimental\\dqn_position_sizing.py", "category": "general"}
{"instruction": "What is the formula for Get Position Size?", "input": "", "output": "Get optimal position size for given state.\n\nArgs:\n    state: State vector\n    direction: 1 for long, -1 for short\n\nReturns:\n    Position size as fraction (0.0 to 1.0)", "source": "core\\_experimental\\dqn_position_sizing.py", "category": "regime"}
{"instruction": "Explain the Get Position Size function", "input": "", "output": "Function: get_position_size\n\nGet optimal position size for given state.\n\nArgs:\n    state: State vector\n    direction: 1 for long, -1 for short\n\nReturns:\n    Position size as fraction (0.0 to 1.0)", "source": "core\\_experimental\\dqn_position_sizing.py", "category": "regime"}
{"instruction": "Explain the Train Step function", "input": "", "output": "Function: train_step\n\nPerform one training step.", "source": "core\\_experimental\\dqn_position_sizing.py", "category": "general"}
{"instruction": "Explain the Train function", "input": "", "output": "Function: train\n\nTrain DQN on historical data.\n\nSimulates trading and learns optimal position sizes.", "source": "core\\_experimental\\dqn_position_sizing.py", "category": "rl"}
{"instruction": "What is DQN in quantitative trading?", "input": "", "output": "DQN (Deep Q-Network for trading).\n\nImplementation details:\nTrain DQN on historical data.\n\nSimulates trading and learns optimal position sizes.", "source": "core\\_experimental\\dqn_position_sizing.py", "category": "rl"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nPredict optimal position size.\n\nReturns:\n    Dict with position_size, action, q_values", "source": "core\\_experimental\\dqn_position_sizing.py", "category": "general"}
{"instruction": "Explain the Get Action function", "input": "", "output": "Function: get_action\n\nGet action from policy.", "source": "core\\_experimental\\dqn_position_sizing.py", "category": "general"}
{"instruction": "Explain the Get Value function", "input": "", "output": "Function: get_value\n\nGet value estimate.", "source": "core\\_experimental\\dqn_position_sizing.py", "category": "general"}
{"instruction": "Explain the Update function", "input": "", "output": "Function: update\n\nUpdate policy using PPO objective.", "source": "core\\_experimental\\dqn_position_sizing.py", "category": "rl"}
{"instruction": "What is PPO in quantitative trading?", "input": "", "output": "PPO (Proximal Policy Optimization).\n\nImplementation details:\nUpdate policy using PPO objective.", "source": "core\\_experimental\\dqn_position_sizing.py", "category": "rl"}
{"instruction": "Explain the purpose of Elite Quant Factors - Top Chinese Fund Algorithms", "input": "", "output": "Elite Quant Factors - Top Chinese Fund Algorithms\n==================================================\nSources verified from:\n- 幻方量化 (High-Flyer) - DeepSeek parent, 萤火超算\n- 九坤投资 (Ubiquant) - AI Lab, 水滴实验室\n- 明汯投资 (Minghong) - Multi-factor pioneer\n- 知乎专栏 verified articles\n- CSDN 高频因子系列\n- QuantsPlaybook (券商金工研报复现)\n- Microsoft Qlib (35k stars)\n\nGold Standard Algorithms:\n1. Dynamic Factor Model (DFM) - Factor rotation\n2. PCA Factor Orthogonalization - Remove correlation\n3. Elastic Net Factor Combination - L1+L2 regularization\n4. Higher-Order Moments - Skewness/Kurtosis factors\n5. Intraday Momentum - First 30min / Last 30min effects\n6. Overnight Gap Analysis - 隔夜收益分解\n7. Cross-Sectional Momentum - Relative strength\n8. Adaptive Factor Weighting - IC-based weights\n9. Factor Decay Analysis - Half-life estimation\n10. Information Coefficient (IC) Engine - Factor evaluation", "source": "core\\_experimental\\elite_quant_factors.py", "category": "alpha"}
{"instruction": "What is the FactorEvaluation class and how do I use it?", "input": "", "output": "The FactorEvaluation class:\n\nFactor evaluation metrics.", "source": "core\\_experimental\\elite_quant_factors.py", "category": "alpha"}
{"instruction": "What is the InformationCoefficientEngine class and how do I use it?", "input": "", "output": "The InformationCoefficientEngine class:\n\nIC/ICIR Engine - Core factor evaluation tool.\n\nSource: Every top quant fund uses this\n\nIC = corr(factor_t, return_t+1)\nICIR = mean(IC) / std(IC)\n\nGood factor: IC > 0.03, ICIR > 0.5\nGreat factor: IC > 0.05, ICIR > 1.0", "source": "core\\_experimental\\elite_quant_factors.py", "category": "alpha"}
{"instruction": "What is the PCAFactorOrthogonalizer class and how do I use it?", "input": "", "output": "The PCAFactorOrthogonalizer class:\n\nPCA Factor Orthogonalization.\n\nSource: Standard in 九坤, 明汯 factor research\n\nRemoves correlation between factors to:\n1. Avoid multicollinearity\n2. Identify independent alpha sources\n3. Improve factor combination", "source": "core\\_experimental\\elite_quant_factors.py", "category": "alpha"}
{"instruction": "What is the ElasticNetFactorCombiner class and how do I use it?", "input": "", "output": "The ElasticNetFactorCombiner class:\n\nElastic Net Factor Combination.\n\nSource: Standard in top quant funds for factor weighting\n\nCombines L1 (Lasso) and L2 (Ridge) regularization:\n- L1: Feature selection (sets weak factors to 0)\n- L2: Handles correlated factors\n\nBetter than simple IC-weighting for high-dimensional factors.", "source": "core\\_experimental\\elite_quant_factors.py", "category": "alpha"}
{"instruction": "What is the HigherOrderMoments class and how do I use it?", "input": "", "output": "The HigherOrderMoments class:\n\nHigher-Order Moment Factors.\n\nSource: Academic literature, verified in Chinese quant research\n\nBeyond mean and variance:\n- Skewness: Asymmetry of returns\n- Kurtosis: Fat tails / extreme events\n- Coskewness: Systematic skewness risk\n\nInvestors dislike negative skew (crash risk).", "source": "core\\_experimental\\elite_quant_factors.py", "category": "alpha"}
{"instruction": "What is the IntradayMomentum class and how do I use it?", "input": "", "output": "The IntradayMomentum class:\n\nIntraday Momentum Factors.\n\nSource: 券商金工研报, verified on A-shares\n\nKey patterns:\n1. First 30 minutes momentum - opening auction effect\n2. Last 30 minutes momentum - closing auction effect\n3. Lunch break effect - pre/post lunch patterns\n4. Overnight gap vs intraday reversal\n\nFor Forex HFT:\n- Session open effects (London, NY, Tokyo)\n- Pre-news vs post-news patterns", "source": "core\\_experimental\\elite_quant_factors.py", "category": "alpha"}
{"instruction": "What is the AdaptiveFactorWeighting class and how do I use it?", "input": "", "output": "The AdaptiveFactorWeighting class:\n\nAdaptive Factor Weighting.\n\nSource: 幻方量化 factor combination approach\n\nInstead of static weights, adapt based on:\n1. Recent IC performance\n2. Factor decay\n3. Market regime\n\nDynamically allocate to best-performing factors.", "source": "core\\_experimental\\elite_quant_factors.py", "category": "alpha"}
{"instruction": "What is the CrossSectionalMomentum class and how do I use it?", "input": "", "output": "The CrossSectionalMomentum class:\n\nCross-Sectional Momentum / Relative Strength.\n\nSource: Standard in multi-asset quant strategies\n\nRanks assets by momentum and goes:\n- Long top performers\n- Short bottom performers\n\nFor Forex: Rank currency pairs by strength.", "source": "core\\_experimental\\elite_quant_factors.py", "category": "general"}
{"instruction": "What is the EliteFactorEngine class and how do I use it?", "input": "", "output": "The EliteFactorEngine class:\n\nUnified Elite Factor Engine.\n\nCombines all gold standard algorithms from top Chinese quants.", "source": "core\\_experimental\\elite_quant_factors.py", "category": "alpha"}
{"instruction": "What is the EliteQuantEngine class and how do I use it?", "input": "", "output": "The EliteQuantEngine class:\n\nWrapper class for HFT Feature Engine integration.\nProvides compute_all_features() interface.", "source": "core\\_experimental\\elite_quant_factors.py", "category": "general"}
{"instruction": "Explain the Calculate Ic function", "input": "", "output": "Function: calculate_ic\n\nCalculate Information Coefficient.\n\nArgs:\n    factor: Factor values\n    forward_return: Forward returns\n    method: 'pearson' or 'spearman'\n\nReturns:\n    IC value", "source": "core\\_experimental\\elite_quant_factors.py", "category": "alpha"}
{"instruction": "Explain the Calculate Icir function", "input": "", "output": "Function: calculate_icir\n\nCalculate IC Information Ratio.", "source": "core\\_experimental\\elite_quant_factors.py", "category": "general"}
{"instruction": "Explain the Rolling Ic function", "input": "", "output": "Function: rolling_ic\n\nCalculate rolling IC.", "source": "core\\_experimental\\elite_quant_factors.py", "category": "general"}
{"instruction": "What is the formula for Evaluate Factor?", "input": "", "output": "Complete factor evaluation.\n\nReturns IC, ICIR, Rank IC, T-stat, Turnover, Decay", "source": "core\\_experimental\\elite_quant_factors.py", "category": "alpha"}
{"instruction": "Explain the Evaluate Factor function", "input": "", "output": "Function: evaluate_factor\n\nComplete factor evaluation.\n\nReturns IC, ICIR, Rank IC, T-stat, Turnover, Decay", "source": "core\\_experimental\\elite_quant_factors.py", "category": "alpha"}
{"instruction": "Explain the Fit Transform function", "input": "", "output": "Function: fit_transform\n\nOrthogonalize factors using PCA.\n\nArgs:\n    factor_df: DataFrame with factor columns\n\nReturns:\n    DataFrame with orthogonalized PC factors", "source": "core\\_experimental\\elite_quant_factors.py", "category": "alpha"}
{"instruction": "Explain the Get Factor Loadings function", "input": "", "output": "Function: get_factor_loadings\n\nGet factor loadings for interpretation.", "source": "core\\_experimental\\elite_quant_factors.py", "category": "alpha"}
{"instruction": "Explain the Fit function", "input": "", "output": "Function: fit\n\nFit Elastic Net to find optimal factor weights.\n\nArgs:\n    factor_df: DataFrame with factor columns\n    returns: Target returns (forward)\n\nReturns:\n    self", "source": "core\\_experimental\\elite_quant_factors.py", "category": "alpha"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nPredict combined factor signal.", "source": "core\\_experimental\\elite_quant_factors.py", "category": "alpha"}
{"instruction": "Explain the Get Top Factors function", "input": "", "output": "Function: get_top_factors\n\nGet top N factors by absolute weight.", "source": "core\\_experimental\\elite_quant_factors.py", "category": "alpha"}
{"instruction": "What is the formula for Calculate Skewness?", "input": "", "output": "Rolling skewness factor.\n\nNegative skew = more likely to have large negative returns", "source": "core\\_experimental\\elite_quant_factors.py", "category": "alpha"}
{"instruction": "Explain the Calculate Skewness function", "input": "", "output": "Function: calculate_skewness\n\nRolling skewness factor.\n\nNegative skew = more likely to have large negative returns", "source": "core\\_experimental\\elite_quant_factors.py", "category": "alpha"}
{"instruction": "What is the formula for Calculate Kurtosis?", "input": "", "output": "Rolling kurtosis factor.\n\nHigh kurtosis = fat tails = more extreme moves", "source": "core\\_experimental\\elite_quant_factors.py", "category": "alpha"}
{"instruction": "Explain the Calculate Kurtosis function", "input": "", "output": "Function: calculate_kurtosis\n\nRolling kurtosis factor.\n\nHigh kurtosis = fat tails = more extreme moves", "source": "core\\_experimental\\elite_quant_factors.py", "category": "alpha"}
{"instruction": "What is the formula for Calculate Downside Skew?", "input": "", "output": "Downside skewness - only negative returns.\n\nMore relevant for risk assessment.", "source": "core\\_experimental\\elite_quant_factors.py", "category": "risk"}
{"instruction": "Explain the Calculate Downside Skew function", "input": "", "output": "Function: calculate_downside_skew\n\nDownside skewness - only negative returns.\n\nMore relevant for risk assessment.", "source": "core\\_experimental\\elite_quant_factors.py", "category": "risk"}
{"instruction": "What is the formula for Calculate Tail Risk?", "input": "", "output": "Tail risk factor (Expected Shortfall / CVaR).\n\nAverage loss in worst X% of cases.", "source": "core\\_experimental\\elite_quant_factors.py", "category": "alpha"}
{"instruction": "Explain the Calculate Tail Risk function", "input": "", "output": "Function: calculate_tail_risk\n\nTail risk factor (Expected Shortfall / CVaR).\n\nAverage loss in worst X% of cases.", "source": "core\\_experimental\\elite_quant_factors.py", "category": "alpha"}
{"instruction": "What is the formula for Generate All?", "input": "", "output": "Generate all higher-order moment factors.", "source": "core\\_experimental\\elite_quant_factors.py", "category": "alpha"}
{"instruction": "Explain the Generate All function", "input": "", "output": "Function: generate_all\n\nGenerate all higher-order moment factors.", "source": "core\\_experimental\\elite_quant_factors.py", "category": "alpha"}
{"instruction": "Explain the Calculate First Hour Momentum function", "input": "", "output": "Function: calculate_first_hour_momentum\n\nFirst N minutes momentum.\n\nStrong opens often continue.", "source": "core\\_experimental\\elite_quant_factors.py", "category": "general"}
{"instruction": "Explain the Calculate Last Hour Momentum function", "input": "", "output": "Function: calculate_last_hour_momentum\n\nLast N minutes momentum.\n\nOften driven by institutional rebalancing.", "source": "core\\_experimental\\elite_quant_factors.py", "category": "general"}
{"instruction": "What is the formula for Calculate Overnight Return?", "input": "", "output": "Overnight return factor.\n\nFor forex: Return during low-liquidity hours.", "source": "core\\_experimental\\elite_quant_factors.py", "category": "alpha"}
{"instruction": "Explain the Calculate Overnight Return function", "input": "", "output": "Function: calculate_overnight_return\n\nOvernight return factor.\n\nFor forex: Return during low-liquidity hours.", "source": "core\\_experimental\\elite_quant_factors.py", "category": "alpha"}
{"instruction": "What is the formula for Calculate Session Momentum?", "input": "", "output": "Session-specific momentum.\n\nDifferent sessions have different characteristics.", "source": "core\\_experimental\\elite_quant_factors.py", "category": "general"}
{"instruction": "Explain the Calculate Session Momentum function", "input": "", "output": "Function: calculate_session_momentum\n\nSession-specific momentum.\n\nDifferent sessions have different characteristics.", "source": "core\\_experimental\\elite_quant_factors.py", "category": "general"}
{"instruction": "Explain the Generate All function", "input": "", "output": "Function: generate_all\n\nGenerate all intraday momentum factors.", "source": "core\\_experimental\\elite_quant_factors.py", "category": "alpha"}
{"instruction": "What is the formula for Calculate Ic Weights?", "input": "", "output": "Calculate IC-based weights with exponential decay.\n\nRecent IC matters more than old IC.", "source": "core\\_experimental\\elite_quant_factors.py", "category": "general"}
{"instruction": "Explain the Calculate Ic Weights function", "input": "", "output": "Function: calculate_ic_weights\n\nCalculate IC-based weights with exponential decay.\n\nRecent IC matters more than old IC.", "source": "core\\_experimental\\elite_quant_factors.py", "category": "general"}
{"instruction": "Explain the Combine Factors function", "input": "", "output": "Function: combine_factors\n\nCombine factors with adaptive weights.\n\nReturns combined signal.", "source": "core\\_experimental\\elite_quant_factors.py", "category": "alpha"}
{"instruction": "Explain the Get Top Factors function", "input": "", "output": "Function: get_top_factors\n\nGet top N factors by weight.", "source": "core\\_experimental\\elite_quant_factors.py", "category": "alpha"}
{"instruction": "What is the formula for Calculate Momentum Rank?", "input": "", "output": "Rank assets by momentum.\n\nArgs:\n    returns_df: DataFrame with asset returns as columns\n\nReturns:\n    DataFrame with ranks (1 = strongest)", "source": "core\\_experimental\\elite_quant_factors.py", "category": "general"}
{"instruction": "Explain the Calculate Momentum Rank function", "input": "", "output": "Function: calculate_momentum_rank\n\nRank assets by momentum.\n\nArgs:\n    returns_df: DataFrame with asset returns as columns\n\nReturns:\n    DataFrame with ranks (1 = strongest)", "source": "core\\_experimental\\elite_quant_factors.py", "category": "general"}
{"instruction": "Explain the Calculate Relative Strength function", "input": "", "output": "Function: calculate_relative_strength\n\nRelative strength vs benchmark.\n\nRS > 1: Outperforming\nRS < 1: Underperforming", "source": "core\\_experimental\\elite_quant_factors.py", "category": "general"}
{"instruction": "Explain the Generate All Factors function", "input": "", "output": "Function: generate_all_factors\n\nGenerate all elite factors.", "source": "core\\_experimental\\elite_quant_factors.py", "category": "alpha"}
{"instruction": "Explain the Evaluate All Factors function", "input": "", "output": "Function: evaluate_all_factors\n\nEvaluate all factors and return metrics.\n\nReturns DataFrame with IC, ICIR, etc. for each factor.", "source": "core\\_experimental\\elite_quant_factors.py", "category": "alpha"}
{"instruction": "Explain the Get Factor Names function", "input": "", "output": "Function: get_factor_names\n\nReturn list of elite factor names.", "source": "core\\_experimental\\elite_quant_factors.py", "category": "alpha"}
{"instruction": "Explain the Compute All Features function", "input": "", "output": "Function: compute_all_features\n\nCompute all Elite Quant features.\nInterface compatible with HFT Feature Engine.", "source": "core\\_experimental\\elite_quant_factors.py", "category": "general"}
{"instruction": "Explain the Compute All Features function", "input": "", "output": "Function: compute_all_features\n\nCompute all Elite Quant features.\nInterface compatible with HFT Feature Engine.", "source": "core\\_experimental\\elite_quant_factors.py", "category": "general"}
{"instruction": "Explain the purpose of Feature Importance Methods (Lopez de Prado AFML)", "input": "", "output": "Feature Importance Methods (Lopez de Prado AFML)\n=================================================\nImplementation of feature importance methods from \"Advances in Financial Machine Learning\"\n\nSources (Gold Standard Citations):\n- Lopez de Prado, M. (2018). \"Advances in Financial Machine Learning\"\n  Chapter 8: Feature Importance\n\nMethods Implemented:\n1. MDA (Mean Decrease Accuracy) - Permutation importance\n2. MDI (Mean Decrease Impurity) - Tree-based importance\n3. SFI (Single Feature Importance) - Univariate importance\n4. Clustered Feature Importance - Correlation-aware importance\n5. SHAP Integration - Shapley values wrapper\n\nThese methods are critical for:\n- Identifying truly predictive features vs noise\n- Detecting overfitting (features with high MDI but low MDA)\n- Regulatory compliance (model explainability)", "source": "core\\_experimental\\feature_importance.py", "category": "risk"}
{"instruction": "What is the FeatureImportanceResult class and how do I use it?", "input": "", "output": "The FeatureImportanceResult class:\n\nContainer for feature importance results.", "source": "core\\_experimental\\feature_importance.py", "category": "general"}
{"instruction": "What is the FeatureImportance class and how do I use it?", "input": "", "output": "The FeatureImportance class:\n\nFeature Importance Analysis (AFML Methods)\n\nImplements permutation-based and tree-based feature importance\nwith proper cross-validation to avoid overfitting.\n\nUsage:\n    fi = FeatureImportance()\n    mda = fi.mean_decrease_accuracy(model, X, y, cv=5)\n    mdi = fi.mean_decrease_impurity(model, X)", "source": "core\\_experimental\\feature_importance.py", "category": "general"}
{"instruction": "Show me a code example for FeatureImportance", "input": "", "output": "fi = FeatureImportance()\n    mda = fi.mean_decrease_accuracy(model, X, y, cv=5)\n    mdi = fi.mean_decrease_impurity(model, X)", "source": "core\\_experimental\\feature_importance.py", "category": "general"}
{"instruction": "What is the SampleWeightsByUniqueness class and how do I use it?", "input": "", "output": "The SampleWeightsByUniqueness class:\n\nSample Weights by Label Uniqueness (AFML Ch. 4)\n\nAssigns sample weights based on how unique each sample's label is.\nSamples with overlapping labels get lower weights to avoid overweighting.\n\nReference:\n    Lopez de Prado (2018), AFML Chapter 4.5", "source": "core\\_experimental\\feature_importance.py", "category": "rl"}
{"instruction": "Explain the Create Feature Importance function", "input": "", "output": "Function: create_feature_importance\n\nFactory function for FeatureImportance.", "source": "core\\_experimental\\feature_importance.py", "category": "alpha"}
{"instruction": "Explain the Get Sample Weights function", "input": "", "output": "Function: get_sample_weights\n\nConvenience function for sample weights.", "source": "core\\_experimental\\feature_importance.py", "category": "general"}
{"instruction": "What is the formula for Mean Decrease Accuracy?", "input": "", "output": "Mean Decrease Accuracy (MDA) - Permutation-based feature importance.\n\nFor each feature:\n1. Fit model on training data\n2. Measure baseline score on OOS data\n3. Permute feature values in OOS data\n4. Measure score drop after permutation\n5. Importance = mean score drop across CV folds\n\nReference:\n    Lopez de Prado (2018), AFML Chapter 8.3\n\nArgs:\n    model: Fitted sklearn-compatible model\n    X: Feature DataFrame\n    y: Target Series\n    cv: Number of cross-validation folds\n    scoring: Scoring metric ('accuracy', 'f1', 'neg_log_loss', etc.)\n    n_repeats: Number of permutation repeats per feature\n    sample_weight: Optional sample weights\n\nReturns:\n    FeatureImportanceResult with importance scores", "source": "core\\_experimental\\feature_importance.py", "category": "general"}
{"instruction": "Explain the Mean Decrease Accuracy function", "input": "", "output": "Function: mean_decrease_accuracy\n\nMean Decrease Accuracy (MDA) - Permutation-based feature importance.\n\nFor each feature:\n1. Fit model on training data\n2. Measure baseline score on OOS data\n3. Permute feature values in OOS data\n4. Measure score drop after permutation\n5. Importance = mean score drop across CV folds\n\nReference:\n    Lopez de Prado (2018), AFML Chapter 8.3\n\nArgs:\n    model: Fitted sklearn-compatible model\n    X: Feature DataFrame\n    y: Target Series\n    cv: Number of cross-validation folds\n    scoring: Scoring metric ('accuracy', 'f1', 'neg_log_loss', etc.)\n    n_repeats: Number of permutation repeats per feature\n    sample_weight: Optional sample weights\n\nReturns:\n    FeatureImportanceResult with importance scores", "source": "core\\_experimental\\feature_importance.py", "category": "general"}
{"instruction": "What is the formula for Mean Decrease Impurity?", "input": "", "output": "Mean Decrease Impurity (MDI) - Tree-based feature importance.\n\nUses the built-in feature_importances_ from tree-based models.\nFast but can be biased toward high-cardinality features.\n\nReference:\n    Lopez de Prado (2018), AFML Chapter 8.2\n\nArgs:\n    model: Fitted tree-based model (RF, XGBoost, LightGBM, etc.)\n    X: Feature DataFrame\n    normalize: Whether to normalize importances to sum to 1\n\nReturns:\n    FeatureImportanceResult with importance scores", "source": "core\\_experimental\\feature_importance.py", "category": "general"}
{"instruction": "Explain the Mean Decrease Impurity function", "input": "", "output": "Function: mean_decrease_impurity\n\nMean Decrease Impurity (MDI) - Tree-based feature importance.\n\nUses the built-in feature_importances_ from tree-based models.\nFast but can be biased toward high-cardinality features.\n\nReference:\n    Lopez de Prado (2018), AFML Chapter 8.2\n\nArgs:\n    model: Fitted tree-based model (RF, XGBoost, LightGBM, etc.)\n    X: Feature DataFrame\n    normalize: Whether to normalize importances to sum to 1\n\nReturns:\n    FeatureImportanceResult with importance scores", "source": "core\\_experimental\\feature_importance.py", "category": "general"}
{"instruction": "What is the formula for Single Feature Importance?", "input": "", "output": "Single Feature Importance (SFI) - Univariate importance.\n\nTrains model on each feature individually and measures OOS score.\nSimple baseline that ignores feature interactions.\n\nReference:\n    Lopez de Prado (2018), AFML Chapter 8.4\n\nArgs:\n    model: sklearn-compatible model\n    X: Feature DataFrame\n    y: Target Series\n    cv: Number of cross-validation folds\n    scoring: Scoring metric\n\nReturns:\n    FeatureImportanceResult with importance scores", "source": "core\\_experimental\\feature_importance.py", "category": "risk"}
{"instruction": "Explain the Single Feature Importance function", "input": "", "output": "Function: single_feature_importance\n\nSingle Feature Importance (SFI) - Univariate importance.\n\nTrains model on each feature individually and measures OOS score.\nSimple baseline that ignores feature interactions.\n\nReference:\n    Lopez de Prado (2018), AFML Chapter 8.4\n\nArgs:\n    model: sklearn-compatible model\n    X: Feature DataFrame\n    y: Target Series\n    cv: Number of cross-validation folds\n    scoring: Scoring metric\n\nReturns:\n    FeatureImportanceResult with importance scores", "source": "core\\_experimental\\feature_importance.py", "category": "risk"}
{"instruction": "What is the formula for Clustered Mda?", "input": "", "output": "Clustered MDA - Correlation-aware feature importance.\n\nClusters correlated features together and permutes entire clusters.\nAvoids redundant importance across correlated features.\n\nReference:\n    Lopez de Prado (2018), AFML Chapter 8.5\n\nArgs:\n    model: sklearn-compatible model\n    X: Feature DataFrame\n    y: Target Series\n    n_clusters: Number of feature clusters\n    cv: Number of CV folds\n    scoring: Scoring metric\n\nReturns:\n    Tuple of (importance result, cluster assignments)", "source": "core\\_experimental\\feature_importance.py", "category": "general"}
{"instruction": "Explain the Clustered Mda function", "input": "", "output": "Function: clustered_mda\n\nClustered MDA - Correlation-aware feature importance.\n\nClusters correlated features together and permutes entire clusters.\nAvoids redundant importance across correlated features.\n\nReference:\n    Lopez de Prado (2018), AFML Chapter 8.5\n\nArgs:\n    model: sklearn-compatible model\n    X: Feature DataFrame\n    y: Target Series\n    n_clusters: Number of feature clusters\n    cv: Number of CV folds\n    scoring: Scoring metric\n\nReturns:\n    Tuple of (importance result, cluster assignments)", "source": "core\\_experimental\\feature_importance.py", "category": "general"}
{"instruction": "Explain the Shap Importance function", "input": "", "output": "Function: shap_importance\n\nSHAP (SHapley Additive exPlanations) feature importance.\n\nUses Shapley values for theoretically sound feature attribution.\nRequires 'shap' package to be installed.\n\nReference:\n    Lundberg, S. M., & Lee, S. I. (2017). \"A Unified Approach to\n    Interpreting Model Predictions\". NeurIPS.\n\nArgs:\n    model: Fitted model\n    X: Feature DataFrame\n    n_samples: Number of samples for SHAP calculation\n    check_additivity: Whether to check SHAP additivity\n\nReturns:\n    FeatureImportanceResult with SHAP importance", "source": "core\\_experimental\\feature_importance.py", "category": "general"}
{"instruction": "What is the formula for Compare Methods?", "input": "", "output": "Compare all feature importance methods.\n\nUseful for identifying potential overfitting:\n- High MDI + Low MDA = likely overfit feature\n- High MDA + Low MDI = complex feature interaction\n\nReturns:\n    DataFrame with importance from all methods", "source": "core\\_experimental\\feature_importance.py", "category": "general"}
{"instruction": "Explain the Compare Methods function", "input": "", "output": "Function: compare_methods\n\nCompare all feature importance methods.\n\nUseful for identifying potential overfitting:\n- High MDI + Low MDA = likely overfit feature\n- High MDA + Low MDI = complex feature interaction\n\nReturns:\n    DataFrame with importance from all methods", "source": "core\\_experimental\\feature_importance.py", "category": "general"}
{"instruction": "What is the formula for Detect Overfit Features?", "input": "", "output": "Detect features likely to cause overfitting.\n\nFeatures with high MDI but low MDA are likely memorizing noise.\n\nArgs:\n    model: Fitted tree-based model\n    X: Feature DataFrame\n    y: Target Series\n    threshold: MDI-MDA difference threshold\n\nReturns:\n    List of potentially overfit feature names", "source": "core\\_experimental\\feature_importance.py", "category": "general"}
{"instruction": "Explain the Detect Overfit Features function", "input": "", "output": "Function: detect_overfit_features\n\nDetect features likely to cause overfitting.\n\nFeatures with high MDI but low MDA are likely memorizing noise.\n\nArgs:\n    model: Fitted tree-based model\n    X: Feature DataFrame\n    y: Target Series\n    threshold: MDI-MDA difference threshold\n\nReturns:\n    List of potentially overfit feature names", "source": "core\\_experimental\\feature_importance.py", "category": "general"}
{"instruction": "What is the formula for Get Indicator Matrix?", "input": "", "output": "Create indicator matrix showing which samples span each time point.\n\nArgs:\n    t1: Series with sample end times (index = start time)\n    close_idx: Full datetime index of the price series\n\nReturns:\n    DataFrame with samples as columns, times as rows", "source": "core\\_experimental\\feature_importance.py", "category": "general"}
{"instruction": "Explain the Get Indicator Matrix function", "input": "", "output": "Function: get_indicator_matrix\n\nCreate indicator matrix showing which samples span each time point.\n\nArgs:\n    t1: Series with sample end times (index = start time)\n    close_idx: Full datetime index of the price series\n\nReturns:\n    DataFrame with samples as columns, times as rows", "source": "core\\_experimental\\feature_importance.py", "category": "general"}
{"instruction": "What is the formula for Get Average Uniqueness?", "input": "", "output": "Calculate average uniqueness for each sample.\n\nUniqueness = 1 / (number of concurrent samples)\n\nArgs:\n    indicator_matrix: Output from get_indicator_matrix\n\nReturns:\n    Series of uniqueness values per sample", "source": "core\\_experimental\\feature_importance.py", "category": "general"}
{"instruction": "Explain the Get Average Uniqueness function", "input": "", "output": "Function: get_average_uniqueness\n\nCalculate average uniqueness for each sample.\n\nUniqueness = 1 / (number of concurrent samples)\n\nArgs:\n    indicator_matrix: Output from get_indicator_matrix\n\nReturns:\n    Series of uniqueness values per sample", "source": "core\\_experimental\\feature_importance.py", "category": "general"}
{"instruction": "What is the formula for Get Sample Weights?", "input": "", "output": "Get sample weights based on uniqueness.\n\nArgs:\n    t1: Series with sample end times (index = start time)\n    close_idx: Full datetime index\n    num_co_events: Optional pre-computed concurrency\n\nReturns:\n    Series of sample weights", "source": "core\\_experimental\\feature_importance.py", "category": "general"}
{"instruction": "Explain the Get Sample Weights function", "input": "", "output": "Function: get_sample_weights\n\nGet sample weights based on uniqueness.\n\nArgs:\n    t1: Series with sample end times (index = start time)\n    close_idx: Full datetime index\n    num_co_events: Optional pre-computed concurrency\n\nReturns:\n    Series of sample weights", "source": "core\\_experimental\\feature_importance.py", "category": "general"}
{"instruction": "What is the formula for Get Time Decay Weights?", "input": "", "output": "Apply time decay to sample weights (more recent = higher weight).\n\nArgs:\n    t1: Series with sample end times\n    decay_factor: Decay rate (0 = uniform, 1 = linear decay)\n\nReturns:\n    Time-decayed sample weights", "source": "core\\_experimental\\feature_importance.py", "category": "alpha"}
{"instruction": "Explain the Get Time Decay Weights function", "input": "", "output": "Function: get_time_decay_weights\n\nApply time decay to sample weights (more recent = higher weight).\n\nArgs:\n    t1: Series with sample end times\n    decay_factor: Decay rate (0 = uniform, 1 = linear decay)\n\nReturns:\n    Time-decayed sample weights", "source": "core\\_experimental\\feature_importance.py", "category": "alpha"}
{"instruction": "Explain the Combine Weights function", "input": "", "output": "Function: combine_weights\n\nCombine uniqueness and time decay weights.\n\nArgs:\n    uniqueness_weights: From get_sample_weights\n    time_decay_weights: From get_time_decay_weights\n\nReturns:\n    Combined normalized weights", "source": "core\\_experimental\\feature_importance.py", "category": "general"}
{"instruction": "Explain the purpose of Genetic Programming Factor Mining", "input": "", "output": "Genetic Programming Factor Mining\n=================================\nSources:\n- gplearn library (符号回归)\n- DEAP (Distributed Evolutionary Algorithms in Python)\n- 东方金工 DFQ遗传规划价量因子挖掘系统\n- 华泰金工遗传规划因子挖掘 (GPU加速)\n\nKey Innovation:\n- \"先有公式，后找逻辑\" - Formula first, logic second\n- Automatically discovers alpha factors through evolution\n- Achieves 23.6% annual return, Sharpe 5.87 in backtests\n\nFor Forex HFT:\n- Evolve price/volume patterns specific to forex\n- Discover cross-pair relationships\n- Find microstructure alphas automatically", "source": "core\\_experimental\\genetic_factor_mining.py", "category": "alpha"}
{"instruction": "What is the DiscoveredFactor class and how do I use it?", "input": "", "output": "The DiscoveredFactor class:\n\nA factor discovered by genetic programming.", "source": "core\\_experimental\\genetic_factor_mining.py", "category": "alpha"}
{"instruction": "What is the GeneticFactorMiner class and how do I use it?", "input": "", "output": "The GeneticFactorMiner class:\n\nGenetic Programming Factor Mining using gplearn.\n\nSource: 华泰金工, 东方金工 DFQ系统\n\nUsage:\n    miner = GeneticFactorMiner()\n    factors = miner.mine(df, target_returns, n_factors=10)\n\n    # Use discovered factors\n    for factor in factors:\n        print(f\"Formula: {factor.formula}\")\n        print(f\"IC: {factor.ic:.4f}, ICIR: {factor.icir:.4f}\")", "source": "core\\_experimental\\genetic_factor_mining.py", "category": "alpha"}
{"instruction": "Show me a code example for GeneticFactorMiner", "input": "", "output": "miner = GeneticFactorMiner()\n    factors = miner.mine(df, target_returns, n_factors=10)", "source": "core\\_experimental\\genetic_factor_mining.py", "category": "alpha"}
{"instruction": "What is the DEAPFactorMiner class and how do I use it?", "input": "", "output": "The DEAPFactorMiner class:\n\nFactor mining using DEAP (more flexible than gplearn).\n\nSource: Quantlab 4.2, DEAP因子挖掘\n\nAdvantages over gplearn:\n- More flexible operator definitions\n- Better for multi-objective optimization\n- Can incorporate domain constraints", "source": "core\\_experimental\\genetic_factor_mining.py", "category": "alpha"}
{"instruction": "What is the GeneticFactorEngine class and how do I use it?", "input": "", "output": "The GeneticFactorEngine class:\n\nUnified Genetic Factor Mining Engine.\nWrapper for both gplearn and DEAP methods.", "source": "core\\_experimental\\genetic_factor_mining.py", "category": "alpha"}
{"instruction": "Explain the Mine function", "input": "", "output": "Function: mine\n\nMine factors using genetic programming.\n\nArgs:\n    df: DataFrame with OHLCV data\n    target: Target returns (forward returns)\n    n_factors: Number of factors to discover\n    feature_cols: Columns to use as base features\n\nReturns:\n    List of discovered factors", "source": "core\\_experimental\\genetic_factor_mining.py", "category": "alpha"}
{"instruction": "Explain the Transform function", "input": "", "output": "Function: transform\n\nTransform data using discovered factors.\n\nArgs:\n    df: DataFrame with same features as training\n    feature_cols: Feature columns (must match training)\n\nReturns:\n    DataFrame with factor columns", "source": "core\\_experimental\\genetic_factor_mining.py", "category": "alpha"}
{"instruction": "Explain the Get Best Formulas function", "input": "", "output": "Function: get_best_formulas\n\nGet the best factor formulas.", "source": "core\\_experimental\\genetic_factor_mining.py", "category": "alpha"}
{"instruction": "Explain the Mine function", "input": "", "output": "Function: mine\n\nMine factors using DEAP.", "source": "core\\_experimental\\genetic_factor_mining.py", "category": "alpha"}
{"instruction": "Explain the Mine Factors function", "input": "", "output": "Function: mine_factors\n\nMine factors from data.", "source": "core\\_experimental\\genetic_factor_mining.py", "category": "alpha"}
{"instruction": "Explain the Generate Factor Features function", "input": "", "output": "Function: generate_factor_features\n\nGenerate features using discovered factors.", "source": "core\\_experimental\\genetic_factor_mining.py", "category": "alpha"}
{"instruction": "Explain the Get Factor Report function", "input": "", "output": "Function: get_factor_report\n\nGet report of discovered factors.", "source": "core\\_experimental\\genetic_factor_mining.py", "category": "alpha"}
{"instruction": "What is the formula for Compute All Features?", "input": "", "output": "Compute genetic programming derived features.\nInterface compatible with HFT Feature Engine.\n\nUses pre-defined genetic formulas for speed in HFT context.", "source": "core\\_experimental\\genetic_factor_mining.py", "category": "general"}
{"instruction": "Explain the Compute All Features function", "input": "", "output": "Function: compute_all_features\n\nCompute genetic programming derived features.\nInterface compatible with HFT Feature Engine.\n\nUses pre-defined genetic formulas for speed in HFT context.", "source": "core\\_experimental\\genetic_factor_mining.py", "category": "general"}
{"instruction": "Explain the purpose of Gold Standard Models - Missing Components from GitHub/Gitee Audit", "input": "", "output": "Gold Standard Models - Missing Components from GitHub/Gitee Audit\n==================================================================\nFills gaps identified in audit:\n1. iTransformer (ICLR 2024) - Inverted attention for time series\n2. TimeXer (NeurIPS 2024) - Exogenous factors support\n3. Attention Factor Model - Stat arb (Sharpe 4.0+)\n4. HftBacktest wrapper - Tick-level validation\n5. Optuna integration - Hyperparameter optimization\n6. Meta-labeling - Triple barrier with confidence\n7. Proper RL environment - Realistic trading simulation", "source": "core\\_experimental\\gold_standard_models.py", "category": "alpha"}
{"instruction": "What is the iTransformerForex class and how do I use it?", "input": "", "output": "The iTransformerForex class:\n\niTransformer: Inverted Transformers Are Effective for Time Series Forecasting\nPaper: https://arxiv.org/abs/2310.06625 (ICLR 2024 Spotlight)\n\nKey insight: Invert the attention mechanism - apply attention across\nvariates (features) instead of time steps. Better for multivariate forecasting.\n\nRequires: pip install iTransformer (or clone from github.com/thuml/iTransformer)", "source": "core\\_experimental\\gold_standard_models.py", "category": "risk"}
{"instruction": "What is the TimeXerForex class and how do I use it?", "input": "", "output": "The TimeXerForex class:\n\nTimeXer: Empowering Transformers for Time Series with Exogenous Variables\nPaper: NeurIPS 2024\n\nKey insight: Separate encoding for endogenous (price) and exogenous\n(economic indicators, news sentiment, related pairs) variables.\n\nPerfect for forex: EUR/USD affected by ECB rates, US NFP, GBP/USD correlation, etc.", "source": "core\\_experimental\\gold_standard_models.py", "category": "risk"}
{"instruction": "What is the AttentionFactorModel class and how do I use it?", "input": "", "output": "The AttentionFactorModel class:\n\nAttention-based Factor Model for Statistical Arbitrage\nPaper: arxiv:2510.11616 (November 2025)\n\nAchieves: Sharpe 4.0+ (before frictions), 2.3 (with frictions)\n84% improvement over previous SOTA\n\nKey insight: Use attention to dynamically weight pairs in stat arb basket.", "source": "core\\_experimental\\gold_standard_models.py", "category": "alpha"}
{"instruction": "What is the HftBacktestWrapper class and how do I use it?", "input": "", "output": "The HftBacktestWrapper class:\n\nWrapper for hftbacktest (github.com/nkaz001/hftbacktest)\n\nFeatures:\n- Complete tick-by-tick simulation\n- Order book reconstruction (L2/L3)\n- Feed latency modeling\n- Queue position-aware fills\n\nCritical for validating HFT strategies before live trading.", "source": "core\\_experimental\\gold_standard_models.py", "category": "microstructure"}
{"instruction": "What is the OptunaOptimizer class and how do I use it?", "input": "", "output": "The OptunaOptimizer class:\n\nOptuna wrapper for hyperparameter optimization.\n\nOptimizes model hyperparameters using Bayesian optimization.\nSupports time-series cross-validation for financial data.", "source": "core\\_experimental\\gold_standard_models.py", "category": "rl"}
{"instruction": "What is the MetaLabeler class and how do I use it?", "input": "", "output": "The MetaLabeler class:\n\nMeta-labeling from mlfinlab (Advances in Financial Machine Learning).\n\nTwo-stage approach:\n1. Primary model: Predicts direction (buy/sell)\n2. Meta model: Predicts if primary model is correct (confidence)\n\nOnly trade when meta model is confident.", "source": "core\\_experimental\\gold_standard_models.py", "category": "ensemble"}
{"instruction": "What is the ForexTradingEnv class and how do I use it?", "input": "", "output": "The ForexTradingEnv class:\n\nRealistic forex trading environment for RL.\n\nFeatures:\n- Realistic transaction costs (spread + commission)\n- Position limits\n- Overnight fees\n- Margin requirements\n- Slippage modeling", "source": "core\\_experimental\\gold_standard_models.py", "category": "microstructure"}
{"instruction": "What is the DLinearForex class and how do I use it?", "input": "", "output": "The DLinearForex class:\n\nDLinear: Are Transformers Effective for Time Series Forecasting?\nPaper: https://arxiv.org/abs/2205.13504 (AAAI 2023)\n\nKey insight: A simple linear model with trend-seasonality decomposition\noften outperforms complex transformers for time series forecasting.\n\nReference:\n    Zeng, A., et al. (2023). \"Are Transformers Effective for Time Series\n    Forecasting?\". AAAI 2023.", "source": "core\\_experimental\\gold_standard_models.py", "category": "time_series"}
{"instruction": "What is the PatchTSTForex class and how do I use it?", "input": "", "output": "The PatchTSTForex class:\n\nPatchTST: A Time Series is Worth 64 Words\nPaper: https://arxiv.org/abs/2211.14730 (ICLR 2023)\n\nKey insight: Patch time series into subseries-level patches,\nsimilar to image patches in ViT. More efficient than point-level tokens.\n\nReference:\n    Nie, Y., et al. (2023). \"A Time Series is Worth 64 Words: Long-term\n    Forecasting with Transformers\". ICLR 2023.", "source": "core\\_experimental\\gold_standard_models.py", "category": "time_series"}
{"instruction": "What is the TimeMixerForex class and how do I use it?", "input": "", "output": "The TimeMixerForex class:\n\nTimeMixer: Decomposable Multiscale Mixing for Time Series Forecasting\nPaper: https://arxiv.org/abs/2405.14616 (ICLR 2024)\n\nKey insight: Mix information across multiple temporal resolutions\nusing Past-Decomposable-Mixing and Future-Multipredictor-Mixing.\n\nReference:\n    Wang, S., et al. (2024). \"TimeMixer: Decomposable Multiscale Mixing\n    for Time Series Forecasting\". ICLR 2024.", "source": "core\\_experimental\\gold_standard_models.py", "category": "time_series"}
{"instruction": "Explain the Get Gold Standard Models function", "input": "", "output": "Function: get_gold_standard_models\n\nGet all gold standard models.\n\nReturns dict of initialized model classes.", "source": "core\\_experimental\\gold_standard_models.py", "category": "general"}
{"instruction": "Explain the Build Model function", "input": "", "output": "Function: build_model\n\nBuild iTransformer model.", "source": "core\\_experimental\\gold_standard_models.py", "category": "general"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nGenerate predictions.\n\nArgs:\n    data: (batch, seq_len, features) or (seq_len, features)\n\nReturns:\n    predictions: (batch, pred_len, features)", "source": "core\\_experimental\\gold_standard_models.py", "category": "general"}
{"instruction": "Explain the Build Model function", "input": "", "output": "Function: build_model\n\nBuild TimeXer model.", "source": "core\\_experimental\\gold_standard_models.py", "category": "general"}
{"instruction": "What is the formula for Predict?", "input": "", "output": "Predict using both endogenous and exogenous data.\n\nArgs:\n    endogenous: Price data (batch, seq_len, 1)\n    exogenous: External factors (batch, seq_len, n_exo)\n        - Economic indicators (GDP, CPI, NFP)\n        - Related pair prices (EUR/GBP for EUR/USD)\n        - Sentiment scores\n        - Volatility indices", "source": "core\\_experimental\\gold_standard_models.py", "category": "alpha"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nPredict using both endogenous and exogenous data.\n\nArgs:\n    endogenous: Price data (batch, seq_len, 1)\n    exogenous: External factors (batch, seq_len, n_exo)\n        - Economic indicators (GDP, CPI, NFP)\n        - Related pair prices (EUR/GBP for EUR/USD)\n        - Sentiment scores\n        - Volatility indices", "source": "core\\_experimental\\gold_standard_models.py", "category": "alpha"}
{"instruction": "What is the formula for Prepare Exogenous Features?", "input": "", "output": "Prepare exogenous features for forex trading.\n\nRecommended exogenous variables:\n1. Related pairs (EUR/GBP, GBP/JPY for EUR/USD)\n2. DXY (Dollar Index)\n3. VIX (Volatility Index)\n4. Bond yield spreads\n5. Economic calendar events (binary)\n6. Session indicators (London, NY, Tokyo)\n7. Day of week\n8. Hour of day", "source": "core\\_experimental\\gold_standard_models.py", "category": "volatility"}
{"instruction": "Explain the Prepare Exogenous Features function", "input": "", "output": "Function: prepare_exogenous_features\n\nPrepare exogenous features for forex trading.\n\nRecommended exogenous variables:\n1. Related pairs (EUR/GBP, GBP/JPY for EUR/USD)\n2. DXY (Dollar Index)\n3. VIX (Volatility Index)\n4. Bond yield spreads\n5. Economic calendar events (binary)\n6. Session indicators (London, NY, Tokyo)\n7. Day of week\n8. Hour of day", "source": "core\\_experimental\\gold_standard_models.py", "category": "volatility"}
{"instruction": "Explain the Build Model function", "input": "", "output": "Function: build_model\n\nBuild attention factor model.", "source": "core\\_experimental\\gold_standard_models.py", "category": "alpha"}
{"instruction": "What is the formula for Get Portfolio Weights?", "input": "", "output": "Get market-neutral portfolio weights.\n\nArgs:\n    returns_matrix: (lookback, n_pairs) matrix of returns\n\nReturns:\n    weights: Portfolio weights (sum to 0)\n    attention: Attention matrix showing pair relationships", "source": "core\\_experimental\\gold_standard_models.py", "category": "general"}
{"instruction": "Explain the Get Portfolio Weights function", "input": "", "output": "Function: get_portfolio_weights\n\nGet market-neutral portfolio weights.\n\nArgs:\n    returns_matrix: (lookback, n_pairs) matrix of returns\n\nReturns:\n    weights: Portfolio weights (sum to 0)\n    attention: Attention matrix showing pair relationships", "source": "core\\_experimental\\gold_standard_models.py", "category": "general"}
{"instruction": "Explain the Generate Signals function", "input": "", "output": "Function: generate_signals\n\nGenerate trading signals for a basket of currency pairs.\n\nArgs:\n    prices_df: DataFrame with pair prices as columns\n    pairs: List of pair names to trade\n\nReturns:\n    DataFrame with signals and weights per pair", "source": "core\\_experimental\\gold_standard_models.py", "category": "alpha"}
{"instruction": "Explain the Setup function", "input": "", "output": "Function: setup\n\nSetup backtest with tick data.\n\nArgs:\n    tick_data: DataFrame with columns [timestamp, bid, ask, bid_size, ask_size]", "source": "core\\_experimental\\gold_standard_models.py", "category": "microstructure"}
{"instruction": "Explain the Run Backtest function", "input": "", "output": "Function: run_backtest\n\nRun backtest with strategy function.\n\nArgs:\n    strategy_fn: Function that takes (bid, ask, position) and returns action\n\nReturns:\n    Performance metrics", "source": "core\\_experimental\\gold_standard_models.py", "category": "microstructure"}
{"instruction": "Explain the Optimize Xgboost function", "input": "", "output": "Function: optimize_xgboost\n\nOptimize XGBoost hyperparameters.\n\nReturns best parameters and validation score.", "source": "core\\_experimental\\gold_standard_models.py", "category": "general"}
{"instruction": "Explain the Optimize Transformer function", "input": "", "output": "Function: optimize_transformer\n\nOptimize transformer hyperparameters.", "source": "core\\_experimental\\gold_standard_models.py", "category": "general"}
{"instruction": "What is the formula for Get Triple Barrier Labels?", "input": "", "output": "Apply triple barrier method.\n\nBarriers:\n1. Upper barrier (profit take)\n2. Lower barrier (stop loss)\n3. Vertical barrier (max holding time)\n\nLabel: +1 (hit upper), -1 (hit lower), 0 (hit vertical)", "source": "core\\_experimental\\gold_standard_models.py", "category": "general"}
{"instruction": "Explain the Get Triple Barrier Labels function", "input": "", "output": "Function: get_triple_barrier_labels\n\nApply triple barrier method.\n\nBarriers:\n1. Upper barrier (profit take)\n2. Lower barrier (stop loss)\n3. Vertical barrier (max holding time)\n\nLabel: +1 (hit upper), -1 (hit lower), 0 (hit vertical)", "source": "core\\_experimental\\gold_standard_models.py", "category": "general"}
{"instruction": "What is OFI in quantitative trading?", "input": "", "output": "OFI (Order Flow Imbalance).\n\nImplementation details:\nApply triple barrier method.\n\nBarriers:\n1. Upper barrier (profit take)\n2. Lower barrier (stop loss)\n3. Vertical barrier (max holding time)\n\nLabel: +1 (hit upper), -1 (hit lower), 0 (hit vertical)", "source": "core\\_experimental\\gold_standard_models.py", "category": "general"}
{"instruction": "Explain the Train Meta Model function", "input": "", "output": "Function: train_meta_model\n\nTrain meta model to predict if primary model is correct.\n\nArgs:\n    X: Features\n    primary_predictions: Primary model's predictions\n    actual_labels: Actual outcomes\n\nReturns:\n    Trained meta model", "source": "core\\_experimental\\gold_standard_models.py", "category": "ensemble"}
{"instruction": "Explain the Get Trade Confidence function", "input": "", "output": "Function: get_trade_confidence\n\nGet confidence for each trade.\n\nReturns probability that primary model is correct.", "source": "core\\_experimental\\gold_standard_models.py", "category": "general"}
{"instruction": "Explain the Reset function", "input": "", "output": "Function: reset\n\nReset environment with new data.", "source": "core\\_experimental\\gold_standard_models.py", "category": "general"}
{"instruction": "What is the formula for Step?", "input": "", "output": "Execute action.\n\nActions:\n0 = Hold\n1 = Buy (go long)\n2 = Sell (go short)\n3 = Close position", "source": "core\\_experimental\\gold_standard_models.py", "category": "general"}
{"instruction": "Explain the Step function", "input": "", "output": "Function: step\n\nExecute action.\n\nActions:\n0 = Hold\n1 = Buy (go long)\n2 = Sell (go short)\n3 = Close position", "source": "core\\_experimental\\gold_standard_models.py", "category": "general"}
{"instruction": "Explain the Build Model function", "input": "", "output": "Function: build_model\n\nBuild DLinear model using PyTorch.", "source": "core\\_experimental\\gold_standard_models.py", "category": "general"}
{"instruction": "Explain the Fit function", "input": "", "output": "Function: fit\n\nTrain DLinear model.", "source": "core\\_experimental\\gold_standard_models.py", "category": "general"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nMake predictions.", "source": "core\\_experimental\\gold_standard_models.py", "category": "general"}
{"instruction": "Explain the Build Model function", "input": "", "output": "Function: build_model\n\nBuild PatchTST model using PyTorch.", "source": "core\\_experimental\\gold_standard_models.py", "category": "general"}
{"instruction": "Explain the Fit function", "input": "", "output": "Function: fit\n\nTrain PatchTST model.", "source": "core\\_experimental\\gold_standard_models.py", "category": "general"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nMake predictions.", "source": "core\\_experimental\\gold_standard_models.py", "category": "general"}
{"instruction": "Explain the Build Model function", "input": "", "output": "Function: build_model\n\nBuild TimeMixer model using PyTorch.", "source": "core\\_experimental\\gold_standard_models.py", "category": "general"}
{"instruction": "Explain the Fit function", "input": "", "output": "Function: fit\n\nTrain TimeMixer model.", "source": "core\\_experimental\\gold_standard_models.py", "category": "general"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nMake predictions.", "source": "core\\_experimental\\gold_standard_models.py", "category": "general"}
{"instruction": "What is the InvertedAttention class and how do I use it?", "input": "", "output": "The InvertedAttention class:\n\nAttention across variates instead of time.", "source": "core\\_experimental\\gold_standard_models.py", "category": "risk"}
{"instruction": "What is the MovingAvg class and how do I use it?", "input": "", "output": "The MovingAvg class:\n\nMoving average block for trend extraction.", "source": "core\\_experimental\\gold_standard_models.py", "category": "general"}
{"instruction": "What is the Patching class and how do I use it?", "input": "", "output": "The Patching class:\n\nPatch embedding for time series.", "source": "core\\_experimental\\gold_standard_models.py", "category": "general"}
{"instruction": "What is the MultiScaleDecomp class and how do I use it?", "input": "", "output": "The MultiScaleDecomp class:\n\nMulti-scale decomposition via average pooling.", "source": "core\\_experimental\\gold_standard_models.py", "category": "general"}
{"instruction": "What is the MixingBlock class and how do I use it?", "input": "", "output": "The MixingBlock class:\n\nMixing block for multi-scale features.", "source": "core\\_experimental\\gold_standard_models.py", "category": "general"}
{"instruction": "Explain the purpose of Gold Standard Predictor - Unified Interface", "input": "", "output": "Gold Standard Predictor - Unified Interface\n=============================================\nCombines ALL verified models from GitHub/Gitee audit into single predictor.\n\nComponents:\n1. iTransformer (ICLR 2024) - Time series forecasting\n2. TimeXer (NeurIPS 2024) - Exogenous factors\n3. Attention Factor Model - Stat arb\n4. HMM (Renaissance) - Regime detection\n5. Kalman Filter (Goldman) - Dynamic mean\n6. XGBoost/LightGBM/CatBoost - Gradient boosting\n7. PPO/SAC - RL position sizing\n8. Meta-labeling - Trade confidence\n9. Renaissance weak signals - 50+ signals\n10. WorldQuant Alpha101 - Factor generation\n\nTarget: 70%+ accuracy ensemble", "source": "core\\_experimental\\gold_standard_predictor.py", "category": "alpha"}
{"instruction": "What is the PredictionResult class and how do I use it?", "input": "", "output": "The PredictionResult class:\n\nUnified prediction result.", "source": "core\\_experimental\\gold_standard_predictor.py", "category": "general"}
{"instruction": "What is the GoldStandardPredictor class and how do I use it?", "input": "", "output": "The GoldStandardPredictor class:\n\nMaster predictor combining ALL gold standard models.\n\nUsage:\n    predictor = GoldStandardPredictor()\n    predictor.load_models(Path(\"models/gold_standard\"))\n\n    result = predictor.predict(\"EURUSD\", data)\n    print(f\"Signal: {result.signal}, Confidence: {result.confidence}\")", "source": "core\\_experimental\\gold_standard_predictor.py", "category": "alpha"}
{"instruction": "Show me a code example for GoldStandardPredictor", "input": "", "output": "predictor = GoldStandardPredictor()\n    predictor.load_models(Path(\"models/gold_standard\"))", "source": "core\\_experimental\\gold_standard_predictor.py", "category": "alpha"}
{"instruction": "What is the formula for Create Gold Standard Predictor?", "input": "", "output": "Create and initialize gold standard predictor.\n\nArgs:\n    models_dir: Path to trained models (default: models/gold_standard)", "source": "core\\_experimental\\gold_standard_predictor.py", "category": "general"}
{"instruction": "Explain the Create Gold Standard Predictor function", "input": "", "output": "Function: create_gold_standard_predictor\n\nCreate and initialize gold standard predictor.\n\nArgs:\n    models_dir: Path to trained models (default: models/gold_standard)", "source": "core\\_experimental\\gold_standard_predictor.py", "category": "general"}
{"instruction": "What is the formula for Load Models?", "input": "", "output": "Load trained models from directory.\n\nArgs:\n    models_dir: Path to models/gold_standard/\n\nReturns:\n    True if loaded successfully", "source": "core\\_experimental\\gold_standard_predictor.py", "category": "general"}
{"instruction": "Explain the Load Models function", "input": "", "output": "Function: load_models\n\nLoad trained models from directory.\n\nArgs:\n    models_dir: Path to models/gold_standard/\n\nReturns:\n    True if loaded successfully", "source": "core\\_experimental\\gold_standard_predictor.py", "category": "general"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nGenerate prediction using all models.\n\nArgs:\n    pair: Currency pair (e.g., \"EURUSD\")\n    data: DataFrame with OHLCV data\n\nReturns:\n    PredictionResult with signal, confidence, sizing", "source": "core\\_experimental\\gold_standard_predictor.py", "category": "alpha"}
{"instruction": "Explain the Get All Signals function", "input": "", "output": "Function: get_all_signals\n\nGet detailed signals from all models.\n\nUseful for debugging and analysis.", "source": "core\\_experimental\\gold_standard_predictor.py", "category": "alpha"}
{"instruction": "What is the source paper for this technique?", "input": "", "output": "The source is: A Survey on Graph Neural Networks for Time Series. ", "source": "core\\_experimental\\graph_neural_network.py", "category": "alpha"}
{"instruction": "Explain the purpose of Graph Neural Networks for Multi-Pair Forex Forecasting", "input": "", "output": "Graph Neural Networks for Multi-Pair Forex Forecasting\n=======================================================\nSource: \"A Survey on Graph Neural Networks for Time Series\" (arXiv 2024)\nMTGNN: \"Connecting the Dots: Multivariate Time Series Forecasting with Graph Neural Networks\"\n\nKey Innovation:\n- Model correlation structure between currency pairs as graph\n- Learn information flow between pairs\n- Capture lead-lag relationships\n- Cross-pair arbitrage signals\n\nFor HFT Forex:\n- EUR/USD influences GBP/USD (correlation)\n- USD strength affects all USD pairs\n- Risk-on/risk-off moves AUD, NZD vs JPY, CHF", "source": "core\\_experimental\\graph_neural_network.py", "category": "alpha"}
{"instruction": "What is the GNNConfig class and how do I use it?", "input": "", "output": "The GNNConfig class:\n\nGNN configuration.", "source": "core\\_experimental\\graph_neural_network.py", "category": "general"}
{"instruction": "What is the GraphConvolution class and how do I use it?", "input": "", "output": "The GraphConvolution class:\n\nGraph Convolution Layer.\n\nAggregates information from neighboring nodes (correlated pairs).", "source": "core\\_experimental\\graph_neural_network.py", "category": "volatility"}
{"instruction": "What is the TemporalConvolution class and how do I use it?", "input": "", "output": "The TemporalConvolution class:\n\nTemporal Convolution for time series on graph nodes.\n\nCaptures temporal patterns for each node (currency pair).", "source": "core\\_experimental\\graph_neural_network.py", "category": "volatility"}
{"instruction": "What is the SpatioTemporalBlock class and how do I use it?", "input": "", "output": "The SpatioTemporalBlock class:\n\nCombined spatial (graph) and temporal processing.\n\n1. Temporal convolution per node\n2. Graph convolution across nodes\n3. Residual connection", "source": "core\\_experimental\\graph_neural_network.py", "category": "volatility"}
{"instruction": "What is the AdaptiveGraphLearner class and how do I use it?", "input": "", "output": "The AdaptiveGraphLearner class:\n\nLearn graph structure from data.\n\nInstead of fixed correlation matrix, learn optimal\nadjacency from node embeddings.", "source": "core\\_experimental\\graph_neural_network.py", "category": "general"}
{"instruction": "What is the MTGNN class and how do I use it?", "input": "", "output": "The MTGNN class:\n\nMultivariate Time Series Graph Neural Network.\n\nFor forex: each node = currency pair\nEdges = correlation/causality between pairs\n\nArchitecture:\n1. Learn graph structure or use correlation matrix\n2. Spatiotemporal blocks: temporal conv + graph conv\n3. Output layer for each node", "source": "core\\_experimental\\graph_neural_network.py", "category": "risk"}
{"instruction": "What is the GNNForex class and how do I use it?", "input": "", "output": "The GNNForex class:\n\nGraph Neural Network for multi-pair forex trading.\n\nPairs as nodes:\n- EURUSD, GBPUSD, USDJPY, USDCHF, AUDUSD, NZDUSD, USDCAD\n\nEdges based on:\n- Historical correlation\n- Shared USD exposure\n- Risk-on/risk-off grouping", "source": "core\\_experimental\\graph_neural_network.py", "category": "risk"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nArgs:\n    x: [B, N, F] node features\n    adj: [N, N] adjacency matrix\n\nReturns:\n    [B, N, F'] transformed features", "source": "core\\_experimental\\graph_neural_network.py", "category": "general"}
{"instruction": "What is the formula for Forward?", "input": "", "output": "Args:\n    x: [B, N, T, F] where N=nodes, T=time, F=features\n\nReturns:\n    [B, N, T, F'] temporal features", "source": "core\\_experimental\\graph_neural_network.py", "category": "general"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nArgs:\n    x: [B, N, T, F] where N=nodes, T=time, F=features\n\nReturns:\n    [B, N, T, F'] temporal features", "source": "core\\_experimental\\graph_neural_network.py", "category": "general"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nArgs:\n    x: [B, N, T, F] spatiotemporal tensor\n    adj: [N, N] adjacency matrix\n\nReturns:\n    [B, N, T, F'] processed tensor", "source": "core\\_experimental\\graph_neural_network.py", "category": "general"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nReturn learned adjacency matrix.", "source": "core\\_experimental\\graph_neural_network.py", "category": "general"}
{"instruction": "Explain the Get Adjacency function", "input": "", "output": "Function: get_adjacency\n\nGet adjacency matrix (fixed or learned).", "source": "core\\_experimental\\graph_neural_network.py", "category": "general"}
{"instruction": "What is the formula for Forward?", "input": "", "output": "Args:\n    x: [B, N, T, F] multi-pair time series\n\nReturns:\n    [B, N, output_dim] predictions per pair", "source": "core\\_experimental\\graph_neural_network.py", "category": "general"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nArgs:\n    x: [B, N, T, F] multi-pair time series\n\nReturns:\n    [B, N, output_dim] predictions per pair", "source": "core\\_experimental\\graph_neural_network.py", "category": "general"}
{"instruction": "What is the formula for Prepare Multi Pair Data?", "input": "", "output": "Prepare data for all pairs.\n\nArgs:\n    pair_data: Dict[pair -> DataFrame with OHLCV]\n\nReturns:\n    [T, N, F] tensor", "source": "core\\_experimental\\graph_neural_network.py", "category": "general"}
{"instruction": "Explain the Prepare Multi Pair Data function", "input": "", "output": "Function: prepare_multi_pair_data\n\nPrepare data for all pairs.\n\nArgs:\n    pair_data: Dict[pair -> DataFrame with OHLCV]\n\nReturns:\n    [T, N, F] tensor", "source": "core\\_experimental\\graph_neural_network.py", "category": "general"}
{"instruction": "What is the formula for Fit?", "input": "", "output": "Train GNN on multi-pair data.", "source": "core\\_experimental\\graph_neural_network.py", "category": "general"}
{"instruction": "Explain the Fit function", "input": "", "output": "Function: fit\n\nTrain GNN on multi-pair data.", "source": "core\\_experimental\\graph_neural_network.py", "category": "general"}
{"instruction": "What is the formula for Predict?", "input": "", "output": "Predict direction for all pairs.\n\nReturns:\n    Dict[pair -> probability of up move]", "source": "core\\_experimental\\graph_neural_network.py", "category": "general"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nPredict direction for all pairs.\n\nReturns:\n    Dict[pair -> probability of up move]", "source": "core\\_experimental\\graph_neural_network.py", "category": "general"}
{"instruction": "What is the formula for Get Cross Pair Signals?", "input": "", "output": "Get cross-pair arbitrage signals.\n\nIdentifies divergent pairs and mean-reversion opportunities.", "source": "core\\_experimental\\graph_neural_network.py", "category": "alpha"}
{"instruction": "Explain the Get Cross Pair Signals function", "input": "", "output": "Function: get_cross_pair_signals\n\nGet cross-pair arbitrage signals.\n\nIdentifies divergent pairs and mean-reversion opportunities.", "source": "core\\_experimental\\graph_neural_network.py", "category": "alpha"}
{"instruction": "What is PPO in quantitative trading?", "input": "", "output": "PPO (Proximal Policy Optimization).\n\nImplementation details:\nGet cross-pair arbitrage signals.\n\nIdentifies divergent pairs and mean-reversion opportunities.", "source": "core\\_experimental\\graph_neural_network.py", "category": "alpha"}
{"instruction": "What is the source paper for this technique?", "input": "", "output": "The source is: Corsi (2009). ", "source": "core\\_experimental\\har_rv_volatility.py", "category": "volatility"}
{"instruction": "Explain the purpose of HAR-RV: Heterogeneous Autoregressive Realized Volatility", "input": "", "output": "HAR-RV: Heterogeneous Autoregressive Realized Volatility\n=========================================================\nSource: Corsi (2009) \"A Simple Approximate Long-Memory Model of Realized Volatility\"\nVerified from: CSDN Chinese quant sources (HAR-RV波动率)\n\nThe HAR-RV model captures multi-scale volatility dynamics:\n- Daily (RV_d): Short-term volatility\n- Weekly (RV_w): Medium-term volatility\n- Monthly (RV_m): Long-term volatility\n\nExtensions:\n- HAR-RV-J: Adds jump component\n- HAR-RV-CJ: Continuous + Jump decomposition\n- HAR-RV-SJ: Signed jumps (positive/negative asymmetry)\n\nAdapted for forex tick-level and minute-level data.", "source": "core\\_experimental\\har_rv_volatility.py", "category": "volatility"}
{"instruction": "What is the HARRVVolatility class and how do I use it?", "input": "", "output": "The HARRVVolatility class:\n\nHAR-RV: Heterogeneous Autoregressive Realized Volatility Model\n\nFormula:\n    RV_t+1 = β₀ + β_d * RV_d,t + β_w * RV_w,t + β_m * RV_m,t + ε_t+1\n\nUsage:\n    har = HARRVVolatility()\n    har.fit(returns)\n    forecast = har.predict(returns)\n    regime = har.get_volatility_regime(returns)", "source": "core\\_experimental\\har_rv_volatility.py", "category": "volatility"}
{"instruction": "Show me a code example for HARRVVolatility", "input": "", "output": "har = HARRVVolatility()\n    har.fit(returns)\n    forecast = har.predict(returns)\n    regime = har.get_volatility_regime(returns)", "source": "core\\_experimental\\har_rv_volatility.py", "category": "volatility"}
{"instruction": "What is the HARRVForex class and how do I use it?", "input": "", "output": "The HARRVForex class:\n\nHAR-RV specialized for forex tick data.\n\nAdjustments:\n- 24-hour market (no overnight gaps)\n- Tick-level realized volatility\n- Session-aware components (Asian/London/NY)", "source": "core\\_experimental\\har_rv_volatility.py", "category": "volatility"}
{"instruction": "What is the formula for Compute Realized Volatility?", "input": "", "output": "Compute realized volatility from returns.\n\nFormula: RV = sqrt(sum(r_i^2))\n\nArgs:\n    returns: Return series\n    window: Rolling window for aggregation\n    squared: If True, return RV^2 (variance), else return RV (std)\n\nReturns:\n    Realized volatility series", "source": "core\\_experimental\\har_rv_volatility.py", "category": "volatility"}
{"instruction": "Explain the Compute Realized Volatility function", "input": "", "output": "Function: compute_realized_volatility\n\nCompute realized volatility from returns.\n\nFormula: RV = sqrt(sum(r_i^2))\n\nArgs:\n    returns: Return series\n    window: Rolling window for aggregation\n    squared: If True, return RV^2 (variance), else return RV (std)\n\nReturns:\n    Realized volatility series", "source": "core\\_experimental\\har_rv_volatility.py", "category": "volatility"}
{"instruction": "What is the formula for Compute Bipower Variation?", "input": "", "output": "Compute Bipower Variation (BPV) - robust to jumps.\n\nFormula: BPV = (π/2) * sum(|r_i| * |r_{i-1}|)\n\nUsed to separate continuous volatility from jumps.", "source": "core\\_experimental\\har_rv_volatility.py", "category": "volatility"}
{"instruction": "Explain the Compute Bipower Variation function", "input": "", "output": "Function: compute_bipower_variation\n\nCompute Bipower Variation (BPV) - robust to jumps.\n\nFormula: BPV = (π/2) * sum(|r_i| * |r_{i-1}|)\n\nUsed to separate continuous volatility from jumps.", "source": "core\\_experimental\\har_rv_volatility.py", "category": "volatility"}
{"instruction": "What is the formula for Compute Jump Component?", "input": "", "output": "Compute jump component: RV - BPV (truncated at 0).\n\nJumps are the difference between realized variance and bipower variation.", "source": "core\\_experimental\\har_rv_volatility.py", "category": "risk"}
{"instruction": "Explain the Compute Jump Component function", "input": "", "output": "Function: compute_jump_component\n\nCompute jump component: RV - BPV (truncated at 0).\n\nJumps are the difference between realized variance and bipower variation.", "source": "core\\_experimental\\har_rv_volatility.py", "category": "risk"}
{"instruction": "Explain the Compute Signed Jumps function", "input": "", "output": "Function: compute_signed_jumps\n\nCompute signed jump components (positive and negative).\n\nReturns:\n    Tuple of (positive_jumps, negative_jumps)", "source": "core\\_experimental\\har_rv_volatility.py", "category": "general"}
{"instruction": "Explain the Compute Continuous Volatility function", "input": "", "output": "Function: compute_continuous_volatility\n\nCompute continuous component of volatility (BPV capped at RV).", "source": "core\\_experimental\\har_rv_volatility.py", "category": "volatility"}
{"instruction": "Explain the Compute Har Components function", "input": "", "output": "Function: compute_har_components\n\nCompute daily, weekly, monthly RV components for HAR model.\n\nArgs:\n    rv: Realized volatility series (squared returns)\n\nReturns:\n    DataFrame with rv_daily, rv_weekly, rv_monthly columns", "source": "core\\_experimental\\har_rv_volatility.py", "category": "volatility"}
{"instruction": "What is the formula for Fit?", "input": "", "output": "Fit HAR-RV model using OLS.\n\nArgs:\n    returns: Return series\n    method: 'basic' (HAR-RV), 'jump' (HAR-RV-J), 'cj' (HAR-RV-CJ), 'sj' (HAR-RV-SJ)\n\nReturns:\n    Self for method chaining", "source": "core\\_experimental\\har_rv_volatility.py", "category": "general"}
{"instruction": "Explain the Fit function", "input": "", "output": "Function: fit\n\nFit HAR-RV model using OLS.\n\nArgs:\n    returns: Return series\n    method: 'basic' (HAR-RV), 'jump' (HAR-RV-J), 'cj' (HAR-RV-CJ), 'sj' (HAR-RV-SJ)\n\nReturns:\n    Self for method chaining", "source": "core\\_experimental\\har_rv_volatility.py", "category": "general"}
{"instruction": "What is the formula for Predict?", "input": "", "output": "Predict next-period volatility.\n\nArgs:\n    returns: Return series\n    steps: Number of steps ahead (1 for next period)\n\nReturns:\n    Predicted volatility series", "source": "core\\_experimental\\har_rv_volatility.py", "category": "volatility"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nPredict next-period volatility.\n\nArgs:\n    returns: Return series\n    steps: Number of steps ahead (1 for next period)\n\nReturns:\n    Predicted volatility series", "source": "core\\_experimental\\har_rv_volatility.py", "category": "volatility"}
{"instruction": "What is the formula for Predict With Jumps?", "input": "", "output": "Predict volatility including jump component (HAR-RV-J).", "source": "core\\_experimental\\har_rv_volatility.py", "category": "volatility"}
{"instruction": "Explain the Predict With Jumps function", "input": "", "output": "Function: predict_with_jumps\n\nPredict volatility including jump component (HAR-RV-J).", "source": "core\\_experimental\\har_rv_volatility.py", "category": "volatility"}
{"instruction": "Explain the Forecast Volatility function", "input": "", "output": "Function: forecast_volatility\n\nGet point forecast for future volatility.\n\nArgs:\n    returns: Return series\n    horizon: Forecast horizon in periods\n    annualize: Whether to annualize the volatility\n\nReturns:\n    Volatility forecast", "source": "core\\_experimental\\har_rv_volatility.py", "category": "volatility"}
{"instruction": "Explain the Get Volatility Regime function", "input": "", "output": "Function: get_volatility_regime\n\nClassify volatility regime: low, normal, high.\n\nArgs:\n    returns: Return series\n    low_percentile: Percentile threshold for low volatility\n    high_percentile: Percentile threshold for high volatility\n\nReturns:\n    Series with regime labels ('low', 'normal', 'high')", "source": "core\\_experimental\\har_rv_volatility.py", "category": "volatility"}
{"instruction": "What is the formula for Get Volatility Percentile?", "input": "", "output": "Get rolling percentile rank of current volatility.\n\nReturns value between 0-100 indicating where current vol ranks historically.", "source": "core\\_experimental\\har_rv_volatility.py", "category": "volatility"}
{"instruction": "Explain the Get Volatility Percentile function", "input": "", "output": "Function: get_volatility_percentile\n\nGet rolling percentile rank of current volatility.\n\nReturns value between 0-100 indicating where current vol ranks historically.", "source": "core\\_experimental\\har_rv_volatility.py", "category": "volatility"}
{"instruction": "Explain the Detect Vol Breakout function", "input": "", "output": "Function: detect_vol_breakout\n\nDetect volatility breakouts (sudden vol spikes).\n\nArgs:\n    returns: Return series\n    lookback: Lookback period for baseline\n    threshold: Number of standard deviations for breakout\n\nReturns:\n    Boolean series indicating breakout", "source": "core\\_experimental\\har_rv_volatility.py", "category": "volatility"}
{"instruction": "What is the formula for Vol Mean Reversion Signal?", "input": "", "output": "Generate trading signals based on vol mean reversion.\n\nHigh vol = expect vol to drop = increase position\nLow vol = expect vol to spike = reduce position\n\nArgs:\n    returns: Return series\n    z_entry: Z-score threshold for entry\n    z_exit: Z-score threshold for exit\n\nReturns:\n    Signal series: 1 (increase), -1 (reduce), 0 (neutral)", "source": "core\\_experimental\\har_rv_volatility.py", "category": "alpha"}
{"instruction": "Explain the Vol Mean Reversion Signal function", "input": "", "output": "Function: vol_mean_reversion_signal\n\nGenerate trading signals based on vol mean reversion.\n\nHigh vol = expect vol to drop = increase position\nLow vol = expect vol to spike = reduce position\n\nArgs:\n    returns: Return series\n    z_entry: Z-score threshold for entry\n    z_exit: Z-score threshold for exit\n\nReturns:\n    Signal series: 1 (increase), -1 (reduce), 0 (neutral)", "source": "core\\_experimental\\har_rv_volatility.py", "category": "alpha"}
{"instruction": "What is the formula for Vol Momentum Signal?", "input": "", "output": "Generate signals based on volatility momentum.\n\nRising vol = reduce positions\nFalling vol = increase positions\n\nReturns:\n    Signal series: 1 (increasing risk), -1 (decreasing risk), 0 (neutral)", "source": "core\\_experimental\\har_rv_volatility.py", "category": "alpha"}
{"instruction": "Explain the Vol Momentum Signal function", "input": "", "output": "Function: vol_momentum_signal\n\nGenerate signals based on volatility momentum.\n\nRising vol = reduce positions\nFalling vol = increase positions\n\nReturns:\n    Signal series: 1 (increasing risk), -1 (decreasing risk), 0 (neutral)", "source": "core\\_experimental\\har_rv_volatility.py", "category": "alpha"}
{"instruction": "Explain the Get Model Summary function", "input": "", "output": "Function: get_model_summary\n\nGet summary of fitted model.", "source": "core\\_experimental\\har_rv_volatility.py", "category": "general"}
{"instruction": "Explain the Get Component Contributions function", "input": "", "output": "Function: get_component_contributions\n\nGet contribution of each HAR component to forecast.\n\nReturns DataFrame with daily, weekly, monthly contributions.", "source": "core\\_experimental\\har_rv_volatility.py", "category": "time_series"}
{"instruction": "Explain the Compute Session Rv function", "input": "", "output": "Function: compute_session_rv\n\nCompute realized volatility by trading session.\n\nReturns DataFrame with Asian, London, NY RV components.", "source": "core\\_experimental\\har_rv_volatility.py", "category": "volatility"}
{"instruction": "Explain the purpose of Institutional-Grade ML Predictor", "input": "", "output": "Institutional-Grade ML Predictor\n================================\nUses ACTUAL methods from billion-dollar quants:\n- Hidden Markov Models (Renaissance Technologies) - Regime detection\n- Kalman Filters (Goldman Sachs) - Dynamic parameter estimation\n- XGBoost/LightGBM/CatBoost ensemble (What actually wins)\n- WorldQuant Alpha101 (101 Formulaic Alphas)\n- Avellaneda-Stoikov (HFT Market Making)\n- Kelly Criterion (Optimal Position Sizing)\n- Triple Barrier Method (Lopez de Prado)\n\nNOT using (overfits/doesn't work):\n- Deep Learning / Neural Networks\n- Transformers\n- Deep RL", "source": "core\\_experimental\\institutional_predictor.py", "category": "alpha"}
{"instruction": "What is the InstitutionalPredictor class and how do I use it?", "input": "", "output": "The InstitutionalPredictor class:\n\nInstitutional-grade predictor using proven quant methods.\n\nThis class implements what billion-dollar quants ACTUALLY use:\n- HMM for regime detection (Renaissance)\n- Kalman filter for dynamic hedging (Goldman)\n- Gradient boosting ensemble (Industry standard)\n- WorldQuant Alpha101 (101 weak signals)\n- Avellaneda-Stoikov (Market making quotes)\n- Kelly Criterion (Position sizing)", "source": "core\\_experimental\\institutional_predictor.py", "category": "alpha"}
{"instruction": "What is the FallbackPredictor class and how do I use it?", "input": "", "output": "The FallbackPredictor class:\n\nSimple fallback predictor when institutional models aren't available.\nUses basic technical signals (still better than deep learning for forex).", "source": "core\\_experimental\\institutional_predictor.py", "category": "alpha"}
{"instruction": "Explain the Create Predictor function", "input": "", "output": "Function: create_predictor\n\nFactory function to create the appropriate predictor.", "source": "core\\_experimental\\institutional_predictor.py", "category": "alpha"}
{"instruction": "What is the formula for Load Models?", "input": "", "output": "Load all institutional-grade models.", "source": "core\\_experimental\\institutional_predictor.py", "category": "general"}
{"instruction": "Explain the Load Models function", "input": "", "output": "Function: load_models\n\nLoad all institutional-grade models.", "source": "core\\_experimental\\institutional_predictor.py", "category": "general"}
{"instruction": "What is the formula for Detect Regime?", "input": "", "output": "Detect market regime using Hidden Markov Model.\n\nThis is the Renaissance Technologies method:\n- Uses HMM to identify hidden market states\n- States typically represent: low vol, normal, high vol regimes\n- Adjust position sizing based on regime\n\nReturns:\n    Dict with regime info: state (0,1,2), probabilities, recommended action", "source": "core\\_experimental\\institutional_predictor.py", "category": "volatility"}
{"instruction": "Explain the Detect Regime function", "input": "", "output": "Function: detect_regime\n\nDetect market regime using Hidden Markov Model.\n\nThis is the Renaissance Technologies method:\n- Uses HMM to identify hidden market states\n- States typically represent: low vol, normal, high vol regimes\n- Adjust position sizing based on regime\n\nReturns:\n    Dict with regime info: state (0,1,2), probabilities, recommended action", "source": "core\\_experimental\\institutional_predictor.py", "category": "volatility"}
{"instruction": "What is HMM in quantitative trading?", "input": "", "output": "HMM (Hidden Markov Model for regime detection).\n\nImplementation details:\nDetect market regime using Hidden Markov Model.\n\nThis is the Renaissance Technologies method:\n- Uses HMM to identify hidden market states\n- States typically represent: low vol, normal, high vol regimes\n- Adjust position sizing based on regime\n\nReturns:\n    Dict with regime info: state (0,1,2), probabilities, recommended action", "source": "core\\_experimental\\institutional_predictor.py", "category": "volatility"}
{"instruction": "What is the formula for Get Kalman Estimate?", "input": "", "output": "Get Kalman filter estimate for trend/mean.\n\nThis is the Goldman Sachs method for market making:\n- Kalman filter estimates true underlying value\n- Deviation from estimate suggests mean reversion opportunity\n- Updates dynamically with each new observation\n\nReturns:\n    Dict with: estimated_mean, deviation, signal strength", "source": "core\\_experimental\\institutional_predictor.py", "category": "alpha"}
{"instruction": "Explain the Get Kalman Estimate function", "input": "", "output": "Function: get_kalman_estimate\n\nGet Kalman filter estimate for trend/mean.\n\nThis is the Goldman Sachs method for market making:\n- Kalman filter estimates true underlying value\n- Deviation from estimate suggests mean reversion opportunity\n- Updates dynamically with each new observation\n\nReturns:\n    Dict with: estimated_mean, deviation, signal strength", "source": "core\\_experimental\\institutional_predictor.py", "category": "alpha"}
{"instruction": "What is Kalman Filter in quantitative trading?", "input": "", "output": "Kalman Filter (state estimation and signal filtering).\n\nImplementation details:\nGet Kalman filter estimate for trend/mean.\n\nThis is the Goldman Sachs method for market making:\n- Kalman filter estimates true underlying value\n- Deviation from estimate suggests mean reversion opportunity\n- Updates dynamically with each new observation\n\nReturns:\n    Dict with: estimated_mean, deviation, signal strength", "source": "core\\_experimental\\institutional_predictor.py", "category": "alpha"}
{"instruction": "What is PPO in quantitative trading?", "input": "", "output": "PPO (Proximal Policy Optimization).\n\nImplementation details:\nGet Kalman filter estimate for trend/mean.\n\nThis is the Goldman Sachs method for market making:\n- Kalman filter estimates true underlying value\n- Deviation from estimate suggests mean reversion opportunity\n- Updates dynamically with each new observation\n\nReturns:\n    Dict with: estimated_mean, deviation, signal strength", "source": "core\\_experimental\\institutional_predictor.py", "category": "alpha"}
{"instruction": "What is the formula for Get Ensemble Prediction?", "input": "", "output": "Get ensemble prediction from XGBoost/LightGBM/CatBoost.\n\nThis is what actually wins in production:\n- Gradient boosting trees (NOT neural networks)\n- Ensemble of 3 models with weighted voting\n- Simple, interpretable, generalizes well\n\nReturns:\n    Tuple of (signal: 'long'/'short'/'neutral', confidence: 0-1)", "source": "core\\_experimental\\institutional_predictor.py", "category": "alpha"}
{"instruction": "Explain the Get Ensemble Prediction function", "input": "", "output": "Function: get_ensemble_prediction\n\nGet ensemble prediction from XGBoost/LightGBM/CatBoost.\n\nThis is what actually wins in production:\n- Gradient boosting trees (NOT neural networks)\n- Ensemble of 3 models with weighted voting\n- Simple, interpretable, generalizes well\n\nReturns:\n    Tuple of (signal: 'long'/'short'/'neutral', confidence: 0-1)", "source": "core\\_experimental\\institutional_predictor.py", "category": "alpha"}
{"instruction": "What is the formula for Predict?", "input": "", "output": "Full institutional-grade prediction combining all methods.\n\nCombines:\n1. HMM regime detection (position sizing adjustment)\n2. Kalman filter (mean reversion signal)\n3. Ensemble prediction (direction and confidence)\n\nReturns:\n    Dict with signal, confidence, regime, and recommendations", "source": "core\\_experimental\\institutional_predictor.py", "category": "alpha"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nFull institutional-grade prediction combining all methods.\n\nCombines:\n1. HMM regime detection (position sizing adjustment)\n2. Kalman filter (mean reversion signal)\n3. Ensemble prediction (direction and confidence)\n\nReturns:\n    Dict with signal, confidence, regime, and recommendations", "source": "core\\_experimental\\institutional_predictor.py", "category": "alpha"}
{"instruction": "What is HMM in quantitative trading?", "input": "", "output": "HMM (Hidden Markov Model for regime detection).\n\nImplementation details:\nFull institutional-grade prediction combining all methods.\n\nCombines:\n1. HMM regime detection (position sizing adjustment)\n2. Kalman filter (mean reversion signal)\n3. Ensemble prediction (direction and confidence)\n\nReturns:\n    Dict with signal, confidence, regime, and recommendations", "source": "core\\_experimental\\institutional_predictor.py", "category": "alpha"}
{"instruction": "What is Kalman Filter in quantitative trading?", "input": "", "output": "Kalman Filter (state estimation and signal filtering).\n\nImplementation details:\nFull institutional-grade prediction combining all methods.\n\nCombines:\n1. HMM regime detection (position sizing adjustment)\n2. Kalman filter (mean reversion signal)\n3. Ensemble prediction (direction and confidence)\n\nReturns:\n    Dict with signal, confidence, regime, and recommendations", "source": "core\\_experimental\\institutional_predictor.py", "category": "alpha"}
{"instruction": "What is the formula for Get Alpha101 Signals?", "input": "", "output": "Generate WorldQuant Alpha101 signals.\n\nThese are 101 formulaic alphas from WorldQuant research.\nEach alpha is a weak signal (51-55% accuracy) that contributes\nto ensemble predictions.\n\nArgs:\n    data: DataFrame with OHLCV or forex tick data\n\nReturns:\n    DataFrame with alpha signals added", "source": "core\\_experimental\\institutional_predictor.py", "category": "alpha"}
{"instruction": "Explain the Get Alpha101 Signals function", "input": "", "output": "Function: get_alpha101_signals\n\nGenerate WorldQuant Alpha101 signals.\n\nThese are 101 formulaic alphas from WorldQuant research.\nEach alpha is a weak signal (51-55% accuracy) that contributes\nto ensemble predictions.\n\nArgs:\n    data: DataFrame with OHLCV or forex tick data\n\nReturns:\n    DataFrame with alpha signals added", "source": "core\\_experimental\\institutional_predictor.py", "category": "alpha"}
{"instruction": "What is the formula for Get Market Making Quotes?", "input": "", "output": "Get Avellaneda-Stoikov optimal market making quotes.\n\nThis is the gold standard for HFT market making.\n\nArgs:\n    mid_price: Current mid price\n    inventory: Current position (positive = long)\n    time_remaining: Fraction of trading period remaining\n\nReturns:\n    Dict with bid, ask, and spread info", "source": "core\\_experimental\\institutional_predictor.py", "category": "microstructure"}
{"instruction": "Explain the Get Market Making Quotes function", "input": "", "output": "Function: get_market_making_quotes\n\nGet Avellaneda-Stoikov optimal market making quotes.\n\nThis is the gold standard for HFT market making.\n\nArgs:\n    mid_price: Current mid price\n    inventory: Current position (positive = long)\n    time_remaining: Fraction of trading period remaining\n\nReturns:\n    Dict with bid, ask, and spread info", "source": "core\\_experimental\\institutional_predictor.py", "category": "microstructure"}
{"instruction": "What is the formula for Calculate Position Size?", "input": "", "output": "Calculate optimal position size using Kelly Criterion.\n\nUses fractional Kelly (default 25%) for safety:\n- 50% Kelly = 75% optimal growth, 25% variance\n- 25% Kelly = 43.75% optimal growth, 6.25% variance\n\nArgs:\n    account_value: Total account value\n    win_prob: Probability of winning (from model confidence)\n    win_loss_ratio: Average win / Average loss\n    kelly_fraction: Fraction of full Kelly to use (0.25-0.5)\n\nReturns:\n    Dict with position sizing info", "source": "core\\_experimental\\institutional_predictor.py", "category": "risk"}
{"instruction": "Explain the Calculate Position Size function", "input": "", "output": "Function: calculate_position_size\n\nCalculate optimal position size using Kelly Criterion.\n\nUses fractional Kelly (default 25%) for safety:\n- 50% Kelly = 75% optimal growth, 25% variance\n- 25% Kelly = 43.75% optimal growth, 6.25% variance\n\nArgs:\n    account_value: Total account value\n    win_prob: Probability of winning (from model confidence)\n    win_loss_ratio: Average win / Average loss\n    kelly_fraction: Fraction of full Kelly to use (0.25-0.5)\n\nReturns:\n    Dict with position sizing info", "source": "core\\_experimental\\institutional_predictor.py", "category": "risk"}
{"instruction": "What is Kelly Criterion in quantitative trading?", "input": "", "output": "Kelly Criterion (position sizing formula that maximizes long-term growth).\n\nImplementation details:\nCalculate optimal position size using Kelly Criterion.\n\nUses fractional Kelly (default 25%) for safety:\n- 50% Kelly = 75% optimal growth, 25% variance\n- 25% Kelly = 43.75% optimal growth, 6.25% variance\n\nArgs:\n    account_value: Total account value\n    win_prob: Probability of winning (from model confidence)\n    win_loss_ratio: Average win / Average loss\n    kelly_fraction: Fraction of full Kelly to use (0.25-0.5)\n\nReturns:\n    Dict with position sizing info", "source": "core\\_experimental\\institutional_predictor.py", "category": "risk"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nGenerate prediction from simple signals.", "source": "core\\_experimental\\institutional_predictor.py", "category": "alpha"}
{"instruction": "Explain the purpose of Jump Detection and Bipower Variation for HFT Forex", "input": "", "output": "Jump Detection and Bipower Variation for HFT Forex\n===================================================\nRenaissance Technologies inference: Distinguishing continuous price\nevolution from discrete jumps (news, order flow shocks) is critical\nfor proper volatility estimation and position sizing.\n\nImplemented Methods:\n- Bipower Variation (BPV): Jump-robust volatility estimator\n- Realized Jump Variation: Extracts jump component\n- Relative Jump (RJ): Jump significance test\n- Jump Test Statistics: BNS, AJ, CPR tests\n- Self-Exciting Jumps: Hawkes process for jump clustering\n\nSources:\n- Barndorff-Nielsen & Shephard (2004) \"Power and Multipower Variations\"\n- Barndorff-Nielsen & Shephard (2006) \"Econometrics of Testing for Jumps\"\n- Andersen, Bollerslev, Diebold (2007) \"Roughing it Up\"\n- Lee & Mykland (2008) \"Jumps in Financial Markets\"\n- Ait-Sahalia & Jacod (2009) \"Testing for Jumps\"\n\nWhy Renaissance Uses This:\n- News events cause jumps, not continuous trading\n- GARCH assumes continuous dynamics (fails on jumps)\n- Jump detection → adjust position sizing, widen stops\n- Separate jump volatility from continuous volatility", "source": "core\\_experimental\\jump_detection.py", "category": "volatility"}
{"instruction": "What is the JumpResult class and how do I use it?", "input": "", "output": "The JumpResult class:\n\nResult from jump detection.", "source": "core\\_experimental\\jump_detection.py", "category": "general"}
{"instruction": "What is the VolatilityDecomposition class and how do I use it?", "input": "", "output": "The VolatilityDecomposition class:\n\nDecomposition of realized volatility into continuous and jump components.", "source": "core\\_experimental\\jump_detection.py", "category": "volatility"}
{"instruction": "What is the BipowerVariation class and how do I use it?", "input": "", "output": "The BipowerVariation class:\n\nBipower Variation for jump-robust volatility estimation.\n\nBPV_t = (π/2) * Σ |r_i| * |r_{i-1}|\n\nKey insight: BPV is robust to jumps because jumps are unlikely\nto occur in consecutive periods. If jump at time i:\n- |r_i| * |r_{i-1}| ≈ |jump| * |small_return| ≈ small contribution\n- vs RV: |r_i|² ≈ |jump|² = large contribution\n\nSource: Barndorff-Nielsen & Shephard (2004)", "source": "core\\_experimental\\jump_detection.py", "category": "volatility"}
{"instruction": "What is the JumpTest class and how do I use it?", "input": "", "output": "The JumpTest class:\n\nStatistical tests for jump detection.\n\nMultiple tests implemented:\n1. BNS test (Barndorff-Nielsen & Shephard)\n2. Ratio test\n3. Difference test\n\nAll test H0: No jumps vs H1: Jumps present", "source": "core\\_experimental\\jump_detection.py", "category": "general"}
{"instruction": "What is the LeeMyklandJumpTest class and how do I use it?", "input": "", "output": "The LeeMyklandJumpTest class:\n\nLee & Mykland (2008) instantaneous jump test.\n\nTests each individual return for jump significance,\nrather than testing for jumps in aggregate.\n\nAdvantage: Identifies WHICH observations are jumps", "source": "core\\_experimental\\jump_detection.py", "category": "general"}
{"instruction": "What is the JumpHawkesProcess class and how do I use it?", "input": "", "output": "The JumpHawkesProcess class:\n\nSelf-exciting jump process using Hawkes intensity.\n\nJumps tend to cluster: a jump increases probability of more jumps.\n\nλ(t) = λ₀ + Σ α·exp(-β(t - t_i))\n\nwhere t_i are past jump times.\n\nRenaissance Application:\n- After a jump, increase alertness for more jumps\n- Flash crash dynamics\n- News cascade effects\n\nSource: Hawkes (1971) \"Spectra of Some Self-Exciting and Mutually Exciting Point Processes\"", "source": "core\\_experimental\\jump_detection.py", "category": "general"}
{"instruction": "What is the JumpVolatilityModel class and how do I use it?", "input": "", "output": "The JumpVolatilityModel class:\n\nCombined continuous + jump volatility model.\n\nTotal variance = Continuous variance + Jump variance\n\nUses:\n1. BPV for continuous component\n2. Max(0, RV - BPV) for jump component\n3. Hawkes process for jump intensity\n\nRenaissance Application:\n- Separate trading signal from noise\n- Adjust position sizing based on jump risk\n- Wider stops during high jump intensity", "source": "core\\_experimental\\jump_detection.py", "category": "alpha"}
{"instruction": "What is the formula for Compute Jump Features?", "input": "", "output": "Convenience function to compute all jump-related features.\n\nArgs:\n    returns: Return series\n    window: Window for volatility estimation\n    significance: Significance level for jump tests\n\nReturns:\n    DataFrame with jump features", "source": "core\\_experimental\\jump_detection.py", "category": "volatility"}
{"instruction": "Explain the Compute Jump Features function", "input": "", "output": "Function: compute_jump_features\n\nConvenience function to compute all jump-related features.\n\nArgs:\n    returns: Return series\n    window: Window for volatility estimation\n    significance: Significance level for jump tests\n\nReturns:\n    DataFrame with jump features", "source": "core\\_experimental\\jump_detection.py", "category": "volatility"}
{"instruction": "What is the formula for Detect Jumps Simple?", "input": "", "output": "Simple threshold-based jump detection.\n\nA return is a jump if |r| > threshold * σ\n\nArgs:\n    returns: Return array\n    threshold_std: Number of standard deviations for jump threshold\n\nReturns:\n    Boolean array of jump indicators", "source": "core\\_experimental\\jump_detection.py", "category": "general"}
{"instruction": "Explain the Detect Jumps Simple function", "input": "", "output": "Function: detect_jumps_simple\n\nSimple threshold-based jump detection.\n\nA return is a jump if |r| > threshold * σ\n\nArgs:\n    returns: Return array\n    threshold_std: Number of standard deviations for jump threshold\n\nReturns:\n    Boolean array of jump indicators", "source": "core\\_experimental\\jump_detection.py", "category": "general"}
{"instruction": "What is the formula for Realized Variance?", "input": "", "output": "Compute realized variance (sum of squared returns).\n\nRV = Σ r²_i", "source": "core\\_experimental\\jump_detection.py", "category": "risk"}
{"instruction": "Explain the Realized Variance function", "input": "", "output": "Function: realized_variance\n\nCompute realized variance (sum of squared returns).\n\nRV = Σ r²_i", "source": "core\\_experimental\\jump_detection.py", "category": "risk"}
{"instruction": "What is the formula for Bipower Variance?", "input": "", "output": "Compute bipower variation (jump-robust).\n\nBPV = (π/2) * Σ |r_i| * |r_{i-1}|", "source": "core\\_experimental\\jump_detection.py", "category": "risk"}
{"instruction": "Explain the Bipower Variance function", "input": "", "output": "Function: bipower_variance\n\nCompute bipower variation (jump-robust).\n\nBPV = (π/2) * Σ |r_i| * |r_{i-1}|", "source": "core\\_experimental\\jump_detection.py", "category": "risk"}
{"instruction": "What is the formula for Tripower Quarticity?", "input": "", "output": "Tripower quarticity for variance estimation of BPV.\n\nTPQ = n * μ_{4/3}^{-3} * Σ |r_i|^{4/3} * |r_{i-1}|^{4/3} * |r_{i-2}|^{4/3}\n\nUsed in jump test statistic variance calculation.", "source": "core\\_experimental\\jump_detection.py", "category": "risk"}
{"instruction": "Explain the Tripower Quarticity function", "input": "", "output": "Function: tripower_quarticity\n\nTripower quarticity for variance estimation of BPV.\n\nTPQ = n * μ_{4/3}^{-3} * Σ |r_i|^{4/3} * |r_{i-1}|^{4/3} * |r_{i-2}|^{4/3}\n\nUsed in jump test statistic variance calculation.", "source": "core\\_experimental\\jump_detection.py", "category": "risk"}
{"instruction": "What is the formula for Quadpower Quarticity?", "input": "", "output": "Quadpower quarticity - alternative variance estimator.\n\nQPQ = n * μ_1^{-4} * Σ |r_i| * |r_{i-1}| * |r_{i-2}| * |r_{i-3}|", "source": "core\\_experimental\\jump_detection.py", "category": "risk"}
{"instruction": "Explain the Quadpower Quarticity function", "input": "", "output": "Function: quadpower_quarticity\n\nQuadpower quarticity - alternative variance estimator.\n\nQPQ = n * μ_1^{-4} * Σ |r_i| * |r_{i-1}| * |r_{i-2}| * |r_{i-3}|", "source": "core\\_experimental\\jump_detection.py", "category": "risk"}
{"instruction": "What is the formula for Rolling Rv Bpv?", "input": "", "output": "Compute rolling RV and BPV.\n\nReturns DataFrame with:\n- rv: Realized variance\n- bpv: Bipower variance\n- jump_var: max(0, RV - BPV)\n- relative_jump: jump_var / rv", "source": "core\\_experimental\\jump_detection.py", "category": "risk"}
{"instruction": "Explain the Rolling Rv Bpv function", "input": "", "output": "Function: rolling_rv_bpv\n\nCompute rolling RV and BPV.\n\nReturns DataFrame with:\n- rv: Realized variance\n- bpv: Bipower variance\n- jump_var: max(0, RV - BPV)\n- relative_jump: jump_var / rv", "source": "core\\_experimental\\jump_detection.py", "category": "risk"}
{"instruction": "What is the formula for Bns Test?", "input": "", "output": "Barndorff-Nielsen & Shephard (2006) jump test.\n\nTest statistic:\nZ = (RV - BPV) / sqrt(Var(RV - BPV))\n  = (RV - BPV) / sqrt((π²/4 + π - 5) * TPQ)\n\nUnder H0 (no jumps): Z → N(0, 1)\n\nReturns: (test_statistic, p_value, has_jump)", "source": "core\\_experimental\\jump_detection.py", "category": "risk"}
{"instruction": "Explain the Bns Test function", "input": "", "output": "Function: bns_test\n\nBarndorff-Nielsen & Shephard (2006) jump test.\n\nTest statistic:\nZ = (RV - BPV) / sqrt(Var(RV - BPV))\n  = (RV - BPV) / sqrt((π²/4 + π - 5) * TPQ)\n\nUnder H0 (no jumps): Z → N(0, 1)\n\nReturns: (test_statistic, p_value, has_jump)", "source": "core\\_experimental\\jump_detection.py", "category": "risk"}
{"instruction": "What is the formula for Ratio Test?", "input": "", "output": "Ratio-based jump test.\n\nTest statistic: RJ = 1 - BPV / RV\n\nUnder H0: RJ → 0\nLarge RJ indicates jumps", "source": "core\\_experimental\\jump_detection.py", "category": "general"}
{"instruction": "Explain the Ratio Test function", "input": "", "output": "Function: ratio_test\n\nRatio-based jump test.\n\nTest statistic: RJ = 1 - BPV / RV\n\nUnder H0: RJ → 0\nLarge RJ indicates jumps", "source": "core\\_experimental\\jump_detection.py", "category": "general"}
{"instruction": "Explain the Detect Jumps function", "input": "", "output": "Function: detect_jumps\n\nCombined jump detection using multiple tests.\n\nReturns JumpResult with comprehensive jump information.", "source": "core\\_experimental\\jump_detection.py", "category": "general"}
{"instruction": "What is the formula for Test Returns?", "input": "", "output": "Test each return for jump significance.\n\nReturns dict with:\n- is_jump: boolean array\n- jump_stats: test statistics\n- local_vol: local volatility estimates", "source": "core\\_experimental\\jump_detection.py", "category": "volatility"}
{"instruction": "Explain the Test Returns function", "input": "", "output": "Function: test_returns\n\nTest each return for jump significance.\n\nReturns dict with:\n- is_jump: boolean array\n- jump_stats: test statistics\n- local_vol: local volatility estimates", "source": "core\\_experimental\\jump_detection.py", "category": "volatility"}
{"instruction": "What is the formula for Intensity?", "input": "", "output": "Compute intensity at time t.\n\nλ(t) = λ₀ + Σ α·exp(-β(t - t_i))", "source": "core\\_experimental\\jump_detection.py", "category": "general"}
{"instruction": "Explain the Intensity function", "input": "", "output": "Function: intensity\n\nCompute intensity at time t.\n\nλ(t) = λ₀ + Σ α·exp(-β(t - t_i))", "source": "core\\_experimental\\jump_detection.py", "category": "general"}
{"instruction": "Explain the Update function", "input": "", "output": "Function: update\n\nUpdate process with new observation.", "source": "core\\_experimental\\jump_detection.py", "category": "general"}
{"instruction": "What is the formula for Jump Probability?", "input": "", "output": "Probability of jump in next period.\n\nP(jump) ≈ 1 - exp(-λ(t) * Δt)", "source": "core\\_experimental\\jump_detection.py", "category": "general"}
{"instruction": "Explain the Jump Probability function", "input": "", "output": "Function: jump_probability\n\nProbability of jump in next period.\n\nP(jump) ≈ 1 - exp(-λ(t) * Δt)", "source": "core\\_experimental\\jump_detection.py", "category": "general"}
{"instruction": "Explain the Simulate function", "input": "", "output": "Function: simulate\n\nSimulate Hawkes process.\n\nReturns array of jump indicators.", "source": "core\\_experimental\\jump_detection.py", "category": "general"}
{"instruction": "Explain the Decompose Volatility function", "input": "", "output": "Function: decompose_volatility\n\nFull volatility decomposition into continuous and jump components.", "source": "core\\_experimental\\jump_detection.py", "category": "volatility"}
{"instruction": "What is the formula for Compute Features?", "input": "", "output": "Compute jump-related features for ML.", "source": "core\\_experimental\\jump_detection.py", "category": "general"}
{"instruction": "Explain the Compute Features function", "input": "", "output": "Function: compute_features\n\nCompute jump-related features for ML.", "source": "core\\_experimental\\jump_detection.py", "category": "general"}
{"instruction": "Explain the purpose of Limit Order Book (LOB) Features for HFT", "input": "", "output": "Limit Order Book (LOB) Features for HFT\n========================================\nSources:\n- HftBacktest (nkaz001) - 3.5k stars\n- QuantsPlaybook - 券商金工研报\n- Cont et al. (2014) - Order Flow Imbalance\n- Cartea et al. (2015) - Algorithmic Trading\n\nGold Standard LOB Features Used by:\n- 幻方量化 (High-Flyer)\n- 九坤投资 (Ubiquant)\n- Citadel / Two Sigma / DE Shaw\n\nFeatures:\n1. Book Imbalance (多级不平衡)\n2. Queue Imbalance (队列不平衡)\n3. Trade Imbalance (Lee-Ready)\n4. Depth Imbalance (深度不平衡)\n5. Slope Features (订单簿斜率)\n6. Spread Decomposition (价差分解)\n7. Resilience (弹性)\n8. Price Impact Curve (价格冲击曲线)", "source": "core\\_experimental\\lob_features.py", "category": "execution"}
{"instruction": "What is the TradeDirection class and how do I use it?", "input": "", "output": "The TradeDirection class:\n\nTrade direction classification.", "source": "core\\_experimental\\lob_features.py", "category": "general"}
{"instruction": "What is the LOBSnapshot class and how do I use it?", "input": "", "output": "The LOBSnapshot class:\n\nSingle LOB snapshot.", "source": "core\\_experimental\\lob_features.py", "category": "general"}
{"instruction": "What is the LeeReadyClassifier class and how do I use it?", "input": "", "output": "The LeeReadyClassifier class:\n\nLee-Ready Trade Classification.\n\nSource: Lee & Ready (1991) - Classic algorithm\n\nRules:\n1. Quote Rule: Compare trade price to midpoint\n   - Above mid -> Buy\n   - Below mid -> Sell\n2. Tick Rule: If at mid, use price change\n   - Up-tick -> Buy\n   - Down-tick -> Sell\n   - Zero-tick -> Use previous classification\n\nAccuracy: ~85% on equity markets", "source": "core\\_experimental\\lob_features.py", "category": "microstructure"}
{"instruction": "What is the BookImbalance class and how do I use it?", "input": "", "output": "The BookImbalance class:\n\nMulti-Level Book Imbalance.\n\nSource: Multiple papers, HftBacktest\n\nMeasures:\n- Level 1 imbalance (BBO only)\n- Weighted imbalance (exponential decay)\n- Volume imbalance (total depth)\n\nFormula:\nI_n = sum(w_i * (bid_size_i - ask_size_i)) / sum(w_i * (bid_size_i + ask_size_i))\n\nFor Forex HFT:\n- Primary alpha signal\n- Short-term direction prediction\n- Market making skew", "source": "core\\_experimental\\lob_features.py", "category": "alpha"}
{"instruction": "What is the QueueImbalance class and how do I use it?", "input": "", "output": "The QueueImbalance class:\n\nQueue Position Imbalance.\n\nSource: HftBacktest, Cont (2014)\n\nTracks changes in queue positions to predict fills.\n\nFor Forex HFT:\n- Estimate fill probability\n- Detect order flow changes\n- Improve execution timing", "source": "core\\_experimental\\lob_features.py", "category": "execution"}
{"instruction": "What is the SpreadDecomposition class and how do I use it?", "input": "", "output": "The SpreadDecomposition class:\n\nSpread Decomposition Analysis.\n\nSource: Academic market microstructure literature\n\nComponents:\n1. Adverse Selection Cost (信息成本)\n2. Inventory Cost (库存成本)\n3. Order Processing Cost (处理成本)\n\nFor Forex HFT:\n- Estimate true trading cost\n- Identify informed flow\n- Optimize quote placement", "source": "core\\_experimental\\lob_features.py", "category": "microstructure"}
{"instruction": "What is the LOBSlope class and how do I use it?", "input": "", "output": "The LOBSlope class:\n\nOrder Book Slope Features.\n\nSource: Naik & Yadav, verified in Chinese research\n\nMeasures how quickly depth decays from BBO.\nSteep slope = thin book = high impact\nFlat slope = thick book = low impact\n\nFor Forex HFT:\n- Estimate price impact\n- Detect thin markets\n- Size order appropriately", "source": "core\\_experimental\\lob_features.py", "category": "execution"}
{"instruction": "What is the Resilience class and how do I use it?", "input": "", "output": "The Resilience class:\n\nOrder Book Resilience.\n\nSource: Large & Payne (2007), Chinese HFT research\n\nMeasures how quickly the book recovers after large trades.\nHigh resilience = healthy market\nLow resilience = fragile market\n\nFor Forex HFT:\n- Detect market stress\n- Avoid trading in fragile conditions\n- Time execution optimally", "source": "core\\_experimental\\lob_features.py", "category": "execution"}
{"instruction": "What is the PriceImpactCurve class and how do I use it?", "input": "", "output": "The PriceImpactCurve class:\n\nPrice Impact Curve Estimation.\n\nSource: Almgren-Chriss, Gatheral\n\nModels: I(q) = sigma * sign(q) * |q|^delta\n\nWhere:\n- sigma = volatility scaling\n- q = order size\n- delta = impact exponent (typically 0.5)\n\nFor Forex HFT:\n- Estimate execution cost\n- Optimal order slicing\n- VWAP/TWAP calibration", "source": "core\\_experimental\\lob_features.py", "category": "volatility"}
{"instruction": "What is the LOBFeatureEngine class and how do I use it?", "input": "", "output": "The LOBFeatureEngine class:\n\nUnified LOB Feature Engine.\n\nCombines all LOB-based features into single interface.", "source": "core\\_experimental\\lob_features.py", "category": "general"}
{"instruction": "Explain the Classify function", "input": "", "output": "Function: classify\n\nClassify single trade.\n\nArgs:\n    trade_price: Trade execution price\n    bid: Best bid at trade time\n    ask: Best ask at trade time\n    prev_trade_price: Previous trade price for tick rule\n\nReturns:\n    TradeDirection", "source": "core\\_experimental\\lob_features.py", "category": "execution"}
{"instruction": "What is the formula for Classify Series?", "input": "", "output": "Classify all trades in DataFrame.\n\nArgs:\n    df: DataFrame with 'price', 'bid', 'ask' columns\n\nReturns:\n    Series of trade directions (-1, 0, 1)", "source": "core\\_experimental\\lob_features.py", "category": "microstructure"}
{"instruction": "Explain the Classify Series function", "input": "", "output": "Function: classify_series\n\nClassify all trades in DataFrame.\n\nArgs:\n    df: DataFrame with 'price', 'bid', 'ask' columns\n\nReturns:\n    Series of trade directions (-1, 0, 1)", "source": "core\\_experimental\\lob_features.py", "category": "microstructure"}
{"instruction": "Explain the Calculate Level1 function", "input": "", "output": "Function: calculate_level1\n\nLevel 1 (BBO) imbalance.", "source": "core\\_experimental\\lob_features.py", "category": "general"}
{"instruction": "What is the formula for Calculate Weighted?", "input": "", "output": "Weighted multi-level imbalance.\n\nDeeper levels have exponentially decaying weight.", "source": "core\\_experimental\\lob_features.py", "category": "general"}
{"instruction": "Explain the Calculate Weighted function", "input": "", "output": "Function: calculate_weighted\n\nWeighted multi-level imbalance.\n\nDeeper levels have exponentially decaying weight.", "source": "core\\_experimental\\lob_features.py", "category": "general"}
{"instruction": "Explain the Calculate Volume Imbalance function", "input": "", "output": "Function: calculate_volume_imbalance\n\nTotal volume imbalance across all levels.", "source": "core\\_experimental\\lob_features.py", "category": "volatility"}
{"instruction": "Explain the Calculate Depth Ratio function", "input": "", "output": "Function: calculate_depth_ratio\n\nDepth ratio within price range.\n\nMeasures liquidity asymmetry.", "source": "core\\_experimental\\lob_features.py", "category": "general"}
{"instruction": "What is the formula for Calculate?", "input": "", "output": "Calculate queue imbalance from quote changes.\n\nReturns imbalance in [-1, 1] range.", "source": "core\\_experimental\\lob_features.py", "category": "general"}
{"instruction": "Explain the Calculate function", "input": "", "output": "Function: calculate\n\nCalculate queue imbalance from quote changes.\n\nReturns imbalance in [-1, 1] range.", "source": "core\\_experimental\\lob_features.py", "category": "general"}
{"instruction": "What is the formula for Calculate Realized Spread?", "input": "", "output": "Realized spread - actual profit to liquidity provider.\n\nRealized_Spread = 2 * direction * (trade_price - mid_future)", "source": "core\\_experimental\\lob_features.py", "category": "microstructure"}
{"instruction": "Explain the Calculate Realized Spread function", "input": "", "output": "Function: calculate_realized_spread\n\nRealized spread - actual profit to liquidity provider.\n\nRealized_Spread = 2 * direction * (trade_price - mid_future)", "source": "core\\_experimental\\lob_features.py", "category": "microstructure"}
{"instruction": "What is OFI in quantitative trading?", "input": "", "output": "OFI (Order Flow Imbalance).\n\nImplementation details:\nRealized spread - actual profit to liquidity provider.\n\nRealized_Spread = 2 * direction * (trade_price - mid_future)", "source": "core\\_experimental\\lob_features.py", "category": "microstructure"}
{"instruction": "What is the formula for Calculate Effective Spread?", "input": "", "output": "Effective spread - actual cost to liquidity taker.\n\nEffective_Spread = 2 * |trade_price - mid|", "source": "core\\_experimental\\lob_features.py", "category": "microstructure"}
{"instruction": "Explain the Calculate Effective Spread function", "input": "", "output": "Function: calculate_effective_spread\n\nEffective spread - actual cost to liquidity taker.\n\nEffective_Spread = 2 * |trade_price - mid|", "source": "core\\_experimental\\lob_features.py", "category": "microstructure"}
{"instruction": "What is the formula for Calculate Adverse Selection?", "input": "", "output": "Adverse selection component.\n\nAS = Effective_Spread - Realized_Spread", "source": "core\\_experimental\\lob_features.py", "category": "microstructure"}
{"instruction": "Explain the Calculate Adverse Selection function", "input": "", "output": "Function: calculate_adverse_selection\n\nAdverse selection component.\n\nAS = Effective_Spread - Realized_Spread", "source": "core\\_experimental\\lob_features.py", "category": "microstructure"}
{"instruction": "Explain the Decompose function", "input": "", "output": "Function: decompose\n\nFull spread decomposition.", "source": "core\\_experimental\\lob_features.py", "category": "microstructure"}
{"instruction": "What is the formula for Calculate Slope?", "input": "", "output": "Calculate slope using linear regression.\n\nSlope = d(cumulative_size) / d(price_distance)", "source": "core\\_experimental\\lob_features.py", "category": "general"}
{"instruction": "Explain the Calculate Slope function", "input": "", "output": "Function: calculate_slope\n\nCalculate slope using linear regression.\n\nSlope = d(cumulative_size) / d(price_distance)", "source": "core\\_experimental\\lob_features.py", "category": "general"}
{"instruction": "What is the formula for Calculate Bid Slope?", "input": "", "output": "Bid side slope (positive = thick book).", "source": "core\\_experimental\\lob_features.py", "category": "microstructure"}
{"instruction": "Explain the Calculate Bid Slope function", "input": "", "output": "Function: calculate_bid_slope\n\nBid side slope (positive = thick book).", "source": "core\\_experimental\\lob_features.py", "category": "microstructure"}
{"instruction": "What is the formula for Calculate Ask Slope?", "input": "", "output": "Ask side slope (positive = thick book).", "source": "core\\_experimental\\lob_features.py", "category": "microstructure"}
{"instruction": "Explain the Calculate Ask Slope function", "input": "", "output": "Function: calculate_ask_slope\n\nAsk side slope (positive = thick book).", "source": "core\\_experimental\\lob_features.py", "category": "microstructure"}
{"instruction": "What is the formula for Calculate Slope Imbalance?", "input": "", "output": "Slope imbalance.\n\nPositive = bid side thicker = buy pressure", "source": "core\\_experimental\\lob_features.py", "category": "microstructure"}
{"instruction": "Explain the Calculate Slope Imbalance function", "input": "", "output": "Function: calculate_slope_imbalance\n\nSlope imbalance.\n\nPositive = bid side thicker = buy pressure", "source": "core\\_experimental\\lob_features.py", "category": "microstructure"}
{"instruction": "What is the formula for Calculate?", "input": "", "output": "Calculate resilience metric.\n\nResilience = Speed of spread recovery after widening", "source": "core\\_experimental\\lob_features.py", "category": "microstructure"}
{"instruction": "Explain the Calculate function", "input": "", "output": "Function: calculate\n\nCalculate resilience metric.\n\nResilience = Speed of spread recovery after widening", "source": "core\\_experimental\\lob_features.py", "category": "microstructure"}
{"instruction": "Explain the Calibrate function", "input": "", "output": "Function: calibrate\n\nCalibrate impact model from historical data.\n\nReturns estimated sigma.", "source": "core\\_experimental\\lob_features.py", "category": "execution"}
{"instruction": "Explain the Estimate Impact function", "input": "", "output": "Function: estimate_impact\n\nEstimate price impact for given order size.\n\nArgs:\n    order_size: Order size (can be negative for sells)\n    volatility: Current volatility estimate\n\nReturns:\n    Expected price impact in price units", "source": "core\\_experimental\\lob_features.py", "category": "volatility"}
{"instruction": "Explain the Generate All Features function", "input": "", "output": "Function: generate_all_features\n\nGenerate all LOB features.\n\nArgs:\n    df: DataFrame with bid, ask, volume columns\n\nReturns:\n    DataFrame with LOB feature columns added", "source": "core\\_experimental\\lob_features.py", "category": "volatility"}
{"instruction": "Explain the Get Feature Names function", "input": "", "output": "Function: get_feature_names\n\nReturn list of feature names.", "source": "core\\_experimental\\lob_features.py", "category": "general"}
{"instruction": "Explain the Compute All Features function", "input": "", "output": "Function: compute_all_features\n\nCompute all LOB features.\nInterface compatible with HFT Feature Engine.", "source": "core\\_experimental\\lob_features.py", "category": "general"}
{"instruction": "Explain the purpose of Market Impact Models (Academic Microstructure)", "input": "", "output": "Market Impact Models (Academic Microstructure)\n===============================================\nImplementation of foundational market microstructure models.\n\nSources (Gold Standard Citations):\n\n1. Kyle (1985): \"Continuous Auctions and Insider Trading\"\n   Econometrica, Vol. 53, No. 6, pp. 1315-1335\n   - Lambda (price impact parameter)\n   - Informed vs uninformed trading\n\n2. Glosten & Milgrom (1985): \"Bid, Ask and Transaction Prices in a Specialist Market\n   with Heterogeneously Informed Traders\"\n   Journal of Financial Economics, Vol. 14, pp. 71-100\n   - Adverse selection component of spread\n   - Bayesian updating of beliefs\n\n3. Roll (1984): \"A Simple Implicit Measure of the Effective Bid-Ask Spread in an\n   Efficient Market\"\n   Journal of Finance, Vol. 39, No. 4, pp. 1127-1139\n   - Effective spread from autocorrelation\n\n4. Huang & Stoll (1997): \"The Components of the Bid-Ask Spread: A General Approach\"\n   Review of Financial Studies, Vol. 10, No. 4, pp. 995-1034\n   - Spread decomposition: adverse selection, inventory, order processing\n\n5. Hasbrouck (1991): \"Measuring the Information Content of Stock Trades\"\n   Journal of Finance, Vol. 46, No. 1, pp. 179-207\n   - Trade informativeness, permanent price impact", "source": "core\\_experimental\\market_impact_models.py", "category": "volatility"}
{"instruction": "What is the MarketImpactEstimate class and how do I use it?", "input": "", "output": "The MarketImpactEstimate class:\n\nContainer for market impact estimates.", "source": "core\\_experimental\\market_impact_models.py", "category": "execution"}
{"instruction": "What is the KyleModel class and how do I use it?", "input": "", "output": "The KyleModel class:\n\nKyle (1985) Model - Continuous Auctions and Insider Trading\n\nThe informed trader knows the true value V and trades optimally.\nMarket maker sets prices to break even given order flow.\n\nKey result:\n    P = lambda * (X + U)\n\nwhere:\n    P = price change\n    lambda = sigma_v / (2 * sigma_u) = price impact parameter\n    X = informed trader order\n    U = noise trader order (random)\n    sigma_v = std of fundamental value changes\n    sigma_u = std of noise trading\n\nReference:\n    Kyle, A. S. (1985). \"Continuous Auctions and Insider Trading\".\n    Econometrica, 53(6), 1315-1335.", "source": "core\\_experimental\\market_impact_models.py", "category": "execution"}
{"instruction": "What is the GlostenMilgromModel class and how do I use it?", "input": "", "output": "The GlostenMilgromModel class:\n\nGlosten-Milgrom (1985) Model - Adverse Selection\n\nMarket maker faces informed and uninformed traders.\nSpread compensates for adverse selection risk.\n\nKey results:\n    Ask = E[V | Buy order] > E[V]\n    Bid = E[V | Sell order] < E[V]\n    Spread = (Ask - Bid) = f(probability of informed trading)\n\nReference:\n    Glosten, L. R., & Milgrom, P. R. (1985). \"Bid, Ask and Transaction\n    Prices in a Specialist Market with Heterogeneously Informed Traders\".\n    Journal of Financial Economics, 14, 71-100.", "source": "core\\_experimental\\market_impact_models.py", "category": "risk"}
{"instruction": "What is the RollModel class and how do I use it?", "input": "", "output": "The RollModel class:\n\nRoll (1984) Model - Effective Spread Estimation\n\nEstimates effective spread from first-order autocorrelation of returns.\nWorks without observing quotes (only needs transaction prices).\n\nKey result:\n    Spread = 2 * sqrt(-Cov(ΔP_t, ΔP_{t-1}))\n\nReference:\n    Roll, R. (1984). \"A Simple Implicit Measure of the Effective Bid-Ask\n    Spread in an Efficient Market\". Journal of Finance, 39(4), 1127-1139.", "source": "core\\_experimental\\market_impact_models.py", "category": "microstructure"}
{"instruction": "What is the HuangStollModel class and how do I use it?", "input": "", "output": "The HuangStollModel class:\n\nHuang & Stoll (1997) Model - Spread Component Decomposition\n\nDecomposes bid-ask spread into three components:\n1. Adverse selection (information asymmetry)\n2. Inventory holding cost\n3. Order processing cost\n\nReference:\n    Huang, R. D., & Stoll, H. R. (1997). \"The Components of the Bid-Ask\n    Spread: A General Approach\". Review of Financial Studies, 10(4), 995-1034.", "source": "core\\_experimental\\market_impact_models.py", "category": "microstructure"}
{"instruction": "What is the HasbrouckModel class and how do I use it?", "input": "", "output": "The HasbrouckModel class:\n\nHasbrouck (1991) Model - Trade Informativeness\n\nMeasures information content of trades using VAR model.\nDecomposes price into permanent (information) and transitory (noise) components.\n\nReference:\n    Hasbrouck, J. (1991). \"Measuring the Information Content of Stock Trades\".\n    Journal of Finance, 46(1), 179-207.", "source": "core\\_experimental\\market_impact_models.py", "category": "risk"}
{"instruction": "What is the MarketImpactFeatures class and how do I use it?", "input": "", "output": "The MarketImpactFeatures class:\n\nGenerate market impact features for ML models.\n\nCombines all market impact models into feature set.", "source": "core\\_experimental\\market_impact_models.py", "category": "execution"}
{"instruction": "Explain the Create Kyle Model function", "input": "", "output": "Function: create_kyle_model\n\nFactory for Kyle model.", "source": "core\\_experimental\\market_impact_models.py", "category": "alpha"}
{"instruction": "Explain the Create Market Impact Features function", "input": "", "output": "Function: create_market_impact_features\n\nFactory for market impact features.", "source": "core\\_experimental\\market_impact_models.py", "category": "alpha"}
{"instruction": "What is the formula for Estimate Lambda?", "input": "", "output": "Estimate Kyle's lambda from price and volume data.\n\nLambda = Cov(ΔP, V) / Var(V)\n\nArgs:\n    prices: Price series\n    volumes: Volume series (signed: + for buy, - for sell)\n    window: Rolling window for estimation\n\nReturns:\n    Rolling lambda estimates", "source": "core\\_experimental\\market_impact_models.py", "category": "volatility"}
{"instruction": "Explain the Estimate Lambda function", "input": "", "output": "Function: estimate_lambda\n\nEstimate Kyle's lambda from price and volume data.\n\nLambda = Cov(ΔP, V) / Var(V)\n\nArgs:\n    prices: Price series\n    volumes: Volume series (signed: + for buy, - for sell)\n    window: Rolling window for estimation\n\nReturns:\n    Rolling lambda estimates", "source": "core\\_experimental\\market_impact_models.py", "category": "volatility"}
{"instruction": "What is the formula for Estimate From Trades?", "input": "", "output": "Estimate Kyle model parameters from trade data.\n\nUses regression: ΔP = lambda * sign * size + epsilon\n\nArgs:\n    trade_prices: Transaction prices\n    trade_signs: +1 for buyer-initiated, -1 for seller-initiated\n    trade_sizes: Trade sizes\n\nReturns:\n    MarketImpactEstimate with lambda and volatility parameters", "source": "core\\_experimental\\market_impact_models.py", "category": "volatility"}
{"instruction": "Explain the Estimate From Trades function", "input": "", "output": "Function: estimate_from_trades\n\nEstimate Kyle model parameters from trade data.\n\nUses regression: ΔP = lambda * sign * size + epsilon\n\nArgs:\n    trade_prices: Transaction prices\n    trade_signs: +1 for buyer-initiated, -1 for seller-initiated\n    trade_sizes: Trade sizes\n\nReturns:\n    MarketImpactEstimate with lambda and volatility parameters", "source": "core\\_experimental\\market_impact_models.py", "category": "volatility"}
{"instruction": "What is the formula for Expected Price Impact?", "input": "", "output": "Calculate expected price impact for given order size.\n\nΔP = lambda * order_size\n\nArgs:\n    order_size: Signed order size (+ for buy, - for sell)\n\nReturns:\n    Expected price change", "source": "core\\_experimental\\market_impact_models.py", "category": "execution"}
{"instruction": "Explain the Expected Price Impact function", "input": "", "output": "Function: expected_price_impact\n\nCalculate expected price impact for given order size.\n\nΔP = lambda * order_size\n\nArgs:\n    order_size: Signed order size (+ for buy, - for sell)\n\nReturns:\n    Expected price change", "source": "core\\_experimental\\market_impact_models.py", "category": "execution"}
{"instruction": "Explain the Optimal Trade Intensity function", "input": "", "output": "Function: optimal_trade_intensity\n\nCalculate optimal trading rate (from Kyle model).\n\nOptimal intensity minimizes total execution cost.\n\nArgs:\n    total_order: Total order to execute\n    time_horizon: Time available for execution\n\nReturns:\n    Optimal order size per period", "source": "core\\_experimental\\market_impact_models.py", "category": "execution"}
{"instruction": "What is the formula for Estimate Adverse Selection?", "input": "", "output": "Estimate adverse selection component of spread.\n\nUses Glosten-Harris (1988) decomposition:\nΔP = c * sign + z * sign * size + epsilon\n\nwhere c = adverse selection, z = inventory/order processing\n\nArgs:\n    trades: DataFrame with 'price', 'sign', 'size' columns\n    mid_prices: Mid-price series\n\nReturns:\n    Tuple of (adverse_selection, inventory_component)", "source": "core\\_experimental\\market_impact_models.py", "category": "microstructure"}
{"instruction": "Explain the Estimate Adverse Selection function", "input": "", "output": "Function: estimate_adverse_selection\n\nEstimate adverse selection component of spread.\n\nUses Glosten-Harris (1988) decomposition:\nΔP = c * sign + z * sign * size + epsilon\n\nwhere c = adverse selection, z = inventory/order processing\n\nArgs:\n    trades: DataFrame with 'price', 'sign', 'size' columns\n    mid_prices: Mid-price series\n\nReturns:\n    Tuple of (adverse_selection, inventory_component)", "source": "core\\_experimental\\market_impact_models.py", "category": "microstructure"}
{"instruction": "What is the formula for Probability Informed?", "input": "", "output": "Estimate probability of informed trading (mu).\n\nFrom Glosten-Milgrom model:\nSpread ≈ 2 * mu * delta_v\n\nwhere delta_v ≈ volatility / sqrt(trade_frequency)\n\nArgs:\n    spread: Bid-ask spread\n    volatility: Price volatility\n    trade_frequency: Number of trades per period\n\nReturns:\n    Estimated probability of informed trading", "source": "core\\_experimental\\market_impact_models.py", "category": "volatility"}
{"instruction": "Explain the Probability Informed function", "input": "", "output": "Function: probability_informed\n\nEstimate probability of informed trading (mu).\n\nFrom Glosten-Milgrom model:\nSpread ≈ 2 * mu * delta_v\n\nwhere delta_v ≈ volatility / sqrt(trade_frequency)\n\nArgs:\n    spread: Bid-ask spread\n    volatility: Price volatility\n    trade_frequency: Number of trades per period\n\nReturns:\n    Estimated probability of informed trading", "source": "core\\_experimental\\market_impact_models.py", "category": "volatility"}
{"instruction": "What is the formula for Estimate Spread?", "input": "", "output": "Estimate effective spread using Roll model.\n\nSpread = 2 * sqrt(-Cov(ΔP_t, ΔP_{t-1}))\n\nArgs:\n    prices: Transaction price series\n    window: Rolling window for estimation\n\nReturns:\n    Rolling spread estimates", "source": "core\\_experimental\\market_impact_models.py", "category": "microstructure"}
{"instruction": "Explain the Estimate Spread function", "input": "", "output": "Function: estimate_spread\n\nEstimate effective spread using Roll model.\n\nSpread = 2 * sqrt(-Cov(ΔP_t, ΔP_{t-1}))\n\nArgs:\n    prices: Transaction price series\n    window: Rolling window for estimation\n\nReturns:\n    Rolling spread estimates", "source": "core\\_experimental\\market_impact_models.py", "category": "microstructure"}
{"instruction": "What is the formula for Effective Spread Single?", "input": "", "output": "Single-period Roll spread estimate.\n\nArgs:\n    price_changes: Array of price changes\n\nReturns:\n    Effective spread estimate", "source": "core\\_experimental\\market_impact_models.py", "category": "microstructure"}
{"instruction": "Explain the Effective Spread Single function", "input": "", "output": "Function: effective_spread_single\n\nSingle-period Roll spread estimate.\n\nArgs:\n    price_changes: Array of price changes\n\nReturns:\n    Effective spread estimate", "source": "core\\_experimental\\market_impact_models.py", "category": "microstructure"}
{"instruction": "What is the formula for Decompose Spread?", "input": "", "output": "Decompose spread into components.\n\nModel:\nΔQ_t = S/2 * (Q_t - α*Q_{t-1}) + ε_t\n\nwhere:\n- S = total spread\n- α = probability of trade reversal\n- Adverse selection = S * (1 - α)\n- Inventory + Order processing = S * α\n\nArgs:\n    trades: DataFrame with 'price', 'time' columns\n    quotes: DataFrame with 'bid', 'ask', 'time' columns\n\nReturns:\n    Dict with spread components", "source": "core\\_experimental\\market_impact_models.py", "category": "microstructure"}
{"instruction": "Explain the Decompose Spread function", "input": "", "output": "Function: decompose_spread\n\nDecompose spread into components.\n\nModel:\nΔQ_t = S/2 * (Q_t - α*Q_{t-1}) + ε_t\n\nwhere:\n- S = total spread\n- α = probability of trade reversal\n- Adverse selection = S * (1 - α)\n- Inventory + Order processing = S * α\n\nArgs:\n    trades: DataFrame with 'price', 'time' columns\n    quotes: DataFrame with 'bid', 'ask', 'time' columns\n\nReturns:\n    Dict with spread components", "source": "core\\_experimental\\market_impact_models.py", "category": "microstructure"}
{"instruction": "What is the formula for Estimate Var?", "input": "", "output": "Estimate VAR model for returns and trade signs.\n\nr_t = Σ(a_j * r_{t-j}) + Σ(b_j * x_{t-j}) + ε_t\nx_t = Σ(c_j * r_{t-j}) + Σ(d_j * x_{t-j}) + η_t\n\nwhere x_t = trade sign (+1 buy, -1 sell)\n\nArgs:\n    returns: Return series\n    trade_signs: Trade sign series\n    lags: Number of VAR lags\n\nReturns:\n    Dict with VAR coefficients", "source": "core\\_experimental\\market_impact_models.py", "category": "risk"}
{"instruction": "Explain the Estimate Var function", "input": "", "output": "Function: estimate_var\n\nEstimate VAR model for returns and trade signs.\n\nr_t = Σ(a_j * r_{t-j}) + Σ(b_j * x_{t-j}) + ε_t\nx_t = Σ(c_j * r_{t-j}) + Σ(d_j * x_{t-j}) + η_t\n\nwhere x_t = trade sign (+1 buy, -1 sell)\n\nArgs:\n    returns: Return series\n    trade_signs: Trade sign series\n    lags: Number of VAR lags\n\nReturns:\n    Dict with VAR coefficients", "source": "core\\_experimental\\market_impact_models.py", "category": "risk"}
{"instruction": "What is the formula for Information Share?", "input": "", "output": "Calculate information share of trades.\n\nInformation share = variance of permanent component / total variance\n\nArgs:\n    returns: Return series\n    trade_signs: Trade sign series\n\nReturns:\n    Information share (0 to 1)", "source": "core\\_experimental\\market_impact_models.py", "category": "risk"}
{"instruction": "Explain the Information Share function", "input": "", "output": "Function: information_share\n\nCalculate information share of trades.\n\nInformation share = variance of permanent component / total variance\n\nArgs:\n    returns: Return series\n    trade_signs: Trade sign series\n\nReturns:\n    Information share (0 to 1)", "source": "core\\_experimental\\market_impact_models.py", "category": "risk"}
{"instruction": "What is the formula for Compute Features?", "input": "", "output": "Compute all market impact features.\n\nArgs:\n    prices: Transaction prices\n    volumes: Trade volumes\n    trade_signs: +1 for buy, -1 for sell\n    bid: Bid prices (optional)\n    ask: Ask prices (optional)\n    window: Rolling window\n\nReturns:\n    DataFrame with market impact features", "source": "core\\_experimental\\market_impact_models.py", "category": "volatility"}
{"instruction": "Explain the Compute Features function", "input": "", "output": "Function: compute_features\n\nCompute all market impact features.\n\nArgs:\n    prices: Transaction prices\n    volumes: Trade volumes\n    trade_signs: +1 for buy, -1 for sell\n    bid: Bid prices (optional)\n    ask: Ask prices (optional)\n    window: Rolling window\n\nReturns:\n    DataFrame with market impact features", "source": "core\\_experimental\\market_impact_models.py", "category": "volatility"}
{"instruction": "What is the source paper for Noise variance estimation?", "input": "", "output": "The source is: Aït-Sahalia et al.. ", "source": "core\\_experimental\\microstructure_vol.py", "category": "volatility"}
{"instruction": "Explain the purpose of Microstructure Volatility and Noise Filtering", "input": "", "output": "Microstructure Volatility and Noise Filtering\n==============================================\nImplements volatility estimation that accounts for market microstructure noise.\n\nKey methods:\n- Two Scales Realized Volatility (TSRV)\n- Bid-ask bounce filtering\n- Optimal sampling interval\n- Noise variance estimation\n\nSource: Aït-Sahalia et al. \"Ultra High Frequency Volatility Estimation\"", "source": "core\\_experimental\\microstructure_vol.py", "category": "volatility"}
{"instruction": "What is the MicrostructureVolatility class and how do I use it?", "input": "", "output": "The MicrostructureVolatility class:\n\nMicrostructure-Aware Volatility Estimator.\n\nStandard volatility measures are biased at high frequencies due to:\n- Bid-ask bounce\n- Price discreteness\n- Asynchronous quotes\n- Quote stuffing\n\nThis class implements noise-robust volatility estimation.\n\nUsage:\n    mv = MicrostructureVolatility()\n    true_vol = mv.tsrv(prices)\n    noise_var = mv.estimate_noise_variance(prices)\n    clean_prices = mv.filter_bidask_bounce(prices)", "source": "core\\_experimental\\microstructure_vol.py", "category": "volatility"}
{"instruction": "Show me a code example for MicrostructureVolatility", "input": "", "output": "mv = MicrostructureVolatility()\n    true_vol = mv.tsrv(prices)\n    noise_var = mv.estimate_noise_variance(prices)\n    clean_prices = mv.filter_bidask_bounce(prices)", "source": "core\\_experimental\\microstructure_vol.py", "category": "volatility"}
{"instruction": "What is the JumpRobustVolatility class and how do I use it?", "input": "", "output": "The JumpRobustVolatility class:\n\nJump-Robust Volatility Estimation.\n\nSeparates continuous and jump components.", "source": "core\\_experimental\\microstructure_vol.py", "category": "volatility"}
{"instruction": "Explain the Add Microstructure Features function", "input": "", "output": "Function: add_microstructure_features\n\nAdd microstructure volatility features to DataFrame.\n\nArgs:\n    df: DataFrame with price data\n    price_col: Name of price column\n\nReturns:\n    DataFrame with additional volatility features", "source": "core\\_experimental\\microstructure_vol.py", "category": "volatility"}
{"instruction": "What is the formula for Realized Variance?", "input": "", "output": "Standard Realized Variance (biased at high frequency).\n\nRV = Σ(r_i)^2\n\nArgs:\n    prices: Price series\n\nReturns:\n    Realized variance", "source": "core\\_experimental\\microstructure_vol.py", "category": "risk"}
{"instruction": "Explain the Realized Variance function", "input": "", "output": "Function: realized_variance\n\nStandard Realized Variance (biased at high frequency).\n\nRV = Σ(r_i)^2\n\nArgs:\n    prices: Price series\n\nReturns:\n    Realized variance", "source": "core\\_experimental\\microstructure_vol.py", "category": "risk"}
{"instruction": "Explain the Realized Volatility function", "input": "", "output": "Function: realized_volatility\n\nStandard Realized Volatility.\n\nArgs:\n    prices: Price series\n    annualize: If True, annualize (assumes daily data)\n\nReturns:\n    Realized volatility", "source": "core\\_experimental\\microstructure_vol.py", "category": "volatility"}
{"instruction": "What is the formula for Tsrv?", "input": "", "output": "Two Scales Realized Variance.\n\nUnbiased estimator that accounts for microstructure noise.\n\nTSRV = (1/K) Σ RV_k - (n_bar / n) * RV_all\n\nwhere:\n- RV_k is realized variance on subsampled grid k\n- n_bar is average sample size per grid\n- n is total observations\n\nArgs:\n    prices: Price series\n    K: Number of subsampling grids (default: optimal)\n\nReturns:\n    Noise-robust realized variance", "source": "core\\_experimental\\microstructure_vol.py", "category": "risk"}
{"instruction": "Explain the Tsrv function", "input": "", "output": "Function: tsrv\n\nTwo Scales Realized Variance.\n\nUnbiased estimator that accounts for microstructure noise.\n\nTSRV = (1/K) Σ RV_k - (n_bar / n) * RV_all\n\nwhere:\n- RV_k is realized variance on subsampled grid k\n- n_bar is average sample size per grid\n- n is total observations\n\nArgs:\n    prices: Price series\n    K: Number of subsampling grids (default: optimal)\n\nReturns:\n    Noise-robust realized variance", "source": "core\\_experimental\\microstructure_vol.py", "category": "risk"}
{"instruction": "What is the formula for Tsrv Volatility?", "input": "", "output": "Two Scales Realized Volatility.\n\nArgs:\n    prices: Price series\n    K: Subsampling grids\n    annualize: Annualize volatility\n\nReturns:\n    TSRV-based volatility", "source": "core\\_experimental\\microstructure_vol.py", "category": "volatility"}
{"instruction": "Explain the Tsrv Volatility function", "input": "", "output": "Function: tsrv_volatility\n\nTwo Scales Realized Volatility.\n\nArgs:\n    prices: Price series\n    K: Subsampling grids\n    annualize: Annualize volatility\n\nReturns:\n    TSRV-based volatility", "source": "core\\_experimental\\microstructure_vol.py", "category": "volatility"}
{"instruction": "What is the formula for Estimate Noise Variance?", "input": "", "output": "Estimate microstructure noise variance.\n\nUses first-order autocorrelation of returns.\n\nσ²_noise ≈ -Cov(r_t, r_{t-1})\n\nArgs:\n    prices: Price series\n\nReturns:\n    Estimated noise variance", "source": "core\\_experimental\\microstructure_vol.py", "category": "risk"}
{"instruction": "Explain the Estimate Noise Variance function", "input": "", "output": "Function: estimate_noise_variance\n\nEstimate microstructure noise variance.\n\nUses first-order autocorrelation of returns.\n\nσ²_noise ≈ -Cov(r_t, r_{t-1})\n\nArgs:\n    prices: Price series\n\nReturns:\n    Estimated noise variance", "source": "core\\_experimental\\microstructure_vol.py", "category": "risk"}
{"instruction": "What is the formula for Signal To Noise Ratio?", "input": "", "output": "Calculate signal-to-noise ratio.\n\nSNR = true_variance / noise_variance\n\nArgs:\n    prices: Price series\n\nReturns:\n    SNR (higher = less noisy)", "source": "core\\_experimental\\microstructure_vol.py", "category": "alpha"}
{"instruction": "Explain the Signal To Noise Ratio function", "input": "", "output": "Function: signal_to_noise_ratio\n\nCalculate signal-to-noise ratio.\n\nSNR = true_variance / noise_variance\n\nArgs:\n    prices: Price series\n\nReturns:\n    SNR (higher = less noisy)", "source": "core\\_experimental\\microstructure_vol.py", "category": "alpha"}
{"instruction": "What is the formula for Optimal Sampling Interval?", "input": "", "output": "Find optimal sampling interval to minimize MSE.\n\nTrades off:\n- More samples = more information\n- Fewer samples = less noise\n\nArgs:\n    prices: High-frequency price series\n    sampling_intervals: Intervals to test\n\nReturns:\n    Optimal sampling interval", "source": "core\\_experimental\\microstructure_vol.py", "category": "general"}
{"instruction": "Explain the Optimal Sampling Interval function", "input": "", "output": "Function: optimal_sampling_interval\n\nFind optimal sampling interval to minimize MSE.\n\nTrades off:\n- More samples = more information\n- Fewer samples = less noise\n\nArgs:\n    prices: High-frequency price series\n    sampling_intervals: Intervals to test\n\nReturns:\n    Optimal sampling interval", "source": "core\\_experimental\\microstructure_vol.py", "category": "general"}
{"instruction": "What is the formula for Filter Bidask Bounce?", "input": "", "output": "Filter bid-ask bounce from prices.\n\nArgs:\n    prices: Price series with bid-ask bounce\n    method: 'ma' (moving average) or 'kalman'\n\nReturns:\n    Filtered price series", "source": "core\\_experimental\\microstructure_vol.py", "category": "microstructure"}
{"instruction": "Explain the Filter Bidask Bounce function", "input": "", "output": "Function: filter_bidask_bounce\n\nFilter bid-ask bounce from prices.\n\nArgs:\n    prices: Price series with bid-ask bounce\n    method: 'ma' (moving average) or 'kalman'\n\nReturns:\n    Filtered price series", "source": "core\\_experimental\\microstructure_vol.py", "category": "microstructure"}
{"instruction": "What is Kalman Filter in quantitative trading?", "input": "", "output": "Kalman Filter (state estimation and signal filtering).\n\nImplementation details:\nFilter bid-ask bounce from prices.\n\nArgs:\n    prices: Price series with bid-ask bounce\n    method: 'ma' (moving average) or 'kalman'\n\nReturns:\n    Filtered price series", "source": "core\\_experimental\\microstructure_vol.py", "category": "microstructure"}
{"instruction": "Explain the Multi Scale Variance function", "input": "", "output": "Function: multi_scale_variance\n\nCalculate variance at multiple time scales.\n\nArgs:\n    prices: Price series\n    scales: Time scales (sampling intervals)\n\nReturns:\n    Dict with variance at each scale", "source": "core\\_experimental\\microstructure_vol.py", "category": "risk"}
{"instruction": "What is the formula for Volatility Signature?", "input": "", "output": "Generate volatility signature plot data.\n\nShows how volatility estimate varies with sampling frequency.\nFlat signature = unbiased estimator.\n\nArgs:\n    prices: Price series\n    max_scale: Maximum sampling interval\n\nReturns:\n    DataFrame with scale and volatility columns", "source": "core\\_experimental\\microstructure_vol.py", "category": "volatility"}
{"instruction": "Explain the Volatility Signature function", "input": "", "output": "Function: volatility_signature\n\nGenerate volatility signature plot data.\n\nShows how volatility estimate varies with sampling frequency.\nFlat signature = unbiased estimator.\n\nArgs:\n    prices: Price series\n    max_scale: Maximum sampling interval\n\nReturns:\n    DataFrame with scale and volatility columns", "source": "core\\_experimental\\microstructure_vol.py", "category": "volatility"}
{"instruction": "What is the formula for Bipower Variation?", "input": "", "output": "Bipower Variation - robust to jumps.\n\nBV = (π/2) Σ |r_i| |r_{i-1}|\n\nArgs:\n    prices: Price series\n\nReturns:\n    Bipower variation", "source": "core\\_experimental\\microstructure_vol.py", "category": "risk"}
{"instruction": "Explain the Bipower Variation function", "input": "", "output": "Function: bipower_variation\n\nBipower Variation - robust to jumps.\n\nBV = (π/2) Σ |r_i| |r_{i-1}|\n\nArgs:\n    prices: Price series\n\nReturns:\n    Bipower variation", "source": "core\\_experimental\\microstructure_vol.py", "category": "risk"}
{"instruction": "Explain the Detect Jumps function", "input": "", "output": "Function: detect_jumps\n\nDetect jumps in price series.\n\nArgs:\n    prices: Price series\n\nReturns:\n    Boolean array indicating jumps", "source": "core\\_experimental\\microstructure_vol.py", "category": "general"}
{"instruction": "Explain the Remove Jumps function", "input": "", "output": "Function: remove_jumps\n\nRemove jumps from price series.\n\nArgs:\n    prices: Price series with jumps\n\nReturns:\n    Price series with jumps removed", "source": "core\\_experimental\\microstructure_vol.py", "category": "general"}
{"instruction": "Explain the Continuous Variation function", "input": "", "output": "Function: continuous_variation\n\nEstimate continuous variation (excluding jumps).\n\nArgs:\n    prices: Price series\n\nReturns:\n    Continuous variation", "source": "core\\_experimental\\microstructure_vol.py", "category": "risk"}
{"instruction": "What is the formula for Jump Variation?", "input": "", "output": "Estimate jump variation.\n\nArgs:\n    prices: Price series\n\nReturns:\n    Jump variation (RV - continuous variation)", "source": "core\\_experimental\\microstructure_vol.py", "category": "risk"}
{"instruction": "Explain the Jump Variation function", "input": "", "output": "Function: jump_variation\n\nEstimate jump variation.\n\nArgs:\n    prices: Price series\n\nReturns:\n    Jump variation (RV - continuous variation)", "source": "core\\_experimental\\microstructure_vol.py", "category": "risk"}
{"instruction": "Explain the purpose of Core ML Integration - Production Ready", "input": "", "output": "Core ML Integration - Production Ready\nIntegrates Time-Series-Library (47 models), Qlib, FinRL, Chinese Quant", "source": "core\\_experimental\\ml_integration.py", "category": "rl"}
{"instruction": "What is the MLPredictor class and how do I use it?", "input": "", "output": "The MLPredictor class:\n\nBase class for ML predictions", "source": "core\\_experimental\\ml_integration.py", "category": "general"}
{"instruction": "What is the TimeSeriesPredictor class and how do I use it?", "input": "", "output": "The TimeSeriesPredictor class:\n\nTime-Series-Library integration (47 models)", "source": "core\\_experimental\\ml_integration.py", "category": "general"}
{"instruction": "What is the QlibPredictor class and how do I use it?", "input": "", "output": "The QlibPredictor class:\n\nMicrosoft Qlib integration", "source": "core\\_experimental\\ml_integration.py", "category": "general"}
{"instruction": "What is the FinRLPredictor class and how do I use it?", "input": "", "output": "The FinRLPredictor class:\n\nFinRL Deep Reinforcement Learning integration", "source": "core\\_experimental\\ml_integration.py", "category": "rl"}
{"instruction": "What is the ChineseQuantPredictor class and how do I use it?", "input": "", "output": "The ChineseQuantPredictor class:\n\nChinese Quant frameworks (QUANTAXIS, vnpy)", "source": "core\\_experimental\\ml_integration.py", "category": "general"}
{"instruction": "What is the MLEnsemble class and how do I use it?", "input": "", "output": "The MLEnsemble class:\n\nEnsemble multiple ML models for robust predictions\nCombines: Time-Series-Library + Qlib + FinRL + Chinese Quant", "source": "core\\_experimental\\ml_integration.py", "category": "rl"}
{"instruction": "Explain the Test Ml Integration function", "input": "", "output": "Function: test_ml_integration\n\nTest ML integration", "source": "core\\_experimental\\ml_integration.py", "category": "general"}
{"instruction": "Explain the Load Model function", "input": "", "output": "Function: load_model\n\nLoad trained model from disk", "source": "core\\_experimental\\ml_integration.py", "category": "general"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nGenerate predictions", "source": "core\\_experimental\\ml_integration.py", "category": "general"}
{"instruction": "What is the formula for Load Model?", "input": "", "output": "Load Time-Series-Library model", "source": "core\\_experimental\\ml_integration.py", "category": "general"}
{"instruction": "Explain the Load Model function", "input": "", "output": "Function: load_model\n\nLoad Time-Series-Library model", "source": "core\\_experimental\\ml_integration.py", "category": "general"}
{"instruction": "What is the formula for Predict?", "input": "", "output": "Generate price predictions using Time-Series-Library\n\nReturns: Array of predictions (1=buy, -1=sell, 0=hold)", "source": "core\\_experimental\\ml_integration.py", "category": "general"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nGenerate price predictions using Time-Series-Library\n\nReturns: Array of predictions (1=buy, -1=sell, 0=hold)", "source": "core\\_experimental\\ml_integration.py", "category": "general"}
{"instruction": "Explain the Load Model function", "input": "", "output": "Function: load_model\n\nLoad Qlib workflow", "source": "core\\_experimental\\ml_integration.py", "category": "general"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nGenerate predictions using Qlib", "source": "core\\_experimental\\ml_integration.py", "category": "general"}
{"instruction": "Explain the Load Model function", "input": "", "output": "Function: load_model\n\nLoad FinRL trained agent", "source": "core\\_experimental\\ml_integration.py", "category": "rl"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nGenerate actions using FinRL DRL agent", "source": "core\\_experimental\\ml_integration.py", "category": "rl"}
{"instruction": "Explain the Load Model function", "input": "", "output": "Function: load_model\n\nLoad Chinese quant framework", "source": "core\\_experimental\\ml_integration.py", "category": "general"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nGenerate predictions using Chinese quant framework", "source": "core\\_experimental\\ml_integration.py", "category": "general"}
{"instruction": "What is the formula for Predict?", "input": "", "output": "Generate ensemble predictions\n\nReturns:\n    signals: Array of trading signals (1=buy, -1=sell, 0=hold)\n    confidence: Array of confidence scores (0-1)", "source": "core\\_experimental\\ml_integration.py", "category": "alpha"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nGenerate ensemble predictions\n\nReturns:\n    signals: Array of trading signals (1=buy, -1=sell, 0=hold)\n    confidence: Array of confidence scores (0-1)", "source": "core\\_experimental\\ml_integration.py", "category": "alpha"}
{"instruction": "Explain the Update Weights function", "input": "", "output": "Function: update_weights\n\nUpdate model weights based on recent performance\n\nArgs:\n    performance: Dict of {model_name: sharpe_ratio or win_rate}", "source": "core\\_experimental\\ml_integration.py", "category": "risk"}
{"instruction": "What is Sharpe Ratio in quantitative trading?", "input": "", "output": "Sharpe Ratio (risk-adjusted return measure).\n\nImplementation details:\nUpdate model weights based on recent performance\n\nArgs:\n    performance: Dict of {model_name: sharpe_ratio or win_rate}", "source": "core\\_experimental\\ml_integration.py", "category": "risk"}
{"instruction": "Explain the purpose of NautilusTrader Execution Engine Wrapper", "input": "", "output": "NautilusTrader Execution Engine Wrapper\n========================================\nHigh-frequency execution with sub-microsecond latency.\n\nRepository: github.com/nautechsystems/nautilus_trader (17.2k stars)\n\nFeatures:\n- Rust core + Cython (1000x faster than pure Python)\n- Event-driven architecture\n- Multi-venue support (IB, FX)\n- Advanced order types (IOC, FOK, conditional)\n- 5M+ rows/second throughput", "source": "core\\_experimental\\nautilus_executor.py", "category": "execution"}
{"instruction": "What is the Order class and how do I use it?", "input": "", "output": "The Order class:\n\nOrder representation.", "source": "core\\_experimental\\nautilus_executor.py", "category": "general"}
{"instruction": "What is the Position class and how do I use it?", "input": "", "output": "The Position class:\n\nPosition representation.", "source": "core\\_experimental\\nautilus_executor.py", "category": "general"}
{"instruction": "What is the Fill class and how do I use it?", "input": "", "output": "The Fill class:\n\nFill/execution representation.", "source": "core\\_experimental\\nautilus_executor.py", "category": "execution"}
{"instruction": "What is the NautilusExecutor class and how do I use it?", "input": "", "output": "The NautilusExecutor class:\n\nHigh-performance execution engine inspired by NautilusTrader.\n\nFor actual NautilusTrader, install and use directly:\n    pip install nautilus_trader\n\nThis wrapper provides:\n- Compatible interface for strategy development\n- Simulation mode for backtesting\n- IB Gateway integration via ib_insync", "source": "core\\_experimental\\nautilus_executor.py", "category": "execution"}
{"instruction": "What is the StrategyBase class and how do I use it?", "input": "", "output": "The StrategyBase class:\n\nBase class for trading strategies.\n\nInherit from this to create strategies compatible with NautilusExecutor.", "source": "core\\_experimental\\nautilus_executor.py", "category": "general"}
{"instruction": "What is the MovingAverageCrossover class and how do I use it?", "input": "", "output": "The MovingAverageCrossover class:\n\nSimple MA crossover strategy.", "source": "core\\_experimental\\nautilus_executor.py", "category": "general"}
{"instruction": "Explain the Submit Order function", "input": "", "output": "Function: submit_order\n\nSubmit order for execution.\n\nReturns order ID.", "source": "core\\_experimental\\nautilus_executor.py", "category": "execution"}
{"instruction": "Explain the Market Order function", "input": "", "output": "Function: market_order\n\nSubmit market order.", "source": "core\\_experimental\\nautilus_executor.py", "category": "general"}
{"instruction": "Explain the Limit Order function", "input": "", "output": "Function: limit_order\n\nSubmit limit order.", "source": "core\\_experimental\\nautilus_executor.py", "category": "general"}
{"instruction": "Explain the Stop Order function", "input": "", "output": "Function: stop_order\n\nSubmit stop order.", "source": "core\\_experimental\\nautilus_executor.py", "category": "general"}
{"instruction": "What is the formula for Bracket Order?", "input": "", "output": "Submit bracket order (entry + TP + SL).\n\nReturns dict with order IDs for each leg.", "source": "core\\_experimental\\nautilus_executor.py", "category": "general"}
{"instruction": "Explain the Bracket Order function", "input": "", "output": "Function: bracket_order\n\nSubmit bracket order (entry + TP + SL).\n\nReturns dict with order IDs for each leg.", "source": "core\\_experimental\\nautilus_executor.py", "category": "general"}
{"instruction": "Explain the Cancel Order function", "input": "", "output": "Function: cancel_order\n\nCancel order.", "source": "core\\_experimental\\nautilus_executor.py", "category": "general"}
{"instruction": "Explain the Get Position function", "input": "", "output": "Function: get_position\n\nGet current position for symbol.", "source": "core\\_experimental\\nautilus_executor.py", "category": "general"}
{"instruction": "Explain the Get All Positions function", "input": "", "output": "Function: get_all_positions\n\nGet all positions.", "source": "core\\_experimental\\nautilus_executor.py", "category": "general"}
{"instruction": "Explain the Get Order function", "input": "", "output": "Function: get_order\n\nGet order by ID.", "source": "core\\_experimental\\nautilus_executor.py", "category": "general"}
{"instruction": "Explain the Get Open Orders function", "input": "", "output": "Function: get_open_orders\n\nGet all open orders.", "source": "core\\_experimental\\nautilus_executor.py", "category": "general"}
{"instruction": "Explain the Update Market Data function", "input": "", "output": "Function: update_market_data\n\nUpdate market data and check pending orders.\n\nCall this with each tick for realistic simulation.", "source": "core\\_experimental\\nautilus_executor.py", "category": "microstructure"}
{"instruction": "Explain the Get Statistics function", "input": "", "output": "Function: get_statistics\n\nGet execution statistics.", "source": "core\\_experimental\\nautilus_executor.py", "category": "execution"}
{"instruction": "Explain the Close All Positions function", "input": "", "output": "Function: close_all_positions\n\nClose all open positions.", "source": "core\\_experimental\\nautilus_executor.py", "category": "general"}
{"instruction": "Explain the On Tick function", "input": "", "output": "Function: on_tick\n\nCalled on each tick. Override in subclass.", "source": "core\\_experimental\\nautilus_executor.py", "category": "microstructure"}
{"instruction": "Explain the On Bar function", "input": "", "output": "Function: on_bar\n\nCalled on each bar close. Override in subclass.", "source": "core\\_experimental\\nautilus_executor.py", "category": "general"}
{"instruction": "Explain the On Fill function", "input": "", "output": "Function: on_fill\n\nCalled when order is filled. Override in subclass.", "source": "core\\_experimental\\nautilus_executor.py", "category": "general"}
{"instruction": "Explain the On Order Update function", "input": "", "output": "Function: on_order_update\n\nCalled when order status changes. Override in subclass.", "source": "core\\_experimental\\nautilus_executor.py", "category": "general"}
{"instruction": "What is the source paper for this technique?", "input": "", "output": "The source is: Optuna (13k+ stars) - https://github.com/optuna/optuna. ", "source": "core\\_experimental\\optuna_tuning.py", "category": "alpha"}
{"instruction": "Explain the purpose of Optuna Hyperparameter Optimization for HFT Models", "input": "", "output": "Optuna Hyperparameter Optimization for HFT Models\n==================================================\nSource: Optuna (13k+ stars) - https://github.com/optuna/optuna\n\nTree-Parzen Estimator (TPE) for efficient hyperparameter search.\nFinds good parameters in 50-100 trials vs 1000s for grid search.\n\nUse cases:\n1. XGBoost/LightGBM/CatBoost hyperparameters\n2. Signal weight optimization\n3. Risk parameter tuning (Kelly fraction, stop loss)\n4. Feature selection", "source": "core\\_experimental\\optuna_tuning.py", "category": "alpha"}
{"instruction": "What is the OptimizationResult class and how do I use it?", "input": "", "output": "The OptimizationResult class:\n\nOptimization result.", "source": "core\\_experimental\\optuna_tuning.py", "category": "general"}
{"instruction": "What is the XGBoostOptimizer class and how do I use it?", "input": "", "output": "The XGBoostOptimizer class:\n\nOptimize XGBoost hyperparameters using Optuna.", "source": "core\\_experimental\\optuna_tuning.py", "category": "general"}
{"instruction": "What is the LightGBMOptimizer class and how do I use it?", "input": "", "output": "The LightGBMOptimizer class:\n\nOptimize LightGBM hyperparameters.", "source": "core\\_experimental\\optuna_tuning.py", "category": "general"}
{"instruction": "What is the SignalWeightOptimizer class and how do I use it?", "input": "", "output": "The SignalWeightOptimizer class:\n\nOptimize signal weights in ensemble.\n\nFinds optimal combination of:\n- Alpha101 weight\n- Alpha191 weight\n- Renaissance weight\n- Technical weight\n- Order flow weight", "source": "core\\_experimental\\optuna_tuning.py", "category": "alpha"}
{"instruction": "What is the RiskParameterOptimizer class and how do I use it?", "input": "", "output": "The RiskParameterOptimizer class:\n\nOptimize risk parameters using historical performance.\n\nParameters to optimize:\n- Kelly fraction (0.1 to 0.5)\n- Stop loss (in ATR multiples)\n- Take profit (in ATR multiples)\n- Max position size", "source": "core\\_experimental\\optuna_tuning.py", "category": "risk"}
{"instruction": "Explain the Save Optimization Results function", "input": "", "output": "Function: save_optimization_results\n\nSave optimization results to JSON.", "source": "core\\_experimental\\optuna_tuning.py", "category": "general"}
{"instruction": "Explain the Load Optimization Results function", "input": "", "output": "Function: load_optimization_results\n\nLoad optimization results from JSON.", "source": "core\\_experimental\\optuna_tuning.py", "category": "general"}
{"instruction": "Explain the Optimize function", "input": "", "output": "Function: optimize\n\nOptimize XGBoost hyperparameters.\n\nArgs:\n    X_train, y_train: Training data\n    X_val, y_val: Validation data\n    objective: XGBoost objective\n    metric: Optimization metric\n\nReturns:\n    OptimizationResult with best parameters", "source": "core\\_experimental\\optuna_tuning.py", "category": "general"}
{"instruction": "Explain the Optimize function", "input": "", "output": "Function: optimize\n\nOptimize LightGBM hyperparameters.", "source": "core\\_experimental\\optuna_tuning.py", "category": "general"}
{"instruction": "What is the formula for Optimize?", "input": "", "output": "Optimize signal weights to maximize Sharpe ratio.\n\nArgs:\n    signals: Dict of signal name -> signal array\n    returns: Forward returns to predict\n\nReturns:\n    OptimizationResult with optimal weights", "source": "core\\_experimental\\optuna_tuning.py", "category": "alpha"}
{"instruction": "Explain the Optimize function", "input": "", "output": "Function: optimize\n\nOptimize signal weights to maximize Sharpe ratio.\n\nArgs:\n    signals: Dict of signal name -> signal array\n    returns: Forward returns to predict\n\nReturns:\n    OptimizationResult with optimal weights", "source": "core\\_experimental\\optuna_tuning.py", "category": "alpha"}
{"instruction": "What is Sharpe Ratio in quantitative trading?", "input": "", "output": "Sharpe Ratio (risk-adjusted return measure).\n\nImplementation details:\nOptimize signal weights to maximize Sharpe ratio.\n\nArgs:\n    signals: Dict of signal name -> signal array\n    returns: Forward returns to predict\n\nReturns:\n    OptimizationResult with optimal weights", "source": "core\\_experimental\\optuna_tuning.py", "category": "alpha"}
{"instruction": "What is the formula for Optimize?", "input": "", "output": "Optimize risk parameters.\n\nArgs:\n    signals: Trading signals (-1, 0, 1)\n    returns: Realized returns\n    volatility: Volatility estimates (for position sizing)\n\nReturns:\n    OptimizationResult with optimal risk parameters", "source": "core\\_experimental\\optuna_tuning.py", "category": "alpha"}
{"instruction": "Explain the Optimize function", "input": "", "output": "Function: optimize\n\nOptimize risk parameters.\n\nArgs:\n    signals: Trading signals (-1, 0, 1)\n    returns: Realized returns\n    volatility: Volatility estimates (for position sizing)\n\nReturns:\n    OptimizationResult with optimal risk parameters", "source": "core\\_experimental\\optuna_tuning.py", "category": "alpha"}
{"instruction": "What is the source paper for this technique?", "input": "", "output": "The source is: https://arxiv.org/html/2505.22678v1. ", "source": "core\\_experimental\\order_flow_features.py", "category": "alpha"}
{"instruction": "Explain the purpose of Order Flow Features for HFT", "input": "", "output": "Order Flow Features for HFT\n============================\nImplements advanced order flow analysis signals.\n\nFeatures:\n- Order Flow Imbalance (OFI)\n- Order Execution Imbalance (OEI)\n- Depth Ratio signals\n- Hawkes Process intensity\n- Trade direction inference\n\nBased on: Chinese A-Share research, Gatheral & Oomen (2010)\nSource: https://arxiv.org/html/2505.22678v1", "source": "core\\_experimental\\order_flow_features.py", "category": "alpha"}
{"instruction": "What is the OrderFlowState class and how do I use it?", "input": "", "output": "The OrderFlowState class:\n\nCurrent order flow state.", "source": "core\\_experimental\\order_flow_features.py", "category": "regime"}
{"instruction": "What is the OrderFlowFeatures class and how do I use it?", "input": "", "output": "The OrderFlowFeatures class:\n\nAdvanced Order Flow Feature Generator.\n\nGenerates signals from:\n- Order book updates (L2/L3)\n- Trade flow\n- Quote changes\n\nUsage:\n    ofi = OrderFlowFeatures()\n    ofi.update_book(bid, ask, bid_size, ask_size)\n    ofi.update_trade(price, size, side)\n    signals = ofi.get_signals()", "source": "core\\_experimental\\order_flow_features.py", "category": "alpha"}
{"instruction": "Show me a code example for OrderFlowFeatures", "input": "", "output": "ofi = OrderFlowFeatures()\n    ofi.update_book(bid, ask, bid_size, ask_size)\n    ofi.update_trade(price, size, side)\n    signals = ofi.get_signals()", "source": "core\\_experimental\\order_flow_features.py", "category": "alpha"}
{"instruction": "What is the TradeDirectionInference class and how do I use it?", "input": "", "output": "The TradeDirectionInference class:\n\nTrade Direction Inference using Lee-Ready and variants.\n\nInfers trade direction when side is not provided.", "source": "core\\_experimental\\order_flow_features.py", "category": "risk"}
{"instruction": "Explain the Update Book function", "input": "", "output": "Function: update_book\n\nUpdate with new book state.\n\nArgs:\n    bid: Best bid price\n    ask: Best ask price\n    bid_size: Quantity at best bid\n    ask_size: Quantity at best ask\n    timestamp: Update timestamp", "source": "core\\_experimental\\order_flow_features.py", "category": "microstructure"}
{"instruction": "Explain the Update Trade function", "input": "", "output": "Function: update_trade\n\nUpdate with new trade.\n\nArgs:\n    price: Trade price\n    size: Trade size\n    side: 'buy' or 'sell' (aggressor side)\n    timestamp: Trade timestamp", "source": "core\\_experimental\\order_flow_features.py", "category": "general"}
{"instruction": "What is the formula for Get Ofi?", "input": "", "output": "Calculate Order Flow Imbalance.\n\nOFI = Σ(bid_size_change - ask_size_change) weighted by price changes\n\nReturns:\n    OFI value (positive = buying pressure)", "source": "core\\_experimental\\order_flow_features.py", "category": "microstructure"}
{"instruction": "Explain the Get Ofi function", "input": "", "output": "Function: get_ofi\n\nCalculate Order Flow Imbalance.\n\nOFI = Σ(bid_size_change - ask_size_change) weighted by price changes\n\nReturns:\n    OFI value (positive = buying pressure)", "source": "core\\_experimental\\order_flow_features.py", "category": "microstructure"}
{"instruction": "What is OFI in quantitative trading?", "input": "", "output": "OFI (Order Flow Imbalance).\n\nImplementation details:\nCalculate Order Flow Imbalance.\n\nOFI = Σ(bid_size_change - ask_size_change) weighted by price changes\n\nReturns:\n    OFI value (positive = buying pressure)", "source": "core\\_experimental\\order_flow_features.py", "category": "microstructure"}
{"instruction": "What is the formula for Get Oei?", "input": "", "output": "Calculate Order Execution Imbalance.\n\nOEI measures efficiency of bid/ask execution.\n\nReturns:\n    OEI value (positive = more efficient buying)", "source": "core\\_experimental\\order_flow_features.py", "category": "execution"}
{"instruction": "Explain the Get Oei function", "input": "", "output": "Function: get_oei\n\nCalculate Order Execution Imbalance.\n\nOEI measures efficiency of bid/ask execution.\n\nReturns:\n    OEI value (positive = more efficient buying)", "source": "core\\_experimental\\order_flow_features.py", "category": "execution"}
{"instruction": "What is the formula for Get Depth Ratio?", "input": "", "output": "Calculate depth ratio.\n\nReturns:\n    bid_depth / ask_depth (>1 = more buy interest)", "source": "core\\_experimental\\order_flow_features.py", "category": "microstructure"}
{"instruction": "Explain the Get Depth Ratio function", "input": "", "output": "Function: get_depth_ratio\n\nCalculate depth ratio.\n\nReturns:\n    bid_depth / ask_depth (>1 = more buy interest)", "source": "core\\_experimental\\order_flow_features.py", "category": "microstructure"}
{"instruction": "What is the formula for Get Trade Imbalance?", "input": "", "output": "Calculate trade imbalance.\n\nReturns:\n    (buy_trades - sell_trades) / total_trades", "source": "core\\_experimental\\order_flow_features.py", "category": "general"}
{"instruction": "Explain the Get Trade Imbalance function", "input": "", "output": "Function: get_trade_imbalance\n\nCalculate trade imbalance.\n\nReturns:\n    (buy_trades - sell_trades) / total_trades", "source": "core\\_experimental\\order_flow_features.py", "category": "general"}
{"instruction": "What is the formula for Get Vpin?", "input": "", "output": "Calculate Volume-Synchronized Probability of Informed Trading.\n\nVPIN = Σ|buy_vol - sell_vol| / Σ(buy_vol + sell_vol)\n\nHigher = more informed trading (toxic flow)", "source": "core\\_experimental\\order_flow_features.py", "category": "volatility"}
{"instruction": "Explain the Get Vpin function", "input": "", "output": "Function: get_vpin\n\nCalculate Volume-Synchronized Probability of Informed Trading.\n\nVPIN = Σ|buy_vol - sell_vol| / Σ(buy_vol + sell_vol)\n\nHigher = more informed trading (toxic flow)", "source": "core\\_experimental\\order_flow_features.py", "category": "volatility"}
{"instruction": "What is VPIN in quantitative trading?", "input": "", "output": "VPIN (Volume-Synchronized Probability of Informed Trading).\n\nImplementation details:\nCalculate Volume-Synchronized Probability of Informed Trading.\n\nVPIN = Σ|buy_vol - sell_vol| / Σ(buy_vol + sell_vol)\n\nHigher = more informed trading (toxic flow)", "source": "core\\_experimental\\order_flow_features.py", "category": "volatility"}
{"instruction": "What is the formula for Get Hawkes Intensity?", "input": "", "output": "Get current Hawkes process intensity.\n\nHigher = more self-exciting (momentum)", "source": "core\\_experimental\\order_flow_features.py", "category": "general"}
{"instruction": "Explain the Get Hawkes Intensity function", "input": "", "output": "Function: get_hawkes_intensity\n\nGet current Hawkes process intensity.\n\nHigher = more self-exciting (momentum)", "source": "core\\_experimental\\order_flow_features.py", "category": "general"}
{"instruction": "What is the formula for Get Spread Percentile?", "input": "", "output": "Calculate current spread percentile vs history.\n\nReturns:\n    Percentile (0-100)", "source": "core\\_experimental\\order_flow_features.py", "category": "microstructure"}
{"instruction": "Explain the Get Spread Percentile function", "input": "", "output": "Function: get_spread_percentile\n\nCalculate current spread percentile vs history.\n\nReturns:\n    Percentile (0-100)", "source": "core\\_experimental\\order_flow_features.py", "category": "microstructure"}
{"instruction": "Explain the Get Microprice Momentum function", "input": "", "output": "Function: get_microprice_momentum\n\nCalculate microprice momentum in basis points.", "source": "core\\_experimental\\order_flow_features.py", "category": "general"}
{"instruction": "Explain the Get Signals function", "input": "", "output": "Function: get_signals\n\nGet all order flow signals.\n\nReturns:\n    Dict with signal names and values", "source": "core\\_experimental\\order_flow_features.py", "category": "alpha"}
{"instruction": "Explain the Get State function", "input": "", "output": "Function: get_state\n\nGet current order flow state.", "source": "core\\_experimental\\order_flow_features.py", "category": "regime"}
{"instruction": "What is the formula for Generate Features?", "input": "", "output": "Generate order flow features from tick DataFrame.\n\nExpects columns:\n- timestamp\n- bid, ask\n- bid_size, ask_size (optional)\n- last_price, last_size (for trades)\n- side (for trades, 'buy' or 'sell')\n\nReturns:\n    DataFrame with additional OFI/OEI columns", "source": "core\\_experimental\\order_flow_features.py", "category": "microstructure"}
{"instruction": "Explain the Generate Features function", "input": "", "output": "Function: generate_features\n\nGenerate order flow features from tick DataFrame.\n\nExpects columns:\n- timestamp\n- bid, ask\n- bid_size, ask_size (optional)\n- last_price, last_size (for trades)\n- side (for trades, 'buy' or 'sell')\n\nReturns:\n    DataFrame with additional OFI/OEI columns", "source": "core\\_experimental\\order_flow_features.py", "category": "microstructure"}
{"instruction": "What is OFI in quantitative trading?", "input": "", "output": "OFI (Order Flow Imbalance).\n\nImplementation details:\nGenerate order flow features from tick DataFrame.\n\nExpects columns:\n- timestamp\n- bid, ask\n- bid_size, ask_size (optional)\n- last_price, last_size (for trades)\n- side (for trades, 'buy' or 'sell')\n\nReturns:\n    DataFrame with additional OFI/OEI columns", "source": "core\\_experimental\\order_flow_features.py", "category": "microstructure"}
{"instruction": "Explain the Infer Direction function", "input": "", "output": "Function: infer_direction\n\nInfer trade direction.\n\nArgs:\n    price: Trade price\n    bid: Best bid\n    ask: Best ask\n    prev_price: Previous trade price (for tick rule)\n\nReturns:\n    'buy' or 'sell'", "source": "core\\_experimental\\order_flow_features.py", "category": "microstructure"}
{"instruction": "What is the source paper for this technique?", "input": "", "output": "The source is: Verified via CSDN Chinese quant (九坤投资 style). ", "source": "core\\_experimental\\ou_spread_trading.py", "category": "volatility"}
{"instruction": "Explain the purpose of Ornstein-Uhlenbeck Process for Pairs/Spread Trading", "input": "", "output": "Ornstein-Uhlenbeck Process for Pairs/Spread Trading\n====================================================\nSource: Verified via CSDN Chinese quant (九坤投资 style)\n\nThe OU process models mean-reverting spreads:\n    dS_t = θ(μ - S_t)dt + σdW_t\n\nWhere:\n    S_t = Spread at time t\n    θ (theta) = Mean reversion speed (kappa)\n    μ (mu) = Long-term mean\n    σ (sigma) = Volatility\n    W_t = Wiener process\n\nKey metrics:\n    - Half-life: ln(2) / θ (time to revert halfway to mean)\n    - Z-score: (S_t - μ) / σ (standardized deviation from mean)\n\nApplications for forex:\n    - EURUSD vs GBPUSD (European correlation)\n    - AUDUSD vs NZDUSD (Oceania correlation)\n    - USDCAD vs USDNOK (Commodity currencies)", "source": "core\\_experimental\\ou_spread_trading.py", "category": "volatility"}
{"instruction": "What is the OUSpreadTrading class and how do I use it?", "input": "", "output": "The OUSpreadTrading class:\n\nOrnstein-Uhlenbeck Process for Pairs Trading.\n\nUsage:\n    ou = OUSpreadTrading()\n    ou.estimate_parameters(spread)\n    if ou.half_life() < 30:  # Mean reverts within 30 days\n        signals = ou.generate_signals(spread)", "source": "core\\_experimental\\ou_spread_trading.py", "category": "alpha"}
{"instruction": "Show me a code example for OUSpreadTrading", "input": "", "output": "ou = OUSpreadTrading()\n    ou.estimate_parameters(spread)\n    if ou.half_life() < 30:  # Mean reverts within 30 days\n        signals = ou.generate_signals(spread)", "source": "core\\_experimental\\ou_spread_trading.py", "category": "alpha"}
{"instruction": "What is the PairsTradingSystem class and how do I use it?", "input": "", "output": "The PairsTradingSystem class:\n\nComplete pairs trading system using OU process.\n\nManages multiple pairs, automatic pair selection, and portfolio allocation.", "source": "core\\_experimental\\ou_spread_trading.py", "category": "general"}
{"instruction": "What is the formula for Estimate Parameters?", "input": "", "output": "Estimate OU parameters using Maximum Likelihood Estimation.\n\nThe MLE estimates for OU process:\n    θ = -log(ρ) / dt  where ρ is AR(1) coefficient\n    μ = mean(S)\n    σ = std(dS) / sqrt(dt)\n\nArgs:\n    spread: Spread time series\n    dt: Time step (default 1/252 for daily data)\n    method: 'mle' or 'ols'\n\nReturns:\n    Dict with theta, mu, sigma", "source": "core\\_experimental\\ou_spread_trading.py", "category": "microstructure"}
{"instruction": "Explain the Estimate Parameters function", "input": "", "output": "Function: estimate_parameters\n\nEstimate OU parameters using Maximum Likelihood Estimation.\n\nThe MLE estimates for OU process:\n    θ = -log(ρ) / dt  where ρ is AR(1) coefficient\n    μ = mean(S)\n    σ = std(dS) / sqrt(dt)\n\nArgs:\n    spread: Spread time series\n    dt: Time step (default 1/252 for daily data)\n    method: 'mle' or 'ols'\n\nReturns:\n    Dict with theta, mu, sigma", "source": "core\\_experimental\\ou_spread_trading.py", "category": "microstructure"}
{"instruction": "What is the formula for Fit Mle Optimizer?", "input": "", "output": "Fit OU parameters using numerical MLE optimization.\n\nMore accurate but slower than closed-form estimates.", "source": "core\\_experimental\\ou_spread_trading.py", "category": "general"}
{"instruction": "Explain the Fit Mle Optimizer function", "input": "", "output": "Function: fit_mle_optimizer\n\nFit OU parameters using numerical MLE optimization.\n\nMore accurate but slower than closed-form estimates.", "source": "core\\_experimental\\ou_spread_trading.py", "category": "general"}
{"instruction": "What is the formula for Half Life?", "input": "", "output": "Compute half-life of mean reversion: ln(2) / θ.\n\nThe half-life is the expected time for the spread to move\nhalfway back to its long-term mean.\n\nReturns:\n    Half-life in same units as dt (typically days)", "source": "core\\_experimental\\ou_spread_trading.py", "category": "microstructure"}
{"instruction": "Explain the Half Life function", "input": "", "output": "Function: half_life\n\nCompute half-life of mean reversion: ln(2) / θ.\n\nThe half-life is the expected time for the spread to move\nhalfway back to its long-term mean.\n\nReturns:\n    Half-life in same units as dt (typically days)", "source": "core\\_experimental\\ou_spread_trading.py", "category": "microstructure"}
{"instruction": "What is the formula for Expected Reversion Time?", "input": "", "output": "Time to revert given percentage toward mean.\n\nArgs:\n    target_pct: Percentage reversion (e.g., 0.9 = 90% reversion)\n\nReturns:\n    Expected time in periods", "source": "core\\_experimental\\ou_spread_trading.py", "category": "general"}
{"instruction": "Explain the Expected Reversion Time function", "input": "", "output": "Function: expected_reversion_time\n\nTime to revert given percentage toward mean.\n\nArgs:\n    target_pct: Percentage reversion (e.g., 0.9 = 90% reversion)\n\nReturns:\n    Expected time in periods", "source": "core\\_experimental\\ou_spread_trading.py", "category": "general"}
{"instruction": "What is the formula for Zscore?", "input": "", "output": "Compute z-score for entry/exit signals.\n\nZ-score = (S - μ) / σ\n\nArgs:\n    spread: Spread series\n    window: Rolling window for dynamic mean/std. If None, use fitted params.\n\nReturns:\n    Z-score series", "source": "core\\_experimental\\ou_spread_trading.py", "category": "alpha"}
{"instruction": "Explain the Zscore function", "input": "", "output": "Function: zscore\n\nCompute z-score for entry/exit signals.\n\nZ-score = (S - μ) / σ\n\nArgs:\n    spread: Spread series\n    window: Rolling window for dynamic mean/std. If None, use fitted params.\n\nReturns:\n    Z-score series", "source": "core\\_experimental\\ou_spread_trading.py", "category": "alpha"}
{"instruction": "What is the formula for Generate Signals?", "input": "", "output": "Generate trading signals based on z-score thresholds.\n\nStrategy:\n    - Enter short when z > entry_z (spread above mean)\n    - Enter long when z < -entry_z (spread below mean)\n    - Exit when |z| < exit_z (spread near mean)\n    - Stop loss when |z| > stop_z\n\nArgs:\n    spread: Spread series\n    entry_z: Z-score threshold for entry (default 2.0)\n    exit_z: Z-score threshold for exit (default 0.5)\n    stop_z: Z-score threshold for stop loss (default 4.0)\n\nReturns:\n    Signal series: 1 (long spread), -1 (short spread), 0 (flat)", "source": "core\\_experimental\\ou_spread_trading.py", "category": "alpha"}
{"instruction": "Explain the Generate Signals function", "input": "", "output": "Function: generate_signals\n\nGenerate trading signals based on z-score thresholds.\n\nStrategy:\n    - Enter short when z > entry_z (spread above mean)\n    - Enter long when z < -entry_z (spread below mean)\n    - Exit when |z| < exit_z (spread near mean)\n    - Stop loss when |z| > stop_z\n\nArgs:\n    spread: Spread series\n    entry_z: Z-score threshold for entry (default 2.0)\n    exit_z: Z-score threshold for exit (default 0.5)\n    stop_z: Z-score threshold for stop loss (default 4.0)\n\nReturns:\n    Signal series: 1 (long spread), -1 (short spread), 0 (flat)", "source": "core\\_experimental\\ou_spread_trading.py", "category": "alpha"}
{"instruction": "What is the formula for Generate Continuous Signals?", "input": "", "output": "Generate continuous position signals based on z-score.\n\nPosition size proportional to z-score deviation.\nLarger deviation = larger position (up to max_position).\n\nArgs:\n    spread: Spread series\n    max_position: Maximum position size\n\nReturns:\n    Continuous signal series between -max_position and +max_position", "source": "core\\_experimental\\ou_spread_trading.py", "category": "alpha"}
{"instruction": "Explain the Generate Continuous Signals function", "input": "", "output": "Function: generate_continuous_signals\n\nGenerate continuous position signals based on z-score.\n\nPosition size proportional to z-score deviation.\nLarger deviation = larger position (up to max_position).\n\nArgs:\n    spread: Spread series\n    max_position: Maximum position size\n\nReturns:\n    Continuous signal series between -max_position and +max_position", "source": "core\\_experimental\\ou_spread_trading.py", "category": "alpha"}
{"instruction": "What is the formula for Compute Hedge Ratio?", "input": "", "output": "Compute optimal hedge ratio for spread construction.\n\nSpread = asset1 - hedge_ratio * asset2\n\nArgs:\n    asset1: First asset price series\n    asset2: Second asset price series\n    method: 'ols', 'tls' (total least squares), or 'rolling'\n\nReturns:\n    Optimal hedge ratio", "source": "core\\_experimental\\ou_spread_trading.py", "category": "microstructure"}
{"instruction": "Explain the Compute Hedge Ratio function", "input": "", "output": "Function: compute_hedge_ratio\n\nCompute optimal hedge ratio for spread construction.\n\nSpread = asset1 - hedge_ratio * asset2\n\nArgs:\n    asset1: First asset price series\n    asset2: Second asset price series\n    method: 'ols', 'tls' (total least squares), or 'rolling'\n\nReturns:\n    Optimal hedge ratio", "source": "core\\_experimental\\ou_spread_trading.py", "category": "microstructure"}
{"instruction": "What is the formula for Construct Spread?", "input": "", "output": "Construct spread from two asset series.\n\nSpread = asset1 - hedge_ratio * asset2\n\nArgs:\n    asset1: First asset series\n    asset2: Second asset series\n    hedge_ratio: If None, compute optimal ratio\n\nReturns:\n    Spread series", "source": "core\\_experimental\\ou_spread_trading.py", "category": "microstructure"}
{"instruction": "Explain the Construct Spread function", "input": "", "output": "Function: construct_spread\n\nConstruct spread from two asset series.\n\nSpread = asset1 - hedge_ratio * asset2\n\nArgs:\n    asset1: First asset series\n    asset2: Second asset series\n    hedge_ratio: If None, compute optimal ratio\n\nReturns:\n    Spread series", "source": "core\\_experimental\\ou_spread_trading.py", "category": "microstructure"}
{"instruction": "What is the formula for Adf Test?", "input": "", "output": "Augmented Dickey-Fuller test for stationarity (mean-reversion).\n\nNull hypothesis: spread has a unit root (not stationary)\nLow p-value = reject null = spread is stationary = mean-reverting\n\nArgs:\n    spread: Spread series\n    regression: 'c' (constant), 'ct' (constant+trend), 'ctt', 'n'\n\nReturns:\n    Dict with test statistic, p-value, critical values", "source": "core\\_experimental\\ou_spread_trading.py", "category": "microstructure"}
{"instruction": "Explain the Adf Test function", "input": "", "output": "Function: adf_test\n\nAugmented Dickey-Fuller test for stationarity (mean-reversion).\n\nNull hypothesis: spread has a unit root (not stationary)\nLow p-value = reject null = spread is stationary = mean-reverting\n\nArgs:\n    spread: Spread series\n    regression: 'c' (constant), 'ct' (constant+trend), 'ctt', 'n'\n\nReturns:\n    Dict with test statistic, p-value, critical values", "source": "core\\_experimental\\ou_spread_trading.py", "category": "microstructure"}
{"instruction": "Explain the Johansen Test function", "input": "", "output": "Function: johansen_test\n\nSimplified Johansen cointegration test for two series.\n\nTests for cointegrating relationship between asset1 and asset2.\n\nReturns:\n    Dict with test results", "source": "core\\_experimental\\ou_spread_trading.py", "category": "general"}
{"instruction": "What is the formula for Simulate Ou?", "input": "", "output": "Simulate OU process path.\n\nUses exact discretization:\n    S_t = S_{t-1} * exp(-θdt) + μ(1 - exp(-θdt)) + σ√((1-exp(-2θdt))/(2θ)) * Z\n\nArgs:\n    n_steps: Number of time steps\n    dt: Time step size\n    S0: Initial value (default: mu)\n\nReturns:\n    Simulated spread series", "source": "core\\_experimental\\ou_spread_trading.py", "category": "microstructure"}
{"instruction": "Explain the Simulate Ou function", "input": "", "output": "Function: simulate_ou\n\nSimulate OU process path.\n\nUses exact discretization:\n    S_t = S_{t-1} * exp(-θdt) + μ(1 - exp(-θdt)) + σ√((1-exp(-2θdt))/(2θ)) * Z\n\nArgs:\n    n_steps: Number of time steps\n    dt: Time step size\n    S0: Initial value (default: mu)\n\nReturns:\n    Simulated spread series", "source": "core\\_experimental\\ou_spread_trading.py", "category": "microstructure"}
{"instruction": "What is the formula for Backtest Strategy?", "input": "", "output": "Backtest pairs trading strategy.\n\nArgs:\n    spread: Spread series\n    entry_z: Z-score entry threshold\n    exit_z: Z-score exit threshold\n    transaction_cost: Cost per trade as fraction\n\nReturns:\n    Dict with performance metrics", "source": "core\\_experimental\\ou_spread_trading.py", "category": "microstructure"}
{"instruction": "Explain the Backtest Strategy function", "input": "", "output": "Function: backtest_strategy\n\nBacktest pairs trading strategy.\n\nArgs:\n    spread: Spread series\n    entry_z: Z-score entry threshold\n    exit_z: Z-score exit threshold\n    transaction_cost: Cost per trade as fraction\n\nReturns:\n    Dict with performance metrics", "source": "core\\_experimental\\ou_spread_trading.py", "category": "microstructure"}
{"instruction": "Explain the Get Forex Pairs Candidates function", "input": "", "output": "Function: get_forex_pairs_candidates\n\nGet list of candidate forex pairs for pairs trading.\n\nReturns:\n    List of (pair1, pair2, rationale) tuples", "source": "core\\_experimental\\ou_spread_trading.py", "category": "general"}
{"instruction": "What is the formula for Scan Pairs?", "input": "", "output": "Scan candidate pairs for tradeable relationships.\n\nArgs:\n    price_data: Dict of symbol -> price series\n    candidate_pairs: List of (symbol1, symbol2) pairs to test\n\nReturns:\n    DataFrame with pair statistics", "source": "core\\_experimental\\ou_spread_trading.py", "category": "general"}
{"instruction": "Explain the Scan Pairs function", "input": "", "output": "Function: scan_pairs\n\nScan candidate pairs for tradeable relationships.\n\nArgs:\n    price_data: Dict of symbol -> price series\n    candidate_pairs: List of (symbol1, symbol2) pairs to test\n\nReturns:\n    DataFrame with pair statistics", "source": "core\\_experimental\\ou_spread_trading.py", "category": "general"}
{"instruction": "Explain the Get Signals function", "input": "", "output": "Function: get_signals\n\nGet trading signals for all registered pairs.\n\nReturns:\n    DataFrame with signals for each pair", "source": "core\\_experimental\\ou_spread_trading.py", "category": "alpha"}
{"instruction": "Explain the purpose of Gold Standard Quantitative Formulas", "input": "", "output": "Gold Standard Quantitative Formulas\n====================================\nMathematical methods verified from Chinese quants, WorldQuant, and academic research.\n\nSources:\n- WorldQuant Alpha101 (101 Formulaic Alphas paper)\n- Avellaneda-Stoikov (HFT Market Making, 2008)\n- Marcos Lopez de Prado (Advances in Financial Machine Learning)\n- Chinese quant research (Tsinghua, Peking University)\n- Kelly Criterion (Edward Thorp)\n- Almgren-Chriss (Optimal Execution)\n\nThese are PROVEN mathematical formulas used by billion-dollar quants.", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "What is the Alpha101Forex class and how do I use it?", "input": "", "output": "The Alpha101Forex class:\n\nWorldQuant Alpha101 formulas adapted for forex.\n\nOriginal paper: \"101 Formulaic Alphas\" by Zura Kakushadze (2016)\nThese alphas use OHLCV data to generate trading signals.\n\nAdapted from: https://github.com/yli188/WorldQuant_alpha101_code", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "What is the AvellanedaStoikov class and how do I use it?", "input": "", "output": "The AvellanedaStoikov class:\n\nAvellaneda-Stoikov HFT Market Making Model.\n\nPaper: \"High-frequency trading in a limit order book\" (2008)\nSource: https://github.com/fedecaccia/avellaneda-stoikov\n\nThis calculates optimal bid/ask quotes for market making.", "source": "core\\_experimental\\quant_formulas.py", "category": "microstructure"}
{"instruction": "What is the KellyCriterion class and how do I use it?", "input": "", "output": "The KellyCriterion class:\n\nKelly Criterion for optimal position sizing.\n\nSource: Edward Thorp, \"Beat the Dealer\" (1962)\n\nf* = (p * b - q) / b\n\nWhere:\n    f* = optimal fraction of bankroll to bet\n    p = probability of winning\n    q = probability of losing (1 - p)\n    b = odds (net return if win)\n\nFor trading: f* = (expected_return) / (variance)", "source": "core\\_experimental\\quant_formulas.py", "category": "risk"}
{"instruction": "What is the TripleBarrier class and how do I use it?", "input": "", "output": "The TripleBarrier class:\n\nTriple Barrier Method for labeling trades.\n\nSource: Marcos Lopez de Prado, \"Advances in Financial Machine Learning\" (2018)\n\nThree barriers:\n1. Upper barrier (profit taking)\n2. Lower barrier (stop loss)\n3. Vertical barrier (time limit)\n\nThe first barrier touched determines the label.", "source": "core\\_experimental\\quant_formulas.py", "category": "general"}
{"instruction": "What is the FractionalDifferentiation class and how do I use it?", "input": "", "output": "The FractionalDifferentiation class:\n\nFractional Differentiation for stationarity while preserving memory.\n\nSource: Marcos Lopez de Prado, \"Advances in Financial Machine Learning\" (2018)\n\nStandard differentiation (d=1) removes all memory.\nFractional differentiation (0 < d < 1) balances stationarity and memory.", "source": "core\\_experimental\\quant_formulas.py", "category": "general"}
{"instruction": "What is the AlmgrenChriss class and how do I use it?", "input": "", "output": "The AlmgrenChriss class:\n\nAlmgren-Chriss Optimal Execution Model.\n\nPaper: \"Optimal Execution of Portfolio Transactions\" (2000)\nSource: https://github.com/joshuapjacob/almgren-chriss-optimal-execution\n\nBalances market impact vs timing risk for large orders.", "source": "core\\_experimental\\quant_formulas.py", "category": "risk"}
{"instruction": "What is the StochasticVolatility class and how do I use it?", "input": "", "output": "The StochasticVolatility class:\n\nStochastic Volatility Models.\n\nSources:\n- Heston (1993)\n- SABR (Hagan et al., 2002)\n- Chinese research from Peking University", "source": "core\\_experimental\\quant_formulas.py", "category": "volatility"}
{"instruction": "Explain the Create Quant Formulas function", "input": "", "output": "Function: create_quant_formulas\n\nCreate all quant formula calculators.\n\nReturns:\n    Dict with all formula calculators", "source": "core\\_experimental\\quant_formulas.py", "category": "general"}
{"instruction": "What is the formula for Rank?", "input": "", "output": "Cross-sectional rank (percentile).", "source": "core\\_experimental\\quant_formulas.py", "category": "general"}
{"instruction": "Explain the Rank function", "input": "", "output": "Function: rank\n\nCross-sectional rank (percentile).", "source": "core\\_experimental\\quant_formulas.py", "category": "general"}
{"instruction": "Explain the Delta function", "input": "", "output": "Function: delta\n\nDifference from period ago.", "source": "core\\_experimental\\quant_formulas.py", "category": "general"}
{"instruction": "Explain the Delay function", "input": "", "output": "Function: delay\n\nLag by period.", "source": "core\\_experimental\\quant_formulas.py", "category": "general"}
{"instruction": "Explain the Correlation function", "input": "", "output": "Function: correlation\n\nRolling correlation.", "source": "core\\_experimental\\quant_formulas.py", "category": "general"}
{"instruction": "Explain the Covariance function", "input": "", "output": "Function: covariance\n\nRolling covariance.", "source": "core\\_experimental\\quant_formulas.py", "category": "risk"}
{"instruction": "What is the formula for Ts Rank?", "input": "", "output": "Time-series rank over window.", "source": "core\\_experimental\\quant_formulas.py", "category": "general"}
{"instruction": "Explain the Ts Rank function", "input": "", "output": "Function: ts_rank\n\nTime-series rank over window.", "source": "core\\_experimental\\quant_formulas.py", "category": "general"}
{"instruction": "Explain the Ts Max function", "input": "", "output": "Function: ts_max\n\nRolling max.", "source": "core\\_experimental\\quant_formulas.py", "category": "general"}
{"instruction": "Explain the Ts Min function", "input": "", "output": "Function: ts_min\n\nRolling min.", "source": "core\\_experimental\\quant_formulas.py", "category": "general"}
{"instruction": "Explain the Ts Argmax function", "input": "", "output": "Function: ts_argmax\n\nPosition of max in window.", "source": "core\\_experimental\\quant_formulas.py", "category": "general"}
{"instruction": "Explain the Ts Argmin function", "input": "", "output": "Function: ts_argmin\n\nPosition of min in window.", "source": "core\\_experimental\\quant_formulas.py", "category": "general"}
{"instruction": "Explain the Stddev function", "input": "", "output": "Function: stddev\n\nRolling standard deviation.", "source": "core\\_experimental\\quant_formulas.py", "category": "general"}
{"instruction": "Explain the Sum Rolling function", "input": "", "output": "Function: sum_rolling\n\nRolling sum.", "source": "core\\_experimental\\quant_formulas.py", "category": "general"}
{"instruction": "Explain the Product function", "input": "", "output": "Function: product\n\nRolling product.", "source": "core\\_experimental\\quant_formulas.py", "category": "general"}
{"instruction": "What is the formula for Alpha 1?", "input": "", "output": "Alpha#1: (rank(Ts_ArgMax(SignedPower(((returns < 0) ? stddev(returns, 20) : close), 2.), 5)) - 0.5)\nMomentum reversal signal.", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "Explain the Alpha 1 function", "input": "", "output": "Function: alpha001\n\nAlpha#1: (rank(Ts_ArgMax(SignedPower(((returns < 0) ? stddev(returns, 20) : close), 2.), 5)) - 0.5)\nMomentum reversal signal.", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 2?", "input": "", "output": "Alpha#2: (-1 * correlation(rank(delta(log(volume), 2)), rank(((close - open) / open)), 6))\nVolume-price divergence.", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "Explain the Alpha 2 function", "input": "", "output": "Function: alpha002\n\nAlpha#2: (-1 * correlation(rank(delta(log(volume), 2)), rank(((close - open) / open)), 6))\nVolume-price divergence.", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 3?", "input": "", "output": "Alpha#3: (-1 * correlation(rank(open), rank(volume), 10))\nOpen-volume correlation.", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "Explain the Alpha 3 function", "input": "", "output": "Function: alpha003\n\nAlpha#3: (-1 * correlation(rank(open), rank(volume), 10))\nOpen-volume correlation.", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 4?", "input": "", "output": "Alpha#4: (-1 * Ts_Rank(rank(low), 9))\nLow price momentum.", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "Explain the Alpha 4 function", "input": "", "output": "Function: alpha004\n\nAlpha#4: (-1 * Ts_Rank(rank(low), 9))\nLow price momentum.", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 6?", "input": "", "output": "Alpha#6: (-1 * correlation(open, volume, 10))\nSimple open-volume correlation.", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "Explain the Alpha 6 function", "input": "", "output": "Function: alpha006\n\nAlpha#6: (-1 * correlation(open, volume, 10))\nSimple open-volume correlation.", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 12?", "input": "", "output": "Alpha#12: (sign(delta(volume, 1)) * (-1 * delta(close, 1)))\nVolume-confirmed price reversal.", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "Explain the Alpha 12 function", "input": "", "output": "Function: alpha012\n\nAlpha#12: (sign(delta(volume, 1)) * (-1 * delta(close, 1)))\nVolume-confirmed price reversal.", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 13?", "input": "", "output": "Alpha#13: (-1 * rank(covariance(rank(close), rank(volume), 5)))\nPrice-volume covariance.", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "Explain the Alpha 13 function", "input": "", "output": "Function: alpha013\n\nAlpha#13: (-1 * rank(covariance(rank(close), rank(volume), 5)))\nPrice-volume covariance.", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 14?", "input": "", "output": "Alpha#14: ((-1 * rank(delta(returns, 3))) * correlation(open, volume, 10))\nReturn momentum with volume confirmation.", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "Explain the Alpha 14 function", "input": "", "output": "Function: alpha014\n\nAlpha#14: ((-1 * rank(delta(returns, 3))) * correlation(open, volume, 10))\nReturn momentum with volume confirmation.", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 17?", "input": "", "output": "Alpha#17: (((-1 * rank(ts_rank(close, 10))) * rank(delta(delta(close, 1), 1))) * rank(ts_rank((volume / adv20), 5)))\nComplex momentum signal.", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "Explain the Alpha 17 function", "input": "", "output": "Function: alpha017\n\nAlpha#17: (((-1 * rank(ts_rank(close, 10))) * rank(delta(delta(close, 1), 1))) * rank(ts_rank((volume / adv20), 5)))\nComplex momentum signal.", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 20?", "input": "", "output": "Alpha#20: (((-1 * rank((open - delay(high, 1)))) * rank((open - delay(close, 1)))) * rank((open - delay(low, 1))))\nGap analysis.", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "Explain the Alpha 20 function", "input": "", "output": "Function: alpha020\n\nAlpha#20: (((-1 * rank((open - delay(high, 1)))) * rank((open - delay(close, 1)))) * rank((open - delay(low, 1))))\nGap analysis.", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 33?", "input": "", "output": "Alpha#33: rank((-1 * ((1 - (open / close))^1)))\nOpen-close ratio.", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "Explain the Alpha 33 function", "input": "", "output": "Function: alpha033\n\nAlpha#33: rank((-1 * ((1 - (open / close))^1)))\nOpen-close ratio.", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 34?", "input": "", "output": "Alpha#34: rank(((1 - rank((stddev(returns, 2) / stddev(returns, 5)))) + (1 - rank(delta(close, 1)))))\nVolatility regime signal.", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "Explain the Alpha 34 function", "input": "", "output": "Function: alpha034\n\nAlpha#34: rank(((1 - rank((stddev(returns, 2) / stddev(returns, 5)))) + (1 - rank(delta(close, 1)))))\nVolatility regime signal.", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 38?", "input": "", "output": "Alpha#38: ((-1 * rank(Ts_Rank(close, 10))) * rank((close / open)))\nClose momentum with intraday ratio.", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "Explain the Alpha 38 function", "input": "", "output": "Function: alpha038\n\nAlpha#38: ((-1 * rank(Ts_Rank(close, 10))) * rank((close / open)))\nClose momentum with intraday ratio.", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 41?", "input": "", "output": "Alpha#41: (((high * low)^0.5) - vwap)\nGeometric mean vs VWAP approximation.", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "Explain the Alpha 41 function", "input": "", "output": "Function: alpha041\n\nAlpha#41: (((high * low)^0.5) - vwap)\nGeometric mean vs VWAP approximation.", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "What is VWAP in quantitative trading?", "input": "", "output": "VWAP (Volume-Weighted Average Price execution).\n\nImplementation details:\nAlpha#41: (((high * low)^0.5) - vwap)\nGeometric mean vs VWAP approximation.", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "What is the formula for Alpha 53?", "input": "", "output": "Alpha#53: ((-1 * delta((((close - low) - (high - close)) / (close - low)), 9)))\nPrice position within range.", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "Explain the Alpha 53 function", "input": "", "output": "Function: alpha053\n\nAlpha#53: ((-1 * delta((((close - low) - (high - close)) / (close - low)), 9)))\nPrice position within range.", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "Explain the Generate All Alphas function", "input": "", "output": "Function: generate_all_alphas\n\nGenerate all Alpha101 signals for forex data.\n\nArgs:\n    df: DataFrame with columns: open, high, low, close, volume (or tick_count for forex)\n\nReturns:\n    DataFrame with alpha signals added", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "What is the formula for Reservation Price?", "input": "", "output": "Calculate the reservation (indifference) price.\n\nr(s,q,t) = s - q * gamma * sigma^2 * (T - t)\n\nThe reservation price adjusts the mid price based on inventory:\n- Positive inventory (long) -> lower reservation price (encourage selling)\n- Negative inventory (short) -> higher reservation price (encourage buying)\n\nArgs:\n    mid_price: Current mid price\n    inventory: Current inventory position (positive = long, negative = short)\n    time_remaining: Time remaining until end of trading period (0 to 1)\n\nReturns:\n    Reservation price", "source": "core\\_experimental\\quant_formulas.py", "category": "general"}
{"instruction": "Explain the Reservation Price function", "input": "", "output": "Function: reservation_price\n\nCalculate the reservation (indifference) price.\n\nr(s,q,t) = s - q * gamma * sigma^2 * (T - t)\n\nThe reservation price adjusts the mid price based on inventory:\n- Positive inventory (long) -> lower reservation price (encourage selling)\n- Negative inventory (short) -> higher reservation price (encourage buying)\n\nArgs:\n    mid_price: Current mid price\n    inventory: Current inventory position (positive = long, negative = short)\n    time_remaining: Time remaining until end of trading period (0 to 1)\n\nReturns:\n    Reservation price", "source": "core\\_experimental\\quant_formulas.py", "category": "general"}
{"instruction": "What is the formula for Optimal Spread?", "input": "", "output": "Calculate the optimal bid-ask spread.\n\ndelta(t) = gamma * sigma^2 * (T - t) + (2/gamma) * ln(1 + gamma/k)\n\nArgs:\n    time_remaining: Time remaining until end of trading period\n\nReturns:\n    Optimal spread (divide by 2 for each side)", "source": "core\\_experimental\\quant_formulas.py", "category": "microstructure"}
{"instruction": "Explain the Optimal Spread function", "input": "", "output": "Function: optimal_spread\n\nCalculate the optimal bid-ask spread.\n\ndelta(t) = gamma * sigma^2 * (T - t) + (2/gamma) * ln(1 + gamma/k)\n\nArgs:\n    time_remaining: Time remaining until end of trading period\n\nReturns:\n    Optimal spread (divide by 2 for each side)", "source": "core\\_experimental\\quant_formulas.py", "category": "microstructure"}
{"instruction": "Explain the Optimal Quotes function", "input": "", "output": "Function: optimal_quotes\n\nCalculate optimal bid and ask quotes.\n\nArgs:\n    mid_price: Current mid price\n    inventory: Current inventory position\n    time_remaining: Time remaining (0 to 1)\n\nReturns:\n    Tuple of (bid_price, ask_price)", "source": "core\\_experimental\\quant_formulas.py", "category": "microstructure"}
{"instruction": "What is the formula for Inventory Skew?", "input": "", "output": "Calculate inventory skew factor.\n\nUsed to adjust spreads based on inventory levels:\n- At max inventory, widen the side we want to exit\n- At zero inventory, symmetric spreads\n\nArgs:\n    inventory: Current position\n    max_inventory: Maximum allowed inventory\n\nReturns:\n    Skew factor (-1 to 1)", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "Explain the Inventory Skew function", "input": "", "output": "Function: inventory_skew\n\nCalculate inventory skew factor.\n\nUsed to adjust spreads based on inventory levels:\n- At max inventory, widen the side we want to exit\n- At zero inventory, symmetric spreads\n\nArgs:\n    inventory: Current position\n    max_inventory: Maximum allowed inventory\n\nReturns:\n    Skew factor (-1 to 1)", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "Explain the Get Signals function", "input": "", "output": "Function: get_signals\n\nGenerate market making signals for a DataFrame.\n\nArgs:\n    df: DataFrame with 'mid' or 'close' price column\n    inventory: Current inventory position\n    trading_hours: Total trading hours in period\n\nReturns:\n    DataFrame with bid, ask, reservation price columns", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "What is the formula for Kelly Fraction?", "input": "", "output": "Calculate Kelly fraction for binary outcomes.\n\nArgs:\n    win_prob: Probability of winning (0 to 1)\n    win_loss_ratio: Average win / Average loss\n\nReturns:\n    Optimal fraction to bet (0 to 1, can be negative for short)", "source": "core\\_experimental\\quant_formulas.py", "category": "risk"}
{"instruction": "Explain the Kelly Fraction function", "input": "", "output": "Function: kelly_fraction\n\nCalculate Kelly fraction for binary outcomes.\n\nArgs:\n    win_prob: Probability of winning (0 to 1)\n    win_loss_ratio: Average win / Average loss\n\nReturns:\n    Optimal fraction to bet (0 to 1, can be negative for short)", "source": "core\\_experimental\\quant_formulas.py", "category": "risk"}
{"instruction": "What is Kelly Criterion in quantitative trading?", "input": "", "output": "Kelly Criterion (position sizing formula that maximizes long-term growth).\n\nImplementation details:\nCalculate Kelly fraction for binary outcomes.\n\nArgs:\n    win_prob: Probability of winning (0 to 1)\n    win_loss_ratio: Average win / Average loss\n\nReturns:\n    Optimal fraction to bet (0 to 1, can be negative for short)", "source": "core\\_experimental\\quant_formulas.py", "category": "risk"}
{"instruction": "What is the formula for Fractional Kelly?", "input": "", "output": "Calculate fractional Kelly (more conservative).\n\nHalf-Kelly (fraction=0.5) gives:\n- 75% of optimal growth rate\n- 25% of the variance\n\nQuarter-Kelly (fraction=0.25) gives:\n- 43.75% of optimal growth rate\n- 6.25% of the variance\n\nArgs:\n    win_prob: Probability of winning\n    win_loss_ratio: Average win / Average loss\n    fraction: Fraction of Kelly to use (0.25 to 0.5 recommended)\n\nReturns:\n    Fractional Kelly bet size", "source": "core\\_experimental\\quant_formulas.py", "category": "risk"}
{"instruction": "Explain the Fractional Kelly function", "input": "", "output": "Function: fractional_kelly\n\nCalculate fractional Kelly (more conservative).\n\nHalf-Kelly (fraction=0.5) gives:\n- 75% of optimal growth rate\n- 25% of the variance\n\nQuarter-Kelly (fraction=0.25) gives:\n- 43.75% of optimal growth rate\n- 6.25% of the variance\n\nArgs:\n    win_prob: Probability of winning\n    win_loss_ratio: Average win / Average loss\n    fraction: Fraction of Kelly to use (0.25 to 0.5 recommended)\n\nReturns:\n    Fractional Kelly bet size", "source": "core\\_experimental\\quant_formulas.py", "category": "risk"}
{"instruction": "What is Kelly Criterion in quantitative trading?", "input": "", "output": "Kelly Criterion (position sizing formula that maximizes long-term growth).\n\nImplementation details:\nCalculate fractional Kelly (more conservative).\n\nHalf-Kelly (fraction=0.5) gives:\n- 75% of optimal growth rate\n- 25% of the variance\n\nQuarter-Kelly (fraction=0.25) gives:\n- 43.75% of optimal growth rate\n- 6.25% of the variance\n\nArgs:\n    win_prob: Probability of winning\n    win_loss_ratio: Average win / Average loss\n    fraction: Fraction of Kelly to use (0.25 to 0.5 recommended)\n\nReturns:\n    Fractional Kelly bet size", "source": "core\\_experimental\\quant_formulas.py", "category": "risk"}
{"instruction": "What is the formula for Kelly From Returns?", "input": "", "output": "Calculate Kelly fraction from historical returns.\n\nf* = mean(returns) / var(returns)\n\nArgs:\n    returns: Series of historical returns\n\nReturns:\n    Optimal Kelly fraction", "source": "core\\_experimental\\quant_formulas.py", "category": "risk"}
{"instruction": "Explain the Kelly From Returns function", "input": "", "output": "Function: kelly_from_returns\n\nCalculate Kelly fraction from historical returns.\n\nf* = mean(returns) / var(returns)\n\nArgs:\n    returns: Series of historical returns\n\nReturns:\n    Optimal Kelly fraction", "source": "core\\_experimental\\quant_formulas.py", "category": "risk"}
{"instruction": "What is Kelly Criterion in quantitative trading?", "input": "", "output": "Kelly Criterion (position sizing formula that maximizes long-term growth).\n\nImplementation details:\nCalculate Kelly fraction from historical returns.\n\nf* = mean(returns) / var(returns)\n\nArgs:\n    returns: Series of historical returns\n\nReturns:\n    Optimal Kelly fraction", "source": "core\\_experimental\\quant_formulas.py", "category": "risk"}
{"instruction": "What is the formula for Optimal Leverage?", "input": "", "output": "Calculate optimal leverage using Kelly.\n\nf* = (mu - r) / sigma^2\n\nWhere:\n    mu = expected return\n    r = risk-free rate\n    sigma = volatility\n\nArgs:\n    returns: Historical returns\n    risk_free_rate: Risk-free rate (same frequency as returns)\n\nReturns:\n    Optimal leverage (>1 means leverage, <1 means partial investment)", "source": "core\\_experimental\\quant_formulas.py", "category": "volatility"}
{"instruction": "Explain the Optimal Leverage function", "input": "", "output": "Function: optimal_leverage\n\nCalculate optimal leverage using Kelly.\n\nf* = (mu - r) / sigma^2\n\nWhere:\n    mu = expected return\n    r = risk-free rate\n    sigma = volatility\n\nArgs:\n    returns: Historical returns\n    risk_free_rate: Risk-free rate (same frequency as returns)\n\nReturns:\n    Optimal leverage (>1 means leverage, <1 means partial investment)", "source": "core\\_experimental\\quant_formulas.py", "category": "volatility"}
{"instruction": "What is Kelly Criterion in quantitative trading?", "input": "", "output": "Kelly Criterion (position sizing formula that maximizes long-term growth).\n\nImplementation details:\nCalculate optimal leverage using Kelly.\n\nf* = (mu - r) / sigma^2\n\nWhere:\n    mu = expected return\n    r = risk-free rate\n    sigma = volatility\n\nArgs:\n    returns: Historical returns\n    risk_free_rate: Risk-free rate (same frequency as returns)\n\nReturns:\n    Optimal leverage (>1 means leverage, <1 means partial investment)", "source": "core\\_experimental\\quant_formulas.py", "category": "volatility"}
{"instruction": "What is the formula for Position Size?", "input": "", "output": "Calculate actual position size in currency.\n\nArgs:\n    account_value: Total account value\n    win_prob: Probability of winning\n    win_loss_ratio: Average win / Average loss\n    fraction: Kelly fraction (0.5 = half Kelly)\n    max_position_pct: Maximum position as % of account\n\nReturns:\n    Position size in currency units", "source": "core\\_experimental\\quant_formulas.py", "category": "risk"}
{"instruction": "Explain the Position Size function", "input": "", "output": "Function: position_size\n\nCalculate actual position size in currency.\n\nArgs:\n    account_value: Total account value\n    win_prob: Probability of winning\n    win_loss_ratio: Average win / Average loss\n    fraction: Kelly fraction (0.5 = half Kelly)\n    max_position_pct: Maximum position as % of account\n\nReturns:\n    Position size in currency units", "source": "core\\_experimental\\quant_formulas.py", "category": "risk"}
{"instruction": "What is Kelly Criterion in quantitative trading?", "input": "", "output": "Kelly Criterion (position sizing formula that maximizes long-term growth).\n\nImplementation details:\nCalculate actual position size in currency.\n\nArgs:\n    account_value: Total account value\n    win_prob: Probability of winning\n    win_loss_ratio: Average win / Average loss\n    fraction: Kelly fraction (0.5 = half Kelly)\n    max_position_pct: Maximum position as % of account\n\nReturns:\n    Position size in currency units", "source": "core\\_experimental\\quant_formulas.py", "category": "risk"}
{"instruction": "Explain the Get Vertical Barrier function", "input": "", "output": "Function: get_vertical_barrier\n\nGet vertical barrier timestamps.\n\nArgs:\n    timestamps: Full price bar timestamps\n    t_events: Event timestamps (when signals occur)\n    num_bars: Number of bars for vertical barrier\n\nReturns:\n    Series with vertical barrier timestamps", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "Explain the Apply Triple Barrier function", "input": "", "output": "Function: apply_triple_barrier\n\nApply triple barrier method.\n\nArgs:\n    close: Close price series\n    t_events: Event timestamps\n    pt_sl: Tuple of (profit_taking_mult, stop_loss_mult) relative to daily vol\n    vertical_barrier: Vertical barrier timestamps\n    min_return: Minimum return threshold\n\nReturns:\n    DataFrame with barrier touch information", "source": "core\\_experimental\\quant_formulas.py", "category": "volatility"}
{"instruction": "What is OFI in quantitative trading?", "input": "", "output": "OFI (Order Flow Imbalance).\n\nImplementation details:\nApply triple barrier method.\n\nArgs:\n    close: Close price series\n    t_events: Event timestamps\n    pt_sl: Tuple of (profit_taking_mult, stop_loss_mult) relative to daily vol\n    vertical_barrier: Vertical barrier timestamps\n    min_return: Minimum return threshold\n\nReturns:\n    DataFrame with barrier touch information", "source": "core\\_experimental\\quant_formulas.py", "category": "volatility"}
{"instruction": "What is the formula for Meta Labeling?", "input": "", "output": "Apply meta-labeling: filter primary model signals.\n\nThe meta-label is 1 if the primary signal would have been profitable,\n0 otherwise. This is used to train a secondary model that learns\nwhen to trust the primary model.\n\nArgs:\n    primary_signal: Primary model's directional signal (1, 0, -1)\n    triple_barrier_labels: Output from apply_triple_barrier\n\nReturns:\n    Meta-labels (1 = take the trade, 0 = skip)", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "Explain the Meta Labeling function", "input": "", "output": "Function: meta_labeling\n\nApply meta-labeling: filter primary model signals.\n\nThe meta-label is 1 if the primary signal would have been profitable,\n0 otherwise. This is used to train a secondary model that learns\nwhen to trust the primary model.\n\nArgs:\n    primary_signal: Primary model's directional signal (1, 0, -1)\n    triple_barrier_labels: Output from apply_triple_barrier\n\nReturns:\n    Meta-labels (1 = take the trade, 0 = skip)", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "What is OFI in quantitative trading?", "input": "", "output": "OFI (Order Flow Imbalance).\n\nImplementation details:\nApply meta-labeling: filter primary model signals.\n\nThe meta-label is 1 if the primary signal would have been profitable,\n0 otherwise. This is used to train a secondary model that learns\nwhen to trust the primary model.\n\nArgs:\n    primary_signal: Primary model's directional signal (1, 0, -1)\n    triple_barrier_labels: Output from apply_triple_barrier\n\nReturns:\n    Meta-labels (1 = take the trade, 0 = skip)", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "What is the formula for Get Weights?", "input": "", "output": "Calculate weights for fractional differentiation.\n\nw_k = -w_{k-1} * (d - k + 1) / k\n\nArgs:\n    d: Fractional differentiation order (0 to 1)\n    size: Number of weights to compute\n    threshold: Minimum weight to include\n\nReturns:\n    Array of weights", "source": "core\\_experimental\\quant_formulas.py", "category": "general"}
{"instruction": "Explain the Get Weights function", "input": "", "output": "Function: get_weights\n\nCalculate weights for fractional differentiation.\n\nw_k = -w_{k-1} * (d - k + 1) / k\n\nArgs:\n    d: Fractional differentiation order (0 to 1)\n    size: Number of weights to compute\n    threshold: Minimum weight to include\n\nReturns:\n    Array of weights", "source": "core\\_experimental\\quant_formulas.py", "category": "general"}
{"instruction": "Explain the Frac Diff function", "input": "", "output": "Function: frac_diff\n\nApply fractional differentiation to a series.\n\nArgs:\n    series: Price series\n    d: Fractional differentiation order\n    threshold: Minimum weight threshold\n\nReturns:\n    Fractionally differentiated series", "source": "core\\_experimental\\quant_formulas.py", "category": "general"}
{"instruction": "Explain the Get Optimal D function", "input": "", "output": "Function: get_optimal_d\n\nFind minimum d that achieves stationarity.\n\nArgs:\n    series: Price series\n    d_range: Range of d values to test\n    adf_threshold: ADF statistic threshold for stationarity\n\nReturns:\n    Optimal d value", "source": "core\\_experimental\\quant_formulas.py", "category": "general"}
{"instruction": "Explain the Optimal Trajectory function", "input": "", "output": "Function: optimal_trajectory\n\nCalculate optimal execution trajectory.\n\nArgs:\n    X: Total shares to execute\n    T: Total time horizon\n    n_steps: Number of trading intervals\n\nReturns:\n    Array of shares to trade at each step", "source": "core\\_experimental\\quant_formulas.py", "category": "execution"}
{"instruction": "Explain the Execution Cost function", "input": "", "output": "Function: execution_cost\n\nCalculate expected execution cost and variance.\n\nArgs:\n    X: Total shares to execute\n    T: Total time horizon\n    n_steps: Number of trading intervals\n\nReturns:\n    Dict with 'expected_cost' and 'cost_variance'", "source": "core\\_experimental\\quant_formulas.py", "category": "risk"}
{"instruction": "What is the formula for Twap Trajectory?", "input": "", "output": "Calculate TWAP (Time-Weighted Average Price) trajectory.\n\nTWAP corresponds to zero risk aversion (lambda = 0).\n\nArgs:\n    X: Total shares to execute\n    n_steps: Number of trading intervals\n\nReturns:\n    Array of uniform trades", "source": "core\\_experimental\\quant_formulas.py", "category": "risk"}
{"instruction": "Explain the Twap Trajectory function", "input": "", "output": "Function: twap_trajectory\n\nCalculate TWAP (Time-Weighted Average Price) trajectory.\n\nTWAP corresponds to zero risk aversion (lambda = 0).\n\nArgs:\n    X: Total shares to execute\n    n_steps: Number of trading intervals\n\nReturns:\n    Array of uniform trades", "source": "core\\_experimental\\quant_formulas.py", "category": "risk"}
{"instruction": "What is TWAP in quantitative trading?", "input": "", "output": "TWAP (Time-Weighted Average Price execution).\n\nImplementation details:\nCalculate TWAP (Time-Weighted Average Price) trajectory.\n\nTWAP corresponds to zero risk aversion (lambda = 0).\n\nArgs:\n    X: Total shares to execute\n    n_steps: Number of trading intervals\n\nReturns:\n    Array of uniform trades", "source": "core\\_experimental\\quant_formulas.py", "category": "risk"}
{"instruction": "What is the formula for Vwap Adjustment?", "input": "", "output": "Adjust trajectory to follow VWAP profile.\n\nArgs:\n    trades: Base trading trajectory\n    volume_profile: Expected volume at each interval (should sum to 1)\n\nReturns:\n    Volume-adjusted trades", "source": "core\\_experimental\\quant_formulas.py", "category": "volatility"}
{"instruction": "Explain the Vwap Adjustment function", "input": "", "output": "Function: vwap_adjustment\n\nAdjust trajectory to follow VWAP profile.\n\nArgs:\n    trades: Base trading trajectory\n    volume_profile: Expected volume at each interval (should sum to 1)\n\nReturns:\n    Volume-adjusted trades", "source": "core\\_experimental\\quant_formulas.py", "category": "volatility"}
{"instruction": "What is OFI in quantitative trading?", "input": "", "output": "OFI (Order Flow Imbalance).\n\nImplementation details:\nAdjust trajectory to follow VWAP profile.\n\nArgs:\n    trades: Base trading trajectory\n    volume_profile: Expected volume at each interval (should sum to 1)\n\nReturns:\n    Volume-adjusted trades", "source": "core\\_experimental\\quant_formulas.py", "category": "volatility"}
{"instruction": "What is VWAP in quantitative trading?", "input": "", "output": "VWAP (Volume-Weighted Average Price execution).\n\nImplementation details:\nAdjust trajectory to follow VWAP profile.\n\nArgs:\n    trades: Base trading trajectory\n    volume_profile: Expected volume at each interval (should sum to 1)\n\nReturns:\n    Volume-adjusted trades", "source": "core\\_experimental\\quant_formulas.py", "category": "volatility"}
{"instruction": "What is the formula for Heston Variance Path?", "input": "", "output": "Simulate Heston variance path.\n\ndv_t = kappa * (theta - v_t) * dt + sigma_v * sqrt(v_t) * dW_t\n\nArgs:\n    v0: Initial variance\n    kappa: Mean reversion speed\n    theta: Long-run variance\n    sigma_v: Vol of vol\n    T: Time horizon\n    n_steps: Number of steps\n    rng: Random number generator\n\nReturns:\n    Simulated variance path", "source": "core\\_experimental\\quant_formulas.py", "category": "volatility"}
{"instruction": "Explain the Heston Variance Path function", "input": "", "output": "Function: heston_variance_path\n\nSimulate Heston variance path.\n\ndv_t = kappa * (theta - v_t) * dt + sigma_v * sqrt(v_t) * dW_t\n\nArgs:\n    v0: Initial variance\n    kappa: Mean reversion speed\n    theta: Long-run variance\n    sigma_v: Vol of vol\n    T: Time horizon\n    n_steps: Number of steps\n    rng: Random number generator\n\nReturns:\n    Simulated variance path", "source": "core\\_experimental\\quant_formulas.py", "category": "volatility"}
{"instruction": "Explain the Sabr Implied Vol function", "input": "", "output": "Function: sabr_implied_vol\n\nSABR implied volatility approximation.\n\nArgs:\n    F: Forward price\n    K: Strike price\n    T: Time to expiry\n    alpha: Initial volatility\n    beta: CEV exponent (0 to 1)\n    rho: Correlation between price and vol\n    nu: Vol of vol\n\nReturns:\n    Implied volatility", "source": "core\\_experimental\\quant_formulas.py", "category": "alpha"}
{"instruction": "Explain the Estimate Heston Params function", "input": "", "output": "Function: estimate_heston_params\n\nEstimate Heston model parameters from data.\n\nUses method of moments estimation.\n\nArgs:\n    returns: Return series\n    vol: Realized volatility series\n\nReturns:\n    Dict with kappa, theta, sigma_v estimates", "source": "core\\_experimental\\quant_formulas.py", "category": "volatility"}
{"instruction": "Explain the purpose of Range-Based Volatility Estimators", "input": "", "output": "Range-Based Volatility Estimators\n==================================\nAcademic volatility estimators using OHLC data.\n\nSources (Gold Standard Citations):\n- Parkinson (1980): \"The Extreme Value Method for Estimating the Variance of the Rate of Return\"\n  Journal of Business, Vol. 53, No. 1, pp. 61-65\n\n- Garman & Klass (1980): \"On the Estimation of Security Price Volatilities from Historical Data\"\n  Journal of Business, Vol. 53, No. 1, pp. 67-78\n\n- Rogers & Satchell (1991): \"Estimating Variance from High, Low and Closing Prices\"\n  Annals of Applied Probability, Vol. 1, No. 4, pp. 504-512\n\n- Yang & Zhang (2000): \"Drift Independent Volatility Estimation Based on High, Low, Open, and Close Prices\"\n  Journal of Business, Vol. 73, No. 3, pp. 477-492\n\nAll estimators are more efficient than close-to-close realized variance.\nEfficiency gains: Parkinson ~5x, Garman-Klass ~7.4x, Yang-Zhang ~14x", "source": "core\\_experimental\\range_volatility.py", "category": "volatility"}
{"instruction": "What is the VolatilityEstimate class and how do I use it?", "input": "", "output": "The VolatilityEstimate class:\n\nContainer for volatility estimate with metadata.", "source": "core\\_experimental\\range_volatility.py", "category": "volatility"}
{"instruction": "What is the RangeVolatility class and how do I use it?", "input": "", "output": "The RangeVolatility class:\n\nRange-Based Volatility Estimators\n\nAll estimators use OHLC data for more efficient volatility estimation\ncompared to close-to-close squared returns.\n\nUsage:\n    rv = RangeVolatility(annualize=True, trading_periods=252)\n    vol = rv.yang_zhang(open_, high, low, close)", "source": "core\\_experimental\\range_volatility.py", "category": "volatility"}
{"instruction": "Show me a code example for RangeVolatility", "input": "", "output": "rv = RangeVolatility(annualize=True, trading_periods=252)\n    vol = rv.yang_zhang(open_, high, low, close)", "source": "core\\_experimental\\range_volatility.py", "category": "volatility"}
{"instruction": "What is the GarmanKlassYangZhang class and how do I use it?", "input": "", "output": "The GarmanKlassYangZhang class:\n\nCombined Garman-Klass-Yang-Zhang estimator (GKYZ).\n\nHybrid approach combining the best properties of both estimators.\nUsed by some institutional traders.", "source": "core\\_experimental\\range_volatility.py", "category": "general"}
{"instruction": "Explain the Create Range Volatility function", "input": "", "output": "Function: create_range_volatility\n\nFactory function to create range volatility calculator.", "source": "core\\_experimental\\range_volatility.py", "category": "alpha"}
{"instruction": "Explain the Parkinson Vol function", "input": "", "output": "Function: parkinson_vol\n\nQuick Parkinson volatility.", "source": "core\\_experimental\\range_volatility.py", "category": "volatility"}
{"instruction": "What is the formula for Garman Klass Vol?", "input": "", "output": "Quick Garman-Klass volatility.", "source": "core\\_experimental\\range_volatility.py", "category": "volatility"}
{"instruction": "Explain the Garman Klass Vol function", "input": "", "output": "Function: garman_klass_vol\n\nQuick Garman-Klass volatility.", "source": "core\\_experimental\\range_volatility.py", "category": "volatility"}
{"instruction": "What is the formula for Rogers Satchell Vol?", "input": "", "output": "Quick Rogers-Satchell volatility.", "source": "core\\_experimental\\range_volatility.py", "category": "volatility"}
{"instruction": "Explain the Rogers Satchell Vol function", "input": "", "output": "Function: rogers_satchell_vol\n\nQuick Rogers-Satchell volatility.", "source": "core\\_experimental\\range_volatility.py", "category": "volatility"}
{"instruction": "What is the formula for Yang Zhang Vol?", "input": "", "output": "Quick Yang-Zhang volatility.", "source": "core\\_experimental\\range_volatility.py", "category": "volatility"}
{"instruction": "Explain the Yang Zhang Vol function", "input": "", "output": "Function: yang_zhang_vol\n\nQuick Yang-Zhang volatility.", "source": "core\\_experimental\\range_volatility.py", "category": "volatility"}
{"instruction": "What is the formula for Parkinson?", "input": "", "output": "Parkinson (1980) volatility estimator.\n\nUses high-low range only. ~5x more efficient than close-to-close.\n\nFormula:\n    σ² = (1 / 4*ln(2)) * E[(ln(H/L))²]\n\nReference:\n    Parkinson, M. (1980). \"The Extreme Value Method for Estimating\n    the Variance of the Rate of Return\". Journal of Business, 53(1), 61-65.\n\nArgs:\n    high: High prices\n    low: Low prices\n    window: Rolling window size\n\nReturns:\n    Parkinson volatility series", "source": "core\\_experimental\\range_volatility.py", "category": "volatility"}
{"instruction": "Explain the Parkinson function", "input": "", "output": "Function: parkinson\n\nParkinson (1980) volatility estimator.\n\nUses high-low range only. ~5x more efficient than close-to-close.\n\nFormula:\n    σ² = (1 / 4*ln(2)) * E[(ln(H/L))²]\n\nReference:\n    Parkinson, M. (1980). \"The Extreme Value Method for Estimating\n    the Variance of the Rate of Return\". Journal of Business, 53(1), 61-65.\n\nArgs:\n    high: High prices\n    low: Low prices\n    window: Rolling window size\n\nReturns:\n    Parkinson volatility series", "source": "core\\_experimental\\range_volatility.py", "category": "volatility"}
{"instruction": "What is the formula for Parkinson Single?", "input": "", "output": "Single-period Parkinson volatility.", "source": "core\\_experimental\\range_volatility.py", "category": "volatility"}
{"instruction": "Explain the Parkinson Single function", "input": "", "output": "Function: parkinson_single\n\nSingle-period Parkinson volatility.", "source": "core\\_experimental\\range_volatility.py", "category": "volatility"}
{"instruction": "What is the formula for Garman Klass?", "input": "", "output": "Garman-Klass (1980) volatility estimator.\n\nUses OHLC data. ~7.4x more efficient than close-to-close.\nAssumes no drift (zero mean return).\n\nFormula:\n    σ² = 0.5 * (ln(H/L))² - (2*ln(2) - 1) * (ln(C/O))²\n\nReference:\n    Garman, M. B., & Klass, M. J. (1980). \"On the Estimation of Security\n    Price Volatilities from Historical Data\". Journal of Business, 53(1), 67-78.\n\nArgs:\n    open_: Open prices\n    high: High prices\n    low: Low prices\n    close: Close prices\n    window: Rolling window size\n\nReturns:\n    Garman-Klass volatility series", "source": "core\\_experimental\\range_volatility.py", "category": "volatility"}
{"instruction": "Explain the Garman Klass function", "input": "", "output": "Function: garman_klass\n\nGarman-Klass (1980) volatility estimator.\n\nUses OHLC data. ~7.4x more efficient than close-to-close.\nAssumes no drift (zero mean return).\n\nFormula:\n    σ² = 0.5 * (ln(H/L))² - (2*ln(2) - 1) * (ln(C/O))²\n\nReference:\n    Garman, M. B., & Klass, M. J. (1980). \"On the Estimation of Security\n    Price Volatilities from Historical Data\". Journal of Business, 53(1), 67-78.\n\nArgs:\n    open_: Open prices\n    high: High prices\n    low: Low prices\n    close: Close prices\n    window: Rolling window size\n\nReturns:\n    Garman-Klass volatility series", "source": "core\\_experimental\\range_volatility.py", "category": "volatility"}
{"instruction": "What is the formula for Garman Klass Single?", "input": "", "output": "Single-period Garman-Klass volatility.", "source": "core\\_experimental\\range_volatility.py", "category": "volatility"}
{"instruction": "Explain the Garman Klass Single function", "input": "", "output": "Function: garman_klass_single\n\nSingle-period Garman-Klass volatility.", "source": "core\\_experimental\\range_volatility.py", "category": "volatility"}
{"instruction": "What is the formula for Rogers Satchell?", "input": "", "output": "Rogers-Satchell (1991) volatility estimator.\n\nDrift-independent estimator using OHLC. Unbiased even with non-zero drift.\n\nFormula:\n    σ² = ln(H/C) * ln(H/O) + ln(L/C) * ln(L/O)\n\nReference:\n    Rogers, L. C. G., & Satchell, S. E. (1991). \"Estimating Variance from\n    High, Low and Closing Prices\". Annals of Applied Probability, 1(4), 504-512.\n\nArgs:\n    open_: Open prices\n    high: High prices\n    low: Low prices\n    close: Close prices\n    window: Rolling window size\n\nReturns:\n    Rogers-Satchell volatility series", "source": "core\\_experimental\\range_volatility.py", "category": "volatility"}
{"instruction": "Explain the Rogers Satchell function", "input": "", "output": "Function: rogers_satchell\n\nRogers-Satchell (1991) volatility estimator.\n\nDrift-independent estimator using OHLC. Unbiased even with non-zero drift.\n\nFormula:\n    σ² = ln(H/C) * ln(H/O) + ln(L/C) * ln(L/O)\n\nReference:\n    Rogers, L. C. G., & Satchell, S. E. (1991). \"Estimating Variance from\n    High, Low and Closing Prices\". Annals of Applied Probability, 1(4), 504-512.\n\nArgs:\n    open_: Open prices\n    high: High prices\n    low: Low prices\n    close: Close prices\n    window: Rolling window size\n\nReturns:\n    Rogers-Satchell volatility series", "source": "core\\_experimental\\range_volatility.py", "category": "volatility"}
{"instruction": "What is the formula for Rogers Satchell Single?", "input": "", "output": "Single-period Rogers-Satchell volatility.", "source": "core\\_experimental\\range_volatility.py", "category": "volatility"}
{"instruction": "Explain the Rogers Satchell Single function", "input": "", "output": "Function: rogers_satchell_single\n\nSingle-period Rogers-Satchell volatility.", "source": "core\\_experimental\\range_volatility.py", "category": "volatility"}
{"instruction": "What is the formula for Yang Zhang?", "input": "", "output": "Yang-Zhang (2000) volatility estimator.\n\nMost efficient estimator (~14x vs close-to-close).\nHandles overnight jumps (open != previous close).\nCombines overnight, open-to-close, and Rogers-Satchell components.\n\nFormula:\n    σ² = σ²_overnight + k*σ²_open_close + (1-k)*σ²_RS\n\nwhere k = 0.34 is optimal for α = 1.34 (market open/close timing)\n\nReference:\n    Yang, D., & Zhang, Q. (2000). \"Drift Independent Volatility Estimation\n    Based on High, Low, Open, and Close Prices\". Journal of Business, 73(3), 477-492.\n\nArgs:\n    open_: Open prices\n    high: High prices\n    low: Low prices\n    close: Close prices\n    window: Rolling window size\n    k: Weighting parameter (default 0.34 is optimal)\n\nReturns:\n    Yang-Zhang volatility series", "source": "core\\_experimental\\range_volatility.py", "category": "volatility"}
{"instruction": "Explain the Yang Zhang function", "input": "", "output": "Function: yang_zhang\n\nYang-Zhang (2000) volatility estimator.\n\nMost efficient estimator (~14x vs close-to-close).\nHandles overnight jumps (open != previous close).\nCombines overnight, open-to-close, and Rogers-Satchell components.\n\nFormula:\n    σ² = σ²_overnight + k*σ²_open_close + (1-k)*σ²_RS\n\nwhere k = 0.34 is optimal for α = 1.34 (market open/close timing)\n\nReference:\n    Yang, D., & Zhang, Q. (2000). \"Drift Independent Volatility Estimation\n    Based on High, Low, Open, and Close Prices\". Journal of Business, 73(3), 477-492.\n\nArgs:\n    open_: Open prices\n    high: High prices\n    low: Low prices\n    close: Close prices\n    window: Rolling window size\n    k: Weighting parameter (default 0.34 is optimal)\n\nReturns:\n    Yang-Zhang volatility series", "source": "core\\_experimental\\range_volatility.py", "category": "volatility"}
{"instruction": "What is the formula for Yang Zhang Single?", "input": "", "output": "Single-period Yang-Zhang volatility (requires previous close).", "source": "core\\_experimental\\range_volatility.py", "category": "volatility"}
{"instruction": "Explain the Yang Zhang Single function", "input": "", "output": "Function: yang_zhang_single\n\nSingle-period Yang-Zhang volatility (requires previous close).", "source": "core\\_experimental\\range_volatility.py", "category": "volatility"}
{"instruction": "What is the formula for Close To Close?", "input": "", "output": "Standard close-to-close volatility (baseline for comparison).\n\nFormula:\n    σ = std(ln(C_t / C_{t-1}))\n\nArgs:\n    close: Close prices\n    window: Rolling window size\n\nReturns:\n    Close-to-close volatility series", "source": "core\\_experimental\\range_volatility.py", "category": "volatility"}
{"instruction": "Explain the Close To Close function", "input": "", "output": "Function: close_to_close\n\nStandard close-to-close volatility (baseline for comparison).\n\nFormula:\n    σ = std(ln(C_t / C_{t-1}))\n\nArgs:\n    close: Close prices\n    window: Rolling window size\n\nReturns:\n    Close-to-close volatility series", "source": "core\\_experimental\\range_volatility.py", "category": "volatility"}
{"instruction": "What is the formula for Ensemble?", "input": "", "output": "Ensemble of all volatility estimators.\n\nCombines multiple estimators for robust volatility estimation.\n\nArgs:\n    open_: Open prices\n    high: High prices\n    low: Low prices\n    close: Close prices\n    window: Rolling window size\n    weights: Dict of estimator weights (default: efficiency-weighted)\n\nReturns:\n    Ensemble volatility series", "source": "core\\_experimental\\range_volatility.py", "category": "volatility"}
{"instruction": "Explain the Ensemble function", "input": "", "output": "Function: ensemble\n\nEnsemble of all volatility estimators.\n\nCombines multiple estimators for robust volatility estimation.\n\nArgs:\n    open_: Open prices\n    high: High prices\n    low: Low prices\n    close: Close prices\n    window: Rolling window size\n    weights: Dict of estimator weights (default: efficiency-weighted)\n\nReturns:\n    Ensemble volatility series", "source": "core\\_experimental\\range_volatility.py", "category": "volatility"}
{"instruction": "Explain the Compute All Features function", "input": "", "output": "Function: compute_all_features\n\nCompute all volatility features for ML.\n\nReturns DataFrame with volatility features at multiple windows.", "source": "core\\_experimental\\range_volatility.py", "category": "volatility"}
{"instruction": "What is the formula for Volatility Regime?", "input": "", "output": "Classify volatility regime: low, normal, high.\n\nUses Yang-Zhang (most efficient estimator).\n\nReturns:\n    Series with regime labels", "source": "core\\_experimental\\range_volatility.py", "category": "volatility"}
{"instruction": "Explain the Volatility Regime function", "input": "", "output": "Function: volatility_regime\n\nClassify volatility regime: low, normal, high.\n\nUses Yang-Zhang (most efficient estimator).\n\nReturns:\n    Series with regime labels", "source": "core\\_experimental\\range_volatility.py", "category": "volatility"}
{"instruction": "What is the formula for Volatility Breakout?", "input": "", "output": "Detect volatility breakouts (spikes above threshold).\n\nReturns:\n    Boolean series (True = breakout)", "source": "core\\_experimental\\range_volatility.py", "category": "volatility"}
{"instruction": "Explain the Volatility Breakout function", "input": "", "output": "Function: volatility_breakout\n\nDetect volatility breakouts (spikes above threshold).\n\nReturns:\n    Boolean series (True = breakout)", "source": "core\\_experimental\\range_volatility.py", "category": "volatility"}
{"instruction": "What is the formula for Estimate?", "input": "", "output": "GKYZ estimator: average of Garman-Klass and Yang-Zhang.", "source": "core\\_experimental\\range_volatility.py", "category": "general"}
{"instruction": "Explain the Estimate function", "input": "", "output": "Function: estimate\n\nGKYZ estimator: average of Garman-Klass and Yang-Zhang.", "source": "core\\_experimental\\range_volatility.py", "category": "general"}
{"instruction": "Explain the purpose of Regime-Dependent Features for HFT Forex", "input": "", "output": "Regime-Dependent Features for HFT Forex\n=======================================\nRenaissance Technologies core insight: Different market regimes\nrequire different strategies. Features should be regime-aware.\n\nKey Concept:\n- Low volatility: Mean-reversion dominates, use tighter signals\n- Normal volatility: Balance trend-following and mean-reversion\n- High volatility: Trend-following works, widen stops\n\nImplemented Methods:\n- HMM Regime Detection (3-state: low, normal, high vol)\n- Regime-Scaled Features (adjust signals by regime)\n- Regime Transition Probabilities\n- Regime-Dependent Kelly Criterion\n- Multi-Regime Ensemble\n\nSources:\n- Hamilton (1989) \"A New Approach to the Economic Analysis of Nonstationary Time Series\"\n- Hamilton (1990) \"Analysis of Time Series Subject to Changes in Regime\"\n- Guidolin & Timmermann (2007) \"Asset Allocation Under Multivariate Regime Switching\"\n\nWhy Renaissance Uses This:\n- Regime detection from speech recognition (Baum-Welch for HMM)\n- Different strategies for different market conditions\n- Position sizing based on regime\n- Avoid trading during regime transitions", "source": "core\\_experimental\\regime_features.py", "category": "alpha"}
{"instruction": "What is the RegimeState class and how do I use it?", "input": "", "output": "The RegimeState class:\n\nCurrent regime state.", "source": "core\\_experimental\\regime_features.py", "category": "regime"}
{"instruction": "What is the RegimeConfig class and how do I use it?", "input": "", "output": "The RegimeConfig class:\n\nConfiguration for regime-dependent trading.", "source": "core\\_experimental\\regime_features.py", "category": "regime"}
{"instruction": "What is the SimpleHMMRegime class and how do I use it?", "input": "", "output": "The SimpleHMMRegime class:\n\nSimple HMM for regime detection.\n\n3 states: Low vol (0), Normal vol (1), High vol (2)\n\nUses Gaussian emissions with different means and variances per state.\nViterbi algorithm for state sequence.\n\nRenaissance Application:\n- Speech recognition experts (Mercer, Brown) brought HMM expertise\n- Baum-Welch algorithm fits model to data\n- Regime = hidden state, Returns = observed emissions", "source": "core\\_experimental\\regime_features.py", "category": "volatility"}
{"instruction": "What is the RegimeFeatureScaler class and how do I use it?", "input": "", "output": "The RegimeFeatureScaler class:\n\nScale features based on current regime.\n\nDifferent regimes have different feature distributions.\nNormalizing within regime improves model accuracy.\n\nRenaissance Application:\n- Features computed relative to regime statistics\n- Avoids spurious signals from regime transitions\n- More stable feature distributions per regime", "source": "core\\_experimental\\regime_features.py", "category": "alpha"}
{"instruction": "What is the RegimeAwarePositionSizer class and how do I use it?", "input": "", "output": "The RegimeAwarePositionSizer class:\n\nAdjust position sizes based on regime.\n\nLow vol: Can take larger positions (lower risk)\nHigh vol: Reduce positions (higher risk)\n\nImplements Regime-Dependent Kelly Criterion.", "source": "core\\_experimental\\regime_features.py", "category": "volatility"}
{"instruction": "What is the RegimeDependentFeatureEngine class and how do I use it?", "input": "", "output": "The RegimeDependentFeatureEngine class:\n\nComplete regime-dependent feature generation.\n\nCombines:\n1. HMM regime detection\n2. Per-regime feature scaling\n3. Regime transition features\n4. Strategy weight suggestions", "source": "core\\_experimental\\regime_features.py", "category": "regime"}
{"instruction": "Explain the Compute Regime Features function", "input": "", "output": "Function: compute_regime_features\n\nConvenience function for regime feature computation.", "source": "core\\_experimental\\regime_features.py", "category": "regime"}
{"instruction": "What is the formula for Get Regime Adjusted Position?", "input": "", "output": "Get regime-adjusted position size.\n\nArgs:\n    signal: Trading signal (-1 to 1)\n    confidence: Model confidence (0 to 1)\n    regime: Current regime (0=low, 1=normal, 2=high)\n    base_size: Base position size as fraction of capital\n\nReturns:\n    Adjusted position size", "source": "core\\_experimental\\regime_features.py", "category": "alpha"}
{"instruction": "Explain the Get Regime Adjusted Position function", "input": "", "output": "Function: get_regime_adjusted_position\n\nGet regime-adjusted position size.\n\nArgs:\n    signal: Trading signal (-1 to 1)\n    confidence: Model confidence (0 to 1)\n    regime: Current regime (0=low, 1=normal, 2=high)\n    base_size: Base position size as fraction of capital\n\nReturns:\n    Adjusted position size", "source": "core\\_experimental\\regime_features.py", "category": "alpha"}
{"instruction": "Explain the Emission Prob function", "input": "", "output": "Function: emission_prob\n\nProbability of observing x given state.", "source": "core\\_experimental\\regime_features.py", "category": "regime"}
{"instruction": "What is the formula for Fit?", "input": "", "output": "Fit HMM using Baum-Welch algorithm.\n\nThis is the key algorithm Renaissance uses - same as speech recognition.", "source": "core\\_experimental\\regime_features.py", "category": "regime"}
{"instruction": "Explain the Fit function", "input": "", "output": "Function: fit\n\nFit HMM using Baum-Welch algorithm.\n\nThis is the key algorithm Renaissance uses - same as speech recognition.", "source": "core\\_experimental\\regime_features.py", "category": "regime"}
{"instruction": "What is HMM in quantitative trading?", "input": "", "output": "HMM (Hidden Markov Model for regime detection).\n\nImplementation details:\nFit HMM using Baum-Welch algorithm.\n\nThis is the key algorithm Renaissance uses - same as speech recognition.", "source": "core\\_experimental\\regime_features.py", "category": "regime"}
{"instruction": "Explain the Predict Regime function", "input": "", "output": "Function: predict_regime\n\nPredict most likely regime sequence (Viterbi).", "source": "core\\_experimental\\regime_features.py", "category": "regime"}
{"instruction": "Explain the Get Regime Probabilities function", "input": "", "output": "Function: get_regime_probabilities\n\nGet probability of each regime at each time.", "source": "core\\_experimental\\regime_features.py", "category": "regime"}
{"instruction": "What is the formula for Fit?", "input": "", "output": "Compute per-regime statistics for each feature.", "source": "core\\_experimental\\regime_features.py", "category": "regime"}
{"instruction": "Explain the Fit function", "input": "", "output": "Function: fit\n\nCompute per-regime statistics for each feature.", "source": "core\\_experimental\\regime_features.py", "category": "regime"}
{"instruction": "What is the formula for Transform?", "input": "", "output": "Transform features to regime-normalized values.", "source": "core\\_experimental\\regime_features.py", "category": "regime"}
{"instruction": "Explain the Transform function", "input": "", "output": "Function: transform\n\nTransform features to regime-normalized values.", "source": "core\\_experimental\\regime_features.py", "category": "regime"}
{"instruction": "Explain the Get Position Multiplier function", "input": "", "output": "Function: get_position_multiplier\n\nGet position size multiplier for regime.", "source": "core\\_experimental\\regime_features.py", "category": "regime"}
{"instruction": "Explain the Get Stop Multiplier function", "input": "", "output": "Function: get_stop_multiplier\n\nGet stop loss multiplier for regime.", "source": "core\\_experimental\\regime_features.py", "category": "regime"}
{"instruction": "What is the formula for Regime Adjusted Kelly?", "input": "", "output": "Compute regime-adjusted Kelly fraction.\n\nKelly = p - (1-p)/b where p = win_prob, b = win_loss_ratio\n\nThen multiply by regime adjustment and base fraction.", "source": "core\\_experimental\\regime_features.py", "category": "risk"}
{"instruction": "Explain the Regime Adjusted Kelly function", "input": "", "output": "Function: regime_adjusted_kelly\n\nCompute regime-adjusted Kelly fraction.\n\nKelly = p - (1-p)/b where p = win_prob, b = win_loss_ratio\n\nThen multiply by regime adjustment and base fraction.", "source": "core\\_experimental\\regime_features.py", "category": "risk"}
{"instruction": "What is Kelly Criterion in quantitative trading?", "input": "", "output": "Kelly Criterion (position sizing formula that maximizes long-term growth).\n\nImplementation details:\nCompute regime-adjusted Kelly fraction.\n\nKelly = p - (1-p)/b where p = win_prob, b = win_loss_ratio\n\nThen multiply by regime adjustment and base fraction.", "source": "core\\_experimental\\regime_features.py", "category": "risk"}
{"instruction": "Explain the Fit function", "input": "", "output": "Function: fit\n\nFit regime model.", "source": "core\\_experimental\\regime_features.py", "category": "regime"}
{"instruction": "Explain the Detect Regime function", "input": "", "output": "Function: detect_regime\n\nDetect current regime.", "source": "core\\_experimental\\regime_features.py", "category": "regime"}
{"instruction": "What is the formula for Compute Features?", "input": "", "output": "Compute regime-dependent features.\n\nReturns DataFrame with:\n- Regime indicators\n- Regime probabilities\n- Transition probabilities\n- Regime-scaled base features (if provided)\n- Strategy weights\n- Position multipliers", "source": "core\\_experimental\\regime_features.py", "category": "regime"}
{"instruction": "Explain the Compute Features function", "input": "", "output": "Function: compute_features\n\nCompute regime-dependent features.\n\nReturns DataFrame with:\n- Regime indicators\n- Regime probabilities\n- Transition probabilities\n- Regime-scaled base features (if provided)\n- Strategy weights\n- Position multipliers", "source": "core\\_experimental\\regime_features.py", "category": "regime"}
{"instruction": "Explain the purpose of Renaissance HFT Engine - Master Coordinator", "input": "", "output": "Renaissance HFT Engine - Master Coordinator\n============================================\n\nIntegrates ALL existing modules for 66%+ win rate:\n- InstitutionalPredictor (HMM + Kalman)\n- OrderFlowFeatures (OFI, OEI, VPIN)\n- RenaissanceSignalGenerator (50+ weak signals)\n- HFTFeatureEngine (500+ features)\n- UltraSelectiveFilter (4-layer filter)\n- KellyCriterion (position sizing)\n\nThis engine uses EXISTING code - no reinvention.", "source": "core\\_experimental\\renaissance_hft_engine.py", "category": "alpha"}
{"instruction": "What is the TradeSignal class and how do I use it?", "input": "", "output": "The TradeSignal class:\n\nComplete trade signal with all details.", "source": "core\\_experimental\\renaissance_hft_engine.py", "category": "alpha"}
{"instruction": "What is the RenaissanceHFTEngine class and how do I use it?", "input": "", "output": "The RenaissanceHFTEngine class:\n\nMaster Coordinator for Renaissance-Level Trading\n\nIntegrates:\n1. InstitutionalPredictor - HMM regime + Kalman mean reversion\n2. OrderFlowFeatures - OFI/OEI/VPIN for flow confirmation\n3. Ensemble Models - XGBoost/LightGBM/CatBoost\n4. UltraSelectiveFilter - 4-layer filter for 66%+\n5. KellyCriterion - Position sizing", "source": "core\\_experimental\\renaissance_hft_engine.py", "category": "risk"}
{"instruction": "Explain the Create Renaissance Engine function", "input": "", "output": "Function: create_renaissance_engine\n\nFactory function to create Renaissance HFT Engine.\n\nArgs:\n    models_dir: Base directory for models\n\nReturns:\n    Configured RenaissanceHFTEngine", "source": "core\\_experimental\\renaissance_hft_engine.py", "category": "alpha"}
{"instruction": "Explain the Update Tick function", "input": "", "output": "Function: update_tick\n\nUpdate with new tick data.\n\nArgs:\n    symbol: Currency pair\n    bid: Best bid price\n    ask: Best ask price\n    bid_size: Quantity at bid\n    ask_size: Quantity at ask\n    timestamp: Tick timestamp", "source": "core\\_experimental\\renaissance_hft_engine.py", "category": "microstructure"}
{"instruction": "Explain the Update Trade function", "input": "", "output": "Function: update_trade\n\nUpdate with trade data.\n\nArgs:\n    price: Trade price\n    size: Trade size\n    side: 'buy' or 'sell'\n    timestamp: Trade timestamp", "source": "core\\_experimental\\renaissance_hft_engine.py", "category": "general"}
{"instruction": "Explain the Get Signal function", "input": "", "output": "Function: get_signal\n\nGenerate trading signal using all components.\n\nArgs:\n    symbol: Currency pair (e.g., 'EURUSD')\n    features: Feature array for model prediction\n    data: Historical data DataFrame (for regime detection)\n\nReturns:\n    TradeSignal with complete analysis", "source": "core\\_experimental\\renaissance_hft_engine.py", "category": "alpha"}
{"instruction": "What is the formula for Update State?", "input": "", "output": "Update engine state after trade.\n\nArgs:\n    pnl: Profit/loss from trade", "source": "core\\_experimental\\renaissance_hft_engine.py", "category": "regime"}
{"instruction": "Explain the Update State function", "input": "", "output": "Function: update_state\n\nUpdate engine state after trade.\n\nArgs:\n    pnl: Profit/loss from trade", "source": "core\\_experimental\\renaissance_hft_engine.py", "category": "regime"}
{"instruction": "What is OFI in quantitative trading?", "input": "", "output": "OFI (Order Flow Imbalance).\n\nImplementation details:\nUpdate engine state after trade.\n\nArgs:\n    pnl: Profit/loss from trade", "source": "core\\_experimental\\renaissance_hft_engine.py", "category": "regime"}
{"instruction": "Explain the Reset Daily function", "input": "", "output": "Function: reset_daily\n\nReset daily counters.", "source": "core\\_experimental\\renaissance_hft_engine.py", "category": "general"}
{"instruction": "Explain the Get Status function", "input": "", "output": "Function: get_status\n\nGet engine status.", "source": "core\\_experimental\\renaissance_hft_engine.py", "category": "general"}
{"instruction": "What is the source paper for this technique?", "input": "", "output": "The source is: ProsusAI/finBERT, ahmedrachid/FinancialBERT-Sentiment-Analysis. ", "source": "core\\_experimental\\sentiment_finbert.py", "category": "execution"}
{"instruction": "Explain the purpose of FinBERT Sentiment Analysis for Forex Trading", "input": "", "output": "FinBERT Sentiment Analysis for Forex Trading\n=============================================\nSource: ProsusAI/finBERT, ahmedrachid/FinancialBERT-Sentiment-Analysis\n\nPre-trained BERT fine-tuned on financial text.\nClassifies text as: Bullish, Neutral, Bearish\n\nUsage for HFT:\n1. Monitor real-time news feeds\n2. Run FinBERT on headlines 50ms before price impact\n3. Pre-position before market reaction\n4. Mean reversion after overreaction\n\nStudies show: 24.06 bps average return per news trade (18-year OOS)", "source": "core\\_experimental\\sentiment_finbert.py", "category": "execution"}
{"instruction": "What is the SentimentResult class and how do I use it?", "input": "", "output": "The SentimentResult class:\n\nSentiment analysis result.", "source": "core\\_experimental\\sentiment_finbert.py", "category": "general"}
{"instruction": "What is the FinBERTSentiment class and how do I use it?", "input": "", "output": "The FinBERTSentiment class:\n\nFinBERT-based sentiment analysis for financial text.\n\nModels available:\n- ProsusAI/finbert (original)\n- ahmedrachid/FinancialBERT-Sentiment-Analysis", "source": "core\\_experimental\\sentiment_finbert.py", "category": "general"}
{"instruction": "What is the ForexNewsSentiment class and how do I use it?", "input": "", "output": "The ForexNewsSentiment class:\n\nForex-specific news sentiment analyzer.\n\nCurrency-specific keyword mappings:\n- \"Fed hawkish\" -> USD bullish\n- \"ECB dovish\" -> EUR bearish\n- \"Risk-on\" -> AUD, NZD bullish; JPY, CHF bearish", "source": "core\\_experimental\\sentiment_finbert.py", "category": "risk"}
{"instruction": "What is the NewsTradingSignal class and how do I use it?", "input": "", "output": "The NewsTradingSignal class:\n\nGenerate trading signals from news events.\n\nStrategy:\n1. Monitor news feeds (Forex Factory, Bloomberg, Reuters)\n2. Analyze sentiment in real-time\n3. Generate entry signal if |sentiment| > threshold\n4. Exit on mean reversion or time-based stop", "source": "core\\_experimental\\sentiment_finbert.py", "category": "alpha"}
{"instruction": "Explain the Compute Sentiment Features function", "input": "", "output": "Function: compute_sentiment_features\n\nCompute sentiment features from news headlines.\n\nArgs:\n    headlines: List of (timestamp, headline) tuples\n    pair: Currency pair\n\nReturns:\n    DataFrame with sentiment features", "source": "core\\_experimental\\sentiment_finbert.py", "category": "general"}
{"instruction": "Explain the Analyze function", "input": "", "output": "Function: analyze\n\nAnalyze sentiment of text.\n\nArgs:\n    text: Financial text (headline, news, tweet)\n\nReturns:\n    SentimentResult with probabilities", "source": "core\\_experimental\\sentiment_finbert.py", "category": "general"}
{"instruction": "Explain the Analyze Batch function", "input": "", "output": "Function: analyze_batch\n\nAnalyze multiple texts efficiently.", "source": "core\\_experimental\\sentiment_finbert.py", "category": "general"}
{"instruction": "What is the formula for Analyze For Pair?", "input": "", "output": "Analyze news sentiment for specific currency pair.\n\nArgs:\n    text: News text\n    pair: Currency pair (e.g., 'EURUSD')\n\nReturns:\n    Dict with signal strength (-1 to 1) and confidence", "source": "core\\_experimental\\sentiment_finbert.py", "category": "alpha"}
{"instruction": "Explain the Analyze For Pair function", "input": "", "output": "Function: analyze_for_pair\n\nAnalyze news sentiment for specific currency pair.\n\nArgs:\n    text: News text\n    pair: Currency pair (e.g., 'EURUSD')\n\nReturns:\n    Dict with signal strength (-1 to 1) and confidence", "source": "core\\_experimental\\sentiment_finbert.py", "category": "alpha"}
{"instruction": "Explain the Process News function", "input": "", "output": "Function: process_news\n\nProcess incoming news and generate signal.\n\nArgs:\n    timestamp: News timestamp\n    headline: News headline\n    pair: Currency pair to trade\n\nReturns:\n    Trading signal dict or None", "source": "core\\_experimental\\sentiment_finbert.py", "category": "alpha"}
{"instruction": "Explain the Get Active Signals function", "input": "", "output": "Function: get_active_signals\n\nGet all active news signals (not yet expired).", "source": "core\\_experimental\\sentiment_finbert.py", "category": "alpha"}
{"instruction": "Explain the purpose of Spectral and Wavelet Analysis for HFT Forex", "input": "", "output": "Spectral and Wavelet Analysis for HFT Forex\n============================================\nRenaissance Technologies inference: Signal processing experts use\nfrequency domain analysis to identify market cycles and filter noise.\n\nImplemented Methods:\n- FFT Power Spectrum: Identify dominant frequencies\n- Welch's Method: Robust spectral estimation\n- Discrete Wavelet Transform (DWT): Multi-scale decomposition\n- Continuous Wavelet Transform (CWT): Time-frequency analysis\n- Hilbert Transform: Instantaneous phase/frequency\n\nSources:\n- Oppenheim & Schafer \"Discrete-Time Signal Processing\"\n- Mallat (1989) \"A Theory for Multiresolution Signal Decomposition\"\n- Daubechies (1992) \"Ten Lectures on Wavelets\"\n- Ramsey & Lampart (1998) \"The Decomposition of Economic Relationships by Time Scale\"\n\nWhy Renaissance Uses This:\n- Identify dominant market cycles (intraday, weekly, monthly)\n- Filter noise from signal at different frequencies\n- Detect phase shifts in correlations\n- Multi-scale trend following", "source": "core\\_experimental\\spectral_analysis.py", "category": "alpha"}
{"instruction": "What is the SpectralResult class and how do I use it?", "input": "", "output": "The SpectralResult class:\n\nResult from spectral analysis.", "source": "core\\_experimental\\spectral_analysis.py", "category": "general"}
{"instruction": "What is the WaveletResult class and how do I use it?", "input": "", "output": "The WaveletResult class:\n\nResult from wavelet decomposition.", "source": "core\\_experimental\\spectral_analysis.py", "category": "general"}
{"instruction": "What is the SpectralAnalyzer class and how do I use it?", "input": "", "output": "The SpectralAnalyzer class:\n\nFourier-based spectral analysis for cycle detection.\n\nDecomposes price series into frequency components to identify:\n- Dominant cycles (intraday, weekly, etc.)\n- Noise level (high frequency)\n- Trend component (low frequency)\n\nRenaissance Application:\n- Identify profitable trading frequencies\n- Filter out noise\n- Time entries to cycle phases", "source": "core\\_experimental\\spectral_analysis.py", "category": "general"}
{"instruction": "What is the WaveletDecomposer class and how do I use it?", "input": "", "output": "The WaveletDecomposer class:\n\nWavelet decomposition for multi-scale analysis.\n\nAdvantages over Fourier:\n- Localized in both time and frequency\n- Better for non-stationary signals\n- Captures transient events\n\nRenaissance Application:\n- Separate long-term trend from short-term noise\n- Detect regime changes at multiple timescales\n- Multi-resolution trading signals", "source": "core\\_experimental\\spectral_analysis.py", "category": "alpha"}
{"instruction": "What is the ContinuousWaveletTransform class and how do I use it?", "input": "", "output": "The ContinuousWaveletTransform class:\n\nContinuous Wavelet Transform for time-frequency analysis.\n\nShows how frequency content changes over time.\n\nRenaissance Application:\n- Detect when dominant frequencies change (regime shift)\n- Identify transient events in time-frequency plane\n- Cross-wavelet coherence between assets", "source": "core\\_experimental\\spectral_analysis.py", "category": "regime"}
{"instruction": "What is the HilbertTransform class and how do I use it?", "input": "", "output": "The HilbertTransform class:\n\nHilbert Transform for instantaneous phase/frequency.\n\nConverts real signal to analytic signal (complex).\nPhase and frequency can be extracted.\n\nRenaissance Application:\n- Phase relationships between assets\n- Instantaneous frequency (local cyclicality)\n- Lead-lag detection", "source": "core\\_experimental\\spectral_analysis.py", "category": "alpha"}
{"instruction": "What is the SpectralFeatureEngine class and how do I use it?", "input": "", "output": "The SpectralFeatureEngine class:\n\nComplete spectral feature generation for HFT.\n\nCombines:\n1. FFT-based cycle detection\n2. Wavelet decomposition\n3. Hilbert transform features", "source": "core\\_experimental\\spectral_analysis.py", "category": "general"}
{"instruction": "Explain the Compute Spectral Features function", "input": "", "output": "Function: compute_spectral_features\n\nConvenience function for spectral feature computation.", "source": "core\\_experimental\\spectral_analysis.py", "category": "general"}
{"instruction": "What is the formula for Detect Cycles?", "input": "", "output": "Detect significant cycles in price series.\n\nReturns list of detected cycles with:\n- period: Cycle length in samples\n- power: Relative power\n- significance: Statistical significance", "source": "core\\_experimental\\spectral_analysis.py", "category": "general"}
{"instruction": "Explain the Detect Cycles function", "input": "", "output": "Function: detect_cycles\n\nDetect significant cycles in price series.\n\nReturns list of detected cycles with:\n- period: Cycle length in samples\n- power: Relative power\n- significance: Statistical significance", "source": "core\\_experimental\\spectral_analysis.py", "category": "general"}
{"instruction": "Explain the Fft Spectrum function", "input": "", "output": "Function: fft_spectrum\n\nCompute FFT power spectrum.\n\nArgs:\n    signal: Time series data\n\nReturns:\n    SpectralResult with frequencies and power", "source": "core\\_experimental\\spectral_analysis.py", "category": "alpha"}
{"instruction": "Explain the Welch Spectrum function", "input": "", "output": "Function: welch_spectrum\n\nWelch's method for robust spectral estimation.\n\nUses overlapping segments for lower variance estimate.", "source": "core\\_experimental\\spectral_analysis.py", "category": "risk"}
{"instruction": "Explain the Band Power function", "input": "", "output": "Function: band_power\n\nCompute power in a specific frequency band.\n\nArgs:\n    signal: Time series\n    low_freq: Lower bound of band\n    high_freq: Upper bound of band\n\nReturns:\n    Total power in band", "source": "core\\_experimental\\spectral_analysis.py", "category": "alpha"}
{"instruction": "What is the formula for Noise Ratio?", "input": "", "output": "Estimate noise ratio (high-freq power / total power).\n\nLower ratio = more signal, less noise", "source": "core\\_experimental\\spectral_analysis.py", "category": "alpha"}
{"instruction": "Explain the Noise Ratio function", "input": "", "output": "Function: noise_ratio\n\nEstimate noise ratio (high-freq power / total power).\n\nLower ratio = more signal, less noise", "source": "core\\_experimental\\spectral_analysis.py", "category": "alpha"}
{"instruction": "What is the formula for Decompose?", "input": "", "output": "Multi-level wavelet decomposition.\n\nReturns approximation (trend) and detail coefficients at each level.", "source": "core\\_experimental\\spectral_analysis.py", "category": "general"}
{"instruction": "Explain the Decompose function", "input": "", "output": "Function: decompose\n\nMulti-level wavelet decomposition.\n\nReturns approximation (trend) and detail coefficients at each level.", "source": "core\\_experimental\\spectral_analysis.py", "category": "general"}
{"instruction": "Explain the Denoise function", "input": "", "output": "Function: denoise\n\nWavelet denoising using soft thresholding.\n\nArgs:\n    signal: Noisy signal\n    threshold: Threshold for wavelet coefficients (auto if None)\n\nReturns:\n    Denoised signal", "source": "core\\_experimental\\spectral_analysis.py", "category": "alpha"}
{"instruction": "What is the formula for Transform?", "input": "", "output": "Compute CWT.\n\nArgs:\n    signal: Time series\n    scales: Wavelet scales (auto if None)\n\nReturns:\n    (coefficients, scales) - 2D array of wavelet coefficients", "source": "core\\_experimental\\spectral_analysis.py", "category": "alpha"}
{"instruction": "Explain the Transform function", "input": "", "output": "Function: transform\n\nCompute CWT.\n\nArgs:\n    signal: Time series\n    scales: Wavelet scales (auto if None)\n\nReturns:\n    (coefficients, scales) - 2D array of wavelet coefficients", "source": "core\\_experimental\\spectral_analysis.py", "category": "alpha"}
{"instruction": "What is the formula for Scalogram?", "input": "", "output": "Compute scalogram (power of CWT).\n\nReturns dict with:\n- power: 2D array (scales x time)\n- scales: scale axis\n- times: time axis\n- total_power: power at each time\n- dominant_scale: scale with max power at each time", "source": "core\\_experimental\\spectral_analysis.py", "category": "general"}
{"instruction": "Explain the Scalogram function", "input": "", "output": "Function: scalogram\n\nCompute scalogram (power of CWT).\n\nReturns dict with:\n- power: 2D array (scales x time)\n- scales: scale axis\n- times: time axis\n- total_power: power at each time\n- dominant_scale: scale with max power at each time", "source": "core\\_experimental\\spectral_analysis.py", "category": "general"}
{"instruction": "What is the formula for Analytic Signal?", "input": "", "output": "Compute analytic signal using Hilbert transform.\n\nReturns complex signal: z(t) = x(t) + i*H[x(t)]", "source": "core\\_experimental\\spectral_analysis.py", "category": "alpha"}
{"instruction": "Explain the Analytic Signal function", "input": "", "output": "Function: analytic_signal\n\nCompute analytic signal using Hilbert transform.\n\nReturns complex signal: z(t) = x(t) + i*H[x(t)]", "source": "core\\_experimental\\spectral_analysis.py", "category": "alpha"}
{"instruction": "What is the formula for Instantaneous Phase?", "input": "", "output": "Compute instantaneous phase.\n\nφ(t) = arctan(H[x(t)] / x(t))", "source": "core\\_experimental\\spectral_analysis.py", "category": "general"}
{"instruction": "Explain the Instantaneous Phase function", "input": "", "output": "Function: instantaneous_phase\n\nCompute instantaneous phase.\n\nφ(t) = arctan(H[x(t)] / x(t))", "source": "core\\_experimental\\spectral_analysis.py", "category": "general"}
{"instruction": "What is the formula for Instantaneous Frequency?", "input": "", "output": "Compute instantaneous frequency.\n\nf(t) = dφ/dt / (2π)", "source": "core\\_experimental\\spectral_analysis.py", "category": "general"}
{"instruction": "Explain the Instantaneous Frequency function", "input": "", "output": "Function: instantaneous_frequency\n\nCompute instantaneous frequency.\n\nf(t) = dφ/dt / (2π)", "source": "core\\_experimental\\spectral_analysis.py", "category": "general"}
{"instruction": "What is the formula for Envelope?", "input": "", "output": "Compute envelope (instantaneous amplitude).\n\nA(t) = |z(t)|", "source": "core\\_experimental\\spectral_analysis.py", "category": "general"}
{"instruction": "Explain the Envelope function", "input": "", "output": "Function: envelope\n\nCompute envelope (instantaneous amplitude).\n\nA(t) = |z(t)|", "source": "core\\_experimental\\spectral_analysis.py", "category": "general"}
{"instruction": "Explain the Compute Features function", "input": "", "output": "Function: compute_features\n\nCompute all spectral features.\n\nArgs:\n    prices: Price series\n    window: Rolling window for spectral analysis\n\nReturns:\n    DataFrame with spectral features", "source": "core\\_experimental\\spectral_analysis.py", "category": "general"}
{"instruction": "Explain the Morlet function", "input": "", "output": "Function: morlet\n\nMorlet wavelet approximation.", "source": "core\\_experimental\\spectral_analysis.py", "category": "rl"}
{"instruction": "What is the source paper for this technique?", "input": "", "output": "The source is: Google Research -. ", "source": "core\\_experimental\\temporal_fusion_transformer.py", "category": "alpha"}
{"instruction": "Explain the purpose of Temporal Fusion Transformer (TFT) for HFT Forex", "input": "", "output": "Temporal Fusion Transformer (TFT) for HFT Forex\n================================================\nSource: Google Research - \"Temporal Fusion Transformers for Interpretable\nMulti-horizon Time Series Forecasting\" (2021)\n\nKey Features:\n- Multi-horizon forecasting (predict 1, 5, 10, 20 ticks ahead simultaneously)\n- Interpretable attention (which features matter most)\n- Static covariates (symbol characteristics)\n- Known future inputs (time features)\n- Variable selection network (automatic feature importance)\n\nFor HFT Forex:\n- Native multi-horizon (1-tick, 5-tick, 10-tick predictions)\n- Feature importance for alpha discovery\n- Handles exogenous inputs (economic calendar)", "source": "core\\_experimental\\temporal_fusion_transformer.py", "category": "alpha"}
{"instruction": "What is the TFTConfig class and how do I use it?", "input": "", "output": "The TFTConfig class:\n\nTFT configuration.", "source": "core\\_experimental\\temporal_fusion_transformer.py", "category": "general"}
{"instruction": "What is the GatedResidualNetwork class and how do I use it?", "input": "", "output": "The GatedResidualNetwork class:\n\nGated Residual Network (GRN) - Core building block of TFT.\n\nProvides:\n- Non-linear processing\n- Skip connections\n- Gating mechanism for feature selection", "source": "core\\_experimental\\temporal_fusion_transformer.py", "category": "general"}
{"instruction": "What is the VariableSelectionNetwork class and how do I use it?", "input": "", "output": "The VariableSelectionNetwork class:\n\nVariable Selection Network - Automatic feature importance.\n\nLearns which features are important for prediction.\nProvides interpretability: which signals drive predictions.", "source": "core\\_experimental\\temporal_fusion_transformer.py", "category": "alpha"}
{"instruction": "What is the InterpretableMultiHeadAttention class and how do I use it?", "input": "", "output": "The InterpretableMultiHeadAttention class:\n\nInterpretable Multi-Head Attention.\n\nSame as standard attention but returns attention weights\nfor interpretability (which time steps matter).", "source": "core\\_experimental\\temporal_fusion_transformer.py", "category": "general"}
{"instruction": "What is the TemporalFusionTransformer class and how do I use it?", "input": "", "output": "The TemporalFusionTransformer class:\n\nTemporal Fusion Transformer for multi-horizon forecasting.\n\nComponents:\n1. Variable Selection - Which features matter\n2. LSTM Encoder - Temporal patterns\n3. Self-Attention - Long-range dependencies\n4. Gated Skip Connections - Information flow\n5. Quantile Output - Prediction intervals", "source": "core\\_experimental\\temporal_fusion_transformer.py", "category": "risk"}
{"instruction": "What is the TFTForex class and how do I use it?", "input": "", "output": "The TFTForex class:\n\nTFT adapted for HFT Forex trading.\n\nFeatures:\n- Returns at multiple lags\n- Volatility measures\n- Momentum indicators\n- Order flow signals\n- Time features", "source": "core\\_experimental\\temporal_fusion_transformer.py", "category": "alpha"}
{"instruction": "What is the formula for Forward?", "input": "", "output": "Args:\n    x: [B, L, num_vars, input_size] or [B, L, num_vars * input_size]\n\nReturns:\n    (selected_features, selection_weights)", "source": "core\\_experimental\\temporal_fusion_transformer.py", "category": "risk"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nArgs:\n    x: [B, L, num_vars, input_size] or [B, L, num_vars * input_size]\n\nReturns:\n    (selected_features, selection_weights)", "source": "core\\_experimental\\temporal_fusion_transformer.py", "category": "risk"}
{"instruction": "What is the formula for Forward?", "input": "", "output": "Forward pass.\n\nArgs:\n    x: [B, L, input_size] input sequence\n\nReturns:\n    Dict[horizon -> [B, num_quantiles]] predictions", "source": "core\\_experimental\\temporal_fusion_transformer.py", "category": "general"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nForward pass.\n\nArgs:\n    x: [B, L, input_size] input sequence\n\nReturns:\n    Dict[horizon -> [B, num_quantiles]] predictions", "source": "core\\_experimental\\temporal_fusion_transformer.py", "category": "general"}
{"instruction": "Explain the Predict Direction function", "input": "", "output": "Function: predict_direction\n\nPredict direction probability for each horizon.", "source": "core\\_experimental\\temporal_fusion_transformer.py", "category": "general"}
{"instruction": "Explain the Prepare Features function", "input": "", "output": "Function: prepare_features\n\nPrepare features for TFT.", "source": "core\\_experimental\\temporal_fusion_transformer.py", "category": "general"}
{"instruction": "Explain the Fit function", "input": "", "output": "Function: fit\n\nTrain TFT model.", "source": "core\\_experimental\\temporal_fusion_transformer.py", "category": "general"}
{"instruction": "What is the formula for Predict?", "input": "", "output": "Predict for all horizons.\n\nReturns:\n    Dict[horizon -> (lower, median, upper)] quantile predictions", "source": "core\\_experimental\\temporal_fusion_transformer.py", "category": "general"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nPredict for all horizons.\n\nReturns:\n    Dict[horizon -> (lower, median, upper)] quantile predictions", "source": "core\\_experimental\\temporal_fusion_transformer.py", "category": "general"}
{"instruction": "Explain the Get Direction Signals function", "input": "", "output": "Function: get_direction_signals\n\nGet direction probability for each horizon.", "source": "core\\_experimental\\temporal_fusion_transformer.py", "category": "alpha"}
{"instruction": "What is the source paper for this technique?", "input": "", "output": "The source is: NeurIPS 2024 -. ", "source": "core\\_experimental\\timexer_model.py", "category": "volatility"}
{"instruction": "Explain the purpose of TimeXer: Time Series with Exogenous Variables", "input": "", "output": "TimeXer: Time Series with Exogenous Variables\n==============================================\nSource: NeurIPS 2024 - \"TimeXer: Empowering Transformers for Time Series\nForecasting with Exogenous Variables\"\nOfficial: https://github.com/thuml/TimeXer\n\nKey Innovation:\n- Reconciles endogenous (price) and exogenous (economic) information\n- No architectural modifications needed vs vanilla Transformer\n- SOTA across 12 real-world benchmarks\n\nFor HFT Forex:\n- Endogenous: Price ticks, returns, volatility\n- Exogenous: Economic calendar, interest rates, DXY, VIX\n- Avoid catastrophic losses during news events\n- Exploit post-event reversions", "source": "core\\_experimental\\timexer_model.py", "category": "volatility"}
{"instruction": "What is the TimeXerConfig class and how do I use it?", "input": "", "output": "The TimeXerConfig class:\n\nTimeXer model configuration.", "source": "core\\_experimental\\timexer_model.py", "category": "general"}
{"instruction": "What is the TokenEmbedding class and how do I use it?", "input": "", "output": "The TokenEmbedding class:\n\nEmbed time series tokens.", "source": "core\\_experimental\\timexer_model.py", "category": "general"}
{"instruction": "What is the PositionalEncoding class and how do I use it?", "input": "", "output": "The PositionalEncoding class:\n\nSinusoidal positional encoding.", "source": "core\\_experimental\\timexer_model.py", "category": "general"}
{"instruction": "What is the ExogenousEncoder class and how do I use it?", "input": "", "output": "The ExogenousEncoder class:\n\nEncode exogenous variables separately.\n\nKey insight from TimeXer:\n- Exogenous variables need different treatment\n- They inform but don't directly predict\n- Use cross-attention to inject into main stream", "source": "core\\_experimental\\timexer_model.py", "category": "risk"}
{"instruction": "What is the TimeXerEncoderLayer class and how do I use it?", "input": "", "output": "The TimeXerEncoderLayer class:\n\nSingle TimeXer encoder layer with exogenous integration.", "source": "core\\_experimental\\timexer_model.py", "category": "rl"}
{"instruction": "What is the TimeXer class and how do I use it?", "input": "", "output": "The TimeXer class:\n\nTimeXer: Transformer for Time Series with Exogenous Variables.\n\nNeurIPS 2024 - SOTA for forecasting with external information.\n\nArchitecture:\n1. Separate embeddings for endogenous and exogenous\n2. Cross-attention to inject exogenous info\n3. Standard Transformer encoder\n4. Linear projection for prediction", "source": "core\\_experimental\\timexer_model.py", "category": "risk"}
{"instruction": "What is the TimeXerForex class and how do I use it?", "input": "", "output": "The TimeXerForex class:\n\nTimeXer adapted for HFT Forex trading.\n\nEndogenous variables:\n- Mid price returns\n- Bid-ask spread\n- Volume\n- Volatility\n- Momentum indicators\n\nExogenous variables:\n- Economic calendar (binary events)\n- Interest rate differentials\n- DXY (dollar index)\n- VIX (volatility index)\n- Hour of day (cyclical)", "source": "core\\_experimental\\timexer_model.py", "category": "volatility"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nInject exogenous information into endogenous representation.\n\nArgs:\n    endo_hidden: [B, L, D] endogenous hidden states\n    exo_input: [B, L, E] exogenous variables\n\nReturns:\n    [B, L, D] enhanced hidden states", "source": "core\\_experimental\\timexer_model.py", "category": "risk"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nForward pass.\n\nArgs:\n    x_endo: [B, L, C_endo] endogenous time series\n    x_exo: [B, L, C_exo] exogenous variables (optional)\n\nReturns:\n    [B, pred_len, C_endo] predictions", "source": "core\\_experimental\\timexer_model.py", "category": "risk"}
{"instruction": "Explain the Prepare Endogenous function", "input": "", "output": "Function: prepare_endogenous\n\nPrepare endogenous features.", "source": "core\\_experimental\\timexer_model.py", "category": "general"}
{"instruction": "Explain the Prepare Exogenous function", "input": "", "output": "Function: prepare_exogenous\n\nPrepare exogenous features.", "source": "core\\_experimental\\timexer_model.py", "category": "general"}
{"instruction": "Explain the Fit function", "input": "", "output": "Function: fit\n\nTrain TimeXer model.\n\nArgs:\n    df: DataFrame with OHLCV data\n    exo_data: Dict with 'economic_events', 'dxy', 'vix'\n    epochs: Training epochs\n    lr: Learning rate", "source": "core\\_experimental\\timexer_model.py", "category": "general"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nPredict future returns.", "source": "core\\_experimental\\timexer_model.py", "category": "general"}
{"instruction": "Explain the Get Direction Probability function", "input": "", "output": "Function: get_direction_probability\n\nGet probability of positive return over prediction horizon.", "source": "core\\_experimental\\timexer_model.py", "category": "general"}
{"instruction": "What is the source paper for this technique?", "input": "", "output": "The source is: - tsfresh library (https://tsfresh.readthedocs.io/). ", "source": "core\\_experimental\\tsfresh_auto_features.py", "category": "alpha"}
{"instruction": "Explain the purpose of TSFresh Automatic Feature Extraction", "input": "", "output": "TSFresh Automatic Feature Extraction\n=====================================\nSource:\n- tsfresh library (https://tsfresh.readthedocs.io/)\n- 知乎: 量化小白也能自动化挖掘出6万+因子\n\nKey Innovation:\n- Transforms 84 base features into 65,000+ factors\n- Automatic feature selection using FRESH algorithm\n- Statistical significance filtering\n\nFor Forex HFT:\n- Extract microstructure patterns automatically\n- Discover hidden relationships in tick data\n- Generate massive feature space for ML\n\nUsage:\n    extractor = TSFreshExtractor()\n    features = extractor.extract(df, target)\n    # Returns DataFrame with 1000s of features", "source": "core\\_experimental\\tsfresh_auto_features.py", "category": "alpha"}
{"instruction": "What is the FeatureExtractionConfig class and how do I use it?", "input": "", "output": "The FeatureExtractionConfig class:\n\nConfiguration for feature extraction.", "source": "core\\_experimental\\tsfresh_auto_features.py", "category": "general"}
{"instruction": "What is the TSFreshExtractor class and how do I use it?", "input": "", "output": "The TSFreshExtractor class:\n\nTSFresh-based automatic feature extraction.\n\nSource: 知乎 \"量化小白也能自动化挖掘出6万+因子\"\n\nModes:\n- minimal: ~10 features per time series (fast)\n- efficient: ~100 features per time series (balanced)\n- comprehensive: ~750 features per time series (slow but thorough)", "source": "core\\_experimental\\tsfresh_auto_features.py", "category": "general"}
{"instruction": "What is the QuickFeatureExtractor class and how do I use it?", "input": "", "output": "The QuickFeatureExtractor class:\n\nQuick feature extraction for HFT.\nOptimized for speed over comprehensiveness.", "source": "core\\_experimental\\tsfresh_auto_features.py", "category": "general"}
{"instruction": "What is the TSFreshFactorEngine class and how do I use it?", "input": "", "output": "The TSFreshFactorEngine class:\n\nUnified TSFresh Factor Engine.\nWrapper for HFT Feature Engine integration.", "source": "core\\_experimental\\tsfresh_auto_features.py", "category": "alpha"}
{"instruction": "Explain the Prepare Data function", "input": "", "output": "Function: prepare_data\n\nPrepare data in tsfresh long format.\n\nArgs:\n    df: Input DataFrame\n    id_col: Column identifying different time series (optional)\n    time_col: Time column name\n    value_cols: Columns to extract features from\n\nReturns:\n    DataFrame in tsfresh format", "source": "core\\_experimental\\tsfresh_auto_features.py", "category": "general"}
{"instruction": "Explain the Extract function", "input": "", "output": "Function: extract\n\nExtract features from time series data.\n\nArgs:\n    df: Input DataFrame with time series columns\n    target: Target variable for feature selection (optional)\n    value_cols: Columns to extract features from\n    use_rolling: Whether to use rolling windows\n\nReturns:\n    DataFrame with extracted features", "source": "core\\_experimental\\tsfresh_auto_features.py", "category": "risk"}
{"instruction": "Explain the Transform function", "input": "", "output": "Function: transform\n\nTransform new data using selected features.\n\nArgs:\n    df: New data to transform\n    value_cols: Value columns\n\nReturns:\n    DataFrame with selected features", "source": "core\\_experimental\\tsfresh_auto_features.py", "category": "general"}
{"instruction": "Explain the Extract function", "input": "", "output": "Function: extract\n\nExtract quick features from OHLCV data.", "source": "core\\_experimental\\tsfresh_auto_features.py", "category": "general"}
{"instruction": "Explain the Compute All Features function", "input": "", "output": "Function: compute_all_features\n\nCompute all TSFresh features.\nInterface compatible with HFT Feature Engine.", "source": "core\\_experimental\\tsfresh_auto_features.py", "category": "general"}
{"instruction": "Explain the purpose of Ultra-Selective 4-Layer Filter for 66%+ Win Rate", "input": "", "output": "Ultra-Selective 4-Layer Filter for 66%+ Win Rate\n=================================================\n\nRenaissance Technologies achieved 66% win rate through EXTREME selectivity.\nThis filter ensures only the highest-probability trades are taken.\n\nMathematical Foundation:\n------------------------\nWhen 3 independent models at p=59% each ALL agree:\n\n    P(correct | all_agree) = p³ / (p³ + (1-p)³)\n                           = 0.59³ / (0.59³ + 0.41³)\n                           = 0.205 / 0.274\n                           = 74.8%\n\nWith 4th confirmation (OFI):\n    Estimated accuracy: 80%+\n\nTrade Frequency:\n----------------\n- ~10% of signals pass all filters\n- Higher win rate compensates for fewer trades\n- Net result: Higher Sharpe ratio", "source": "core\\_experimental\\ultra_selective_filter.py", "category": "alpha"}
{"instruction": "What is the FilterResult class and how do I use it?", "input": "", "output": "The FilterResult class:\n\nResult of filter evaluation.", "source": "core\\_experimental\\ultra_selective_filter.py", "category": "general"}
{"instruction": "What is the UltraSelectiveFilter class and how do I use it?", "input": "", "output": "The UltraSelectiveFilter class:\n\n4-Layer Filter Stack for Renaissance-Level Accuracy\n\nLayer 1: Confidence Threshold (top N%)\n    - Only trade when model confidence is in top percentile\n    - Default: top 10% of all signals\n\nLayer 2: Multi-Model Agreement\n    - Require ALL models to agree on direction\n    - XGBoost, LightGBM, CatBoost must be unanimous\n    - Mathematical boost: 59% → 75%\n\nLayer 3: Regime Filter\n    - Only trade in favorable market regimes\n    - Avoid high-volatility (regime 2)\n    - Best in low-vol (regime 0) and normal (regime 1)\n\nLayer 4: Order Flow Confirmation\n    - Direction must match order flow imbalance\n    - OFI > 0 = bullish flow, OFI < 0 = bearish flow\n    - Confirms institutional activity alignment", "source": "core\\_experimental\\ultra_selective_filter.py", "category": "alpha"}
{"instruction": "What is the AdaptiveFilter class and how do I use it?", "input": "", "output": "The AdaptiveFilter class:\n\nAdaptive version that adjusts thresholds based on performance.", "source": "core\\_experimental\\ultra_selective_filter.py", "category": "general"}
{"instruction": "Explain the Update Confidence History function", "input": "", "output": "Function: update_confidence_history\n\nUpdate confidence history for dynamic threshold calculation.\n\nArgs:\n    confidence: New confidence value to add", "source": "core\\_experimental\\ultra_selective_filter.py", "category": "general"}
{"instruction": "What is the formula for Theoretical Accuracy?", "input": "", "output": "Calculate theoretical accuracy when all models agree.\n\nFormula: P(correct | all_agree) = p^n / (p^n + (1-p)^n)\n\nArgs:\n    n_models: Number of models that must agree\n\nReturns:\n    Theoretical accuracy (0-1)", "source": "core\\_experimental\\ultra_selective_filter.py", "category": "general"}
{"instruction": "Explain the Theoretical Accuracy function", "input": "", "output": "Function: theoretical_accuracy\n\nCalculate theoretical accuracy when all models agree.\n\nFormula: P(correct | all_agree) = p^n / (p^n + (1-p)^n)\n\nArgs:\n    n_models: Number of models that must agree\n\nReturns:\n    Theoretical accuracy (0-1)", "source": "core\\_experimental\\ultra_selective_filter.py", "category": "general"}
{"instruction": "What is the formula for Evaluate?", "input": "", "output": "Apply all 4 filter layers.\n\nArgs:\n    model_predictions: Dict with model predictions\n        {\n            'xgboost': {'direction': 1, 'probability': 0.62},\n            'lightgbm': {'direction': 1, 'probability': 0.61},\n            'catboost': {'direction': 1, 'probability': 0.60}\n        }\n    ensemble_confidence: Combined confidence score (0-1)\n    regime: HMM regime state (0=low vol, 1=normal, 2=high vol)\n    ofi: Order Flow Imbalance (positive=bullish, negative=bearish)\n\nReturns:\n    FilterResult with decision and details", "source": "core\\_experimental\\ultra_selective_filter.py", "category": "volatility"}
{"instruction": "Explain the Evaluate function", "input": "", "output": "Function: evaluate\n\nApply all 4 filter layers.\n\nArgs:\n    model_predictions: Dict with model predictions\n        {\n            'xgboost': {'direction': 1, 'probability': 0.62},\n            'lightgbm': {'direction': 1, 'probability': 0.61},\n            'catboost': {'direction': 1, 'probability': 0.60}\n        }\n    ensemble_confidence: Combined confidence score (0-1)\n    regime: HMM regime state (0=low vol, 1=normal, 2=high vol)\n    ofi: Order Flow Imbalance (positive=bullish, negative=bearish)\n\nReturns:\n    FilterResult with decision and details", "source": "core\\_experimental\\ultra_selective_filter.py", "category": "volatility"}
{"instruction": "What is OFI in quantitative trading?", "input": "", "output": "OFI (Order Flow Imbalance).\n\nImplementation details:\nApply all 4 filter layers.\n\nArgs:\n    model_predictions: Dict with model predictions\n        {\n            'xgboost': {'direction': 1, 'probability': 0.62},\n            'lightgbm': {'direction': 1, 'probability': 0.61},\n            'catboost': {'direction': 1, 'probability': 0.60}\n        }\n    ensemble_confidence: Combined confidence score (0-1)\n    regime: HMM regime state (0=low vol, 1=normal, 2=high vol)\n    ofi: Order Flow Imbalance (positive=bullish, negative=bearish)\n\nReturns:\n    FilterResult with decision and details", "source": "core\\_experimental\\ultra_selective_filter.py", "category": "volatility"}
{"instruction": "What is HMM in quantitative trading?", "input": "", "output": "HMM (Hidden Markov Model for regime detection).\n\nImplementation details:\nApply all 4 filter layers.\n\nArgs:\n    model_predictions: Dict with model predictions\n        {\n            'xgboost': {'direction': 1, 'probability': 0.62},\n            'lightgbm': {'direction': 1, 'probability': 0.61},\n            'catboost': {'direction': 1, 'probability': 0.60}\n        }\n    ensemble_confidence: Combined confidence score (0-1)\n    regime: HMM regime state (0=low vol, 1=normal, 2=high vol)\n    ofi: Order Flow Imbalance (positive=bullish, negative=bearish)\n\nReturns:\n    FilterResult with decision and details", "source": "core\\_experimental\\ultra_selective_filter.py", "category": "volatility"}
{"instruction": "Explain the Get Stats function", "input": "", "output": "Function: get_stats\n\nGet filter statistics.", "source": "core\\_experimental\\ultra_selective_filter.py", "category": "general"}
{"instruction": "Explain the Reset Stats function", "input": "", "output": "Function: reset_stats\n\nReset statistics.", "source": "core\\_experimental\\ultra_selective_filter.py", "category": "general"}
{"instruction": "Explain the Record Outcome function", "input": "", "output": "Function: record_outcome\n\nRecord trade outcome for adaptation.", "source": "core\\_experimental\\ultra_selective_filter.py", "category": "general"}
{"instruction": "What is the source paper for this technique?", "input": "", "output": "The source is: Easley, Lopez de Prado, O. ", "source": "core\\_experimental\\vpin_toxicity.py", "category": "volatility"}
{"instruction": "Explain the purpose of VPIN: Volume-Synchronized Probability of Informed Trading", "input": "", "output": "VPIN: Volume-Synchronized Probability of Informed Trading\n==========================================================\nSource: Easley, Lopez de Prado, O'Hara (2012)\n\"Flow Toxicity and Liquidity in a High-frequency World\"\n\nVPIN measures order flow toxicity - probability that trades are from\ninformed traders who know something the market doesn't.\n\nHigh VPIN = Informed traders are active = Volatility incoming\n- Flash Crash (May 6, 2010): VPIN spiked before crash\n- Useful for: Risk warning, mean reversion fade timing\n\nIntegration:\n- Complements OFI/OEI in order_flow_features.py\n- Use as regime indicator with HMM", "source": "core\\_experimental\\vpin_toxicity.py", "category": "volatility"}
{"instruction": "What is the VPINResult class and how do I use it?", "input": "", "output": "The VPINResult class:\n\nVPIN calculation result.", "source": "core\\_experimental\\vpin_toxicity.py", "category": "general"}
{"instruction": "What is the VPINCalculator class and how do I use it?", "input": "", "output": "The VPINCalculator class:\n\nVolume-Synchronized Probability of Informed Trading.\n\nVPIN = |V_buy - V_sell| / (V_buy + V_sell)\n\nWhere volumes are classified using:\n1. Tick Rule: Trade at uptick = buy, downtick = sell\n2. Bulk Volume Classification (BVC): More robust\n\nParameters:\n-----------\nbucket_size : int\n    Number of contracts per volume bucket\nn_buckets : int\n    Number of buckets for rolling VPIN", "source": "core\\_experimental\\vpin_toxicity.py", "category": "volatility"}
{"instruction": "What is the VPINFeatures class and how do I use it?", "input": "", "output": "The VPINFeatures class:\n\nGenerate VPIN-based features for HFT.", "source": "core\\_experimental\\vpin_toxicity.py", "category": "general"}
{"instruction": "Explain the Calculate Vpin Simple function", "input": "", "output": "Function: calculate_vpin_simple\n\nSimple VPIN calculation for feature engineering.\n\nArgs:\n    prices: Mid prices\n    volumes: Trade volumes\n    n_buckets: Rolling window for VPIN\n\nReturns:\n    Array of VPIN values", "source": "core\\_experimental\\vpin_toxicity.py", "category": "volatility"}
{"instruction": "What is VPIN in quantitative trading?", "input": "", "output": "VPIN (Volume-Synchronized Probability of Informed Trading).\n\nImplementation details:\nSimple VPIN calculation for feature engineering.\n\nArgs:\n    prices: Mid prices\n    volumes: Trade volumes\n    n_buckets: Rolling window for VPIN\n\nReturns:\n    Array of VPIN values", "source": "core\\_experimental\\vpin_toxicity.py", "category": "volatility"}
{"instruction": "Explain the Classify Trade function", "input": "", "output": "Function: classify_trade\n\nClassify trade as buy or sell using tick rule.\n\nReturns:\n    (buy_volume, sell_volume)", "source": "core\\_experimental\\vpin_toxicity.py", "category": "volatility"}
{"instruction": "What is the formula for Bulk Classify?", "input": "", "output": "Bulk Volume Classification (BVC) - more robust than tick rule.\n\nUses: V_buy = V * CDF(Z) where Z = (P - VWAP) / sigma", "source": "core\\_experimental\\vpin_toxicity.py", "category": "volatility"}
{"instruction": "Explain the Bulk Classify function", "input": "", "output": "Function: bulk_classify\n\nBulk Volume Classification (BVC) - more robust than tick rule.\n\nUses: V_buy = V * CDF(Z) where Z = (P - VWAP) / sigma", "source": "core\\_experimental\\vpin_toxicity.py", "category": "volatility"}
{"instruction": "What is VWAP in quantitative trading?", "input": "", "output": "VWAP (Volume-Weighted Average Price execution).\n\nImplementation details:\nBulk Volume Classification (BVC) - more robust than tick rule.\n\nUses: V_buy = V * CDF(Z) where Z = (P - VWAP) / sigma", "source": "core\\_experimental\\vpin_toxicity.py", "category": "volatility"}
{"instruction": "Explain the Update function", "input": "", "output": "Function: update\n\nUpdate VPIN with new trade.\n\nReturns VPINResult when a new bucket is completed.", "source": "core\\_experimental\\vpin_toxicity.py", "category": "general"}
{"instruction": "What is VPIN in quantitative trading?", "input": "", "output": "VPIN (Volume-Synchronized Probability of Informed Trading).\n\nImplementation details:\nUpdate VPIN with new trade.\n\nReturns VPINResult when a new bucket is completed.", "source": "core\\_experimental\\vpin_toxicity.py", "category": "general"}
{"instruction": "Explain the Calculate Vpin function", "input": "", "output": "Function: calculate_vpin\n\nCalculate current VPIN from bucket history.", "source": "core\\_experimental\\vpin_toxicity.py", "category": "general"}
{"instruction": "What is VPIN in quantitative trading?", "input": "", "output": "VPIN (Volume-Synchronized Probability of Informed Trading).\n\nImplementation details:\nCalculate current VPIN from bucket history.", "source": "core\\_experimental\\vpin_toxicity.py", "category": "general"}
{"instruction": "Explain the Get Current Vpin function", "input": "", "output": "Function: get_current_vpin\n\nGet current VPIN estimate.", "source": "core\\_experimental\\vpin_toxicity.py", "category": "general"}
{"instruction": "What is VPIN in quantitative trading?", "input": "", "output": "VPIN (Volume-Synchronized Probability of Informed Trading).\n\nImplementation details:\nGet current VPIN estimate.", "source": "core\\_experimental\\vpin_toxicity.py", "category": "general"}
{"instruction": "Explain the Compute Features function", "input": "", "output": "Function: compute_features\n\nCompute VPIN features from tick data.\n\nArgs:\n    df: DataFrame with columns [timestamp, bid, ask, volume] or [price, volume]\n\nReturns:\n    DataFrame with VPIN features", "source": "core\\_experimental\\vpin_toxicity.py", "category": "volatility"}
{"instruction": "What is VPIN in quantitative trading?", "input": "", "output": "VPIN (Volume-Synchronized Probability of Informed Trading).\n\nImplementation details:\nCompute VPIN features from tick data.\n\nArgs:\n    df: DataFrame with columns [timestamp, bid, ask, volume] or [price, volume]\n\nReturns:\n    DataFrame with VPIN features", "source": "core\\_experimental\\vpin_toxicity.py", "category": "volatility"}
{"instruction": "What is the source paper for Multiple test periods?", "input": "", "output": "The source is: Lopez de Prado. ", "source": "core\\_experimental\\walk_forward.py", "category": "general"}
{"instruction": "Explain the purpose of Walk-Forward Cross-Validation for Financial Time Series", "input": "", "output": "Walk-Forward Cross-Validation for Financial Time Series\n========================================================\nPrevents overfitting by using proper time-series validation.\n\nMethods:\n1. Expanding Window - Train on all historical, test on next period\n2. Rolling Window - Fixed training window, slides forward\n3. Purged K-Fold - K-fold with gap to prevent leakage\n4. Combinatorial Purged CV - Multiple test periods\n\nSource: Lopez de Prado \"Advances in Financial Machine Learning\"", "source": "core\\_experimental\\walk_forward.py", "category": "general"}
{"instruction": "What is the WalkForwardResult class and how do I use it?", "input": "", "output": "The WalkForwardResult class:\n\nResult from one walk-forward fold.", "source": "core\\_experimental\\walk_forward.py", "category": "general"}
{"instruction": "What is the WalkForwardCV class and how do I use it?", "input": "", "output": "The WalkForwardCV class:\n\nWalk-Forward Cross-Validation for time series.\n\nUsage:\n    wf = WalkForwardCV(n_splits=5, train_ratio=0.8)\n    for train_idx, test_idx in wf.split(X, y):\n        model.fit(X[train_idx], y[train_idx])\n        score = model.score(X[test_idx], y[test_idx])", "source": "core\\_experimental\\walk_forward.py", "category": "general"}
{"instruction": "Show me a code example for WalkForwardCV", "input": "", "output": "wf = WalkForwardCV(n_splits=5, train_ratio=0.8)\n    for train_idx, test_idx in wf.split(X, y):\n        model.fit(X[train_idx], y[train_idx])\n        score = model.score(X[test_idx], y[test_idx])", "source": "core\\_experimental\\walk_forward.py", "category": "general"}
{"instruction": "What is the PurgedKFold class and how do I use it?", "input": "", "output": "The PurgedKFold class:\n\nPurged K-Fold Cross-Validation.\n\nAdds embargo period between train and test to prevent information leakage\nfrom overlapping labels or features.\n\nSource: Lopez de Prado \"Advances in Financial Machine Learning\", Chapter 7", "source": "core\\_experimental\\walk_forward.py", "category": "rl"}
{"instruction": "What is the CombinatorialPurgedCV class and how do I use it?", "input": "", "output": "The CombinatorialPurgedCV class:\n\nCombinatorial Purged Cross-Validation (CPCV).\n\nCreates multiple paths through the data, each treated as a potential backtest.\nMore robust than single walk-forward.\n\nSource: Lopez de Prado \"Advances in Financial Machine Learning\", Chapter 12", "source": "core\\_experimental\\walk_forward.py", "category": "general"}
{"instruction": "What is the formula for Run Walk Forward Backtest?", "input": "", "output": "Run complete walk-forward backtest.\n\nArgs:\n    model: Sklearn-compatible model with fit/predict\n    X: Features\n    y: Labels\n    cv: Cross-validation splitter\n    timestamps: Optional timestamps for reporting\n\nReturns:\n    List of WalkForwardResult for each fold", "source": "core\\_experimental\\walk_forward.py", "category": "general"}
{"instruction": "Explain the Run Walk Forward Backtest function", "input": "", "output": "Function: run_walk_forward_backtest\n\nRun complete walk-forward backtest.\n\nArgs:\n    model: Sklearn-compatible model with fit/predict\n    X: Features\n    y: Labels\n    cv: Cross-validation splitter\n    timestamps: Optional timestamps for reporting\n\nReturns:\n    List of WalkForwardResult for each fold", "source": "core\\_experimental\\walk_forward.py", "category": "general"}
{"instruction": "What is the formula for Walk Forward Analysis?", "input": "", "output": "Analyze walk-forward results.\n\nReturns:\n    Dict with summary statistics", "source": "core\\_experimental\\walk_forward.py", "category": "general"}
{"instruction": "Explain the Walk Forward Analysis function", "input": "", "output": "Function: walk_forward_analysis\n\nAnalyze walk-forward results.\n\nReturns:\n    Dict with summary statistics", "source": "core\\_experimental\\walk_forward.py", "category": "general"}
{"instruction": "What is the formula for Detect Overfitting?", "input": "", "output": "Detect if model is overfitting.\n\nArgs:\n    train_score: Training accuracy\n    test_score: Test accuracy\n    threshold: Max acceptable ratio (e.g., 1.15 = 15% higher train)\n\nReturns:\n    True if overfitting detected", "source": "core\\_experimental\\walk_forward.py", "category": "general"}
{"instruction": "Explain the Detect Overfitting function", "input": "", "output": "Function: detect_overfitting\n\nDetect if model is overfitting.\n\nArgs:\n    train_score: Training accuracy\n    test_score: Test accuracy\n    threshold: Max acceptable ratio (e.g., 1.15 = 15% higher train)\n\nReturns:\n    True if overfitting detected", "source": "core\\_experimental\\walk_forward.py", "category": "general"}
{"instruction": "What is the WalkForwardOptimizer class and how do I use it?", "input": "", "output": "The WalkForwardOptimizer class:\n\nOptimize model hyperparameters using walk-forward validation.\n\nPrevents selecting hyperparameters that overfit to a single test set.", "source": "core\\_experimental\\walk_forward.py", "category": "general"}
{"instruction": "Explain the Expanding Window Cv function", "input": "", "output": "Function: expanding_window_cv\n\nCreate expanding window CV.", "source": "core\\_experimental\\walk_forward.py", "category": "general"}
{"instruction": "Explain the Rolling Window Cv function", "input": "", "output": "Function: rolling_window_cv\n\nCreate rolling window CV.", "source": "core\\_experimental\\walk_forward.py", "category": "general"}
{"instruction": "What is the formula for Purged Cv?", "input": "", "output": "Create purged K-fold CV.", "source": "core\\_experimental\\walk_forward.py", "category": "general"}
{"instruction": "Explain the Purged Cv function", "input": "", "output": "Function: purged_cv\n\nCreate purged K-fold CV.", "source": "core\\_experimental\\walk_forward.py", "category": "general"}
{"instruction": "What is the formula for Split?", "input": "", "output": "Generate train/test indices for each fold.\n\nArgs:\n    X: Features array\n    y: Labels array (optional)\n\nYields:\n    (train_indices, test_indices) for each fold", "source": "core\\_experimental\\walk_forward.py", "category": "general"}
{"instruction": "Explain the Split function", "input": "", "output": "Function: split\n\nGenerate train/test indices for each fold.\n\nArgs:\n    X: Features array\n    y: Labels array (optional)\n\nYields:\n    (train_indices, test_indices) for each fold", "source": "core\\_experimental\\walk_forward.py", "category": "general"}
{"instruction": "What is the formula for Split?", "input": "", "output": "Generate purged train/test splits.\n\nArgs:\n    X: Features\n    y: Labels (optional)\n    times: Timestamps for embargo calculation\n\nYields:\n    (train_indices, test_indices)", "source": "core\\_experimental\\walk_forward.py", "category": "general"}
{"instruction": "Explain the Split function", "input": "", "output": "Function: split\n\nGenerate purged train/test splits.\n\nArgs:\n    X: Features\n    y: Labels (optional)\n    times: Timestamps for embargo calculation\n\nYields:\n    (train_indices, test_indices)", "source": "core\\_experimental\\walk_forward.py", "category": "general"}
{"instruction": "Explain the Split function", "input": "", "output": "Function: split\n\nGenerate all combinatorial paths.", "source": "core\\_experimental\\walk_forward.py", "category": "general"}
{"instruction": "What is the formula for Fit?", "input": "", "output": "Find best parameters using walk-forward CV.", "source": "core\\_experimental\\walk_forward.py", "category": "general"}
{"instruction": "Explain the Fit function", "input": "", "output": "Function: fit\n\nFind best parameters using walk-forward CV.", "source": "core\\_experimental\\walk_forward.py", "category": "general"}
{"instruction": "Explain the purpose of Gold Standard RL Agents for Forex Trading", "input": "", "output": "Gold Standard RL Agents for Forex Trading\n\nAcademic Citations:\n══════════════════════════════════════════════════════════════════════════════\n\nPPO - Proximal Policy Optimization:\n    Schulman et al. (2017)\n    \"Proximal Policy Optimization Algorithms\"\n    arXiv:1707.06347\n    Best for: Stability, no divergence, sample efficiency\n\nSAC - Soft Actor-Critic:\n    Haarnoja et al. (2018)\n    \"Soft Actor-Critic: Off-Policy Maximum Entropy Deep RL\"\n    ICML 2018\n    Best for: Aggressive trading, exploration-exploitation balance\n\nA2C - Advantage Actor-Critic:\n    Mnih et al. (2016)\n    \"Asynchronous Methods for Deep Reinforcement Learning\"\n    ICML 2016\n    Best for: Cumulative returns, parallel training\n\nTD3 - Twin Delayed DDPG:\n    Fujimoto et al. (2018)\n    \"Addressing Function Approximation Error in Actor-Critic Methods\"\n    ICML 2018\n    Best for: Continuous actions, reduced overestimation\n\nDQN - Deep Q-Network:\n    Mnih et al. (2015)\n    \"Human-level control through deep reinforcement learning\"\n    Nature 518, 529-533\n    Best for: Discrete actions, experience replay\n\nDDPG - Deep Deterministic Policy Gradient:\n    Lillicrap et al. (2016)\n    \"Continuous control with deep reinforcement learning\"\n    ICLR 2016\n    Best for: Continuous control, off-policy learning\n\nImplementation Based On:\n    - Stable-Baselines3: Raffin et al. (2021), JMLR\n    - FinRL: Liu et al. (2020), NeurIPS Deep RL Workshop\n    - ElegantRL: Liu et al. (2021), ICAIF\n\n══════════════════════════════════════════════════════════════════════════════", "source": "core\\rl\\agents.py", "category": "rl"}
{"instruction": "What is the AgentConfig class and how do I use it?", "input": "", "output": "The AgentConfig class:\n\nConfiguration for RL Agents.\n\nBased on Stable-Baselines3 and FinRL configurations.", "source": "core\\rl\\agents.py", "category": "rl"}
{"instruction": "What is the MLP class and how do I use it?", "input": "", "output": "The MLP class:\n\nMulti-Layer Perceptron for actor/critic networks.", "source": "core\\rl\\agents.py", "category": "general"}
{"instruction": "What is the GaussianActor class and how do I use it?", "input": "", "output": "The GaussianActor class:\n\nGaussian Policy Network for continuous actions.\n\nUsed by: PPO, SAC, A2C\nReference: Schulman et al. (2017), Haarnoja et al. (2018)", "source": "core\\rl\\agents.py", "category": "rl"}
{"instruction": "What is the DeterministicActor class and how do I use it?", "input": "", "output": "The DeterministicActor class:\n\nDeterministic Policy Network for continuous actions.\n\nUsed by: DDPG, TD3\nReference: Lillicrap et al. (2016), Fujimoto et al. (2018)", "source": "core\\rl\\agents.py", "category": "general"}
{"instruction": "What is the Critic class and how do I use it?", "input": "", "output": "The Critic class:\n\nValue/Q-function Network.\n\nUsed by: All agents", "source": "core\\rl\\agents.py", "category": "rl"}
{"instruction": "What is the TwinCritic class and how do I use it?", "input": "", "output": "The TwinCritic class:\n\nTwin Q-Networks for TD3/SAC.\n\nReference: Fujimoto et al. (2018) - \"Clipped Double Q-Learning\"", "source": "core\\rl\\agents.py", "category": "general"}
{"instruction": "What is the ReplayBuffer class and how do I use it?", "input": "", "output": "The ReplayBuffer class:\n\nExperience Replay Buffer.\n\nReference: Mnih et al. (2015) - \"Experience Replay\"", "source": "core\\rl\\agents.py", "category": "general"}
{"instruction": "What is the BaseRLAgent class and how do I use it?", "input": "", "output": "The BaseRLAgent class:\n\nAbstract Base Class for RL Agents.\n\nFollows Stable-Baselines3 interface pattern.", "source": "core\\rl\\agents.py", "category": "rl"}
{"instruction": "What is the PPOAgent class and how do I use it?", "input": "", "output": "The PPOAgent class:\n\nProximal Policy Optimization Agent.\n\nReference:\n    Schulman et al. (2017)\n    \"Proximal Policy Optimization Algorithms\"\n    arXiv:1707.06347\n\nKey innovations:\n- Clipped surrogate objective prevents large policy updates\n- GAE (Generalized Advantage Estimation) for variance reduction\n- Multiple epochs of minibatch updates\n\nPPO is the MOST STABLE algorithm for trading:\n- No divergence from clipped objective\n- Sample efficient on-policy learning\n- Works well with high-dimensional state spaces", "source": "core\\rl\\agents.py", "category": "risk"}
{"instruction": "What is the RolloutBuffer class and how do I use it?", "input": "", "output": "The RolloutBuffer class:\n\nBuffer for on-policy algorithms (PPO, A2C).", "source": "core\\rl\\agents.py", "category": "rl"}
{"instruction": "What is the SACAgent class and how do I use it?", "input": "", "output": "The SACAgent class:\n\nSoft Actor-Critic Agent.\n\nReference:\n    Haarnoja et al. (2018)\n    \"Soft Actor-Critic: Off-Policy Maximum Entropy Deep RL\"\n    ICML 2018\n\nKey innovations:\n- Maximum entropy framework for exploration\n- Automatic temperature tuning\n- Twin Q-networks to reduce overestimation\n\nSAC is BEST for AGGRESSIVE trading:\n- Entropy bonus encourages exploration\n- Off-policy = sample efficient\n- Works well with continuous actions", "source": "core\\rl\\agents.py", "category": "rl"}
{"instruction": "What is the A2CAgent class and how do I use it?", "input": "", "output": "The A2CAgent class:\n\nAdvantage Actor-Critic Agent.\n\nReference:\n    Mnih et al. (2016)\n    \"Asynchronous Methods for Deep Reinforcement Learning\"\n    ICML 2016\n\nA2C (synchronous version of A3C) is BEST for CUMULATIVE RETURNS:\n- Actor-critic reduces variance\n- Fast convergence on trading tasks\n- Good for parallel training", "source": "core\\rl\\agents.py", "category": "risk"}
{"instruction": "What is the TD3Agent class and how do I use it?", "input": "", "output": "The TD3Agent class:\n\nTwin Delayed DDPG Agent.\n\nReference:\n    Fujimoto et al. (2018)\n    \"Addressing Function Approximation Error in Actor-Critic Methods\"\n    ICML 2018\n\nKey innovations:\n- Twin Q-networks to reduce overestimation\n- Delayed policy updates\n- Target policy smoothing\n\nTD3 is BEST for CONTINUOUS ACTIONS:\n- Deterministic policy for precise control\n- Clipped double Q-learning\n- Works well with large action spaces", "source": "core\\rl\\agents.py", "category": "rl"}
{"instruction": "What is the DQNAgent class and how do I use it?", "input": "", "output": "The DQNAgent class:\n\nDeep Q-Network Agent.\n\nReference:\n    Mnih et al. (2015)\n    \"Human-level control through deep reinforcement learning\"\n    Nature 518, 529-533\n\nDQN is BEST for DISCRETE ACTIONS:\n- Q-learning with neural network\n- Experience replay for stability\n- Target network for convergence", "source": "core\\rl\\agents.py", "category": "rl"}
{"instruction": "What is the DDPGAgent class and how do I use it?", "input": "", "output": "The DDPGAgent class:\n\nDeep Deterministic Policy Gradient Agent.\n\nReference:\n    Lillicrap et al. (2016)\n    \"Continuous control with deep reinforcement learning\"\n    ICLR 2016\n\nDDPG is the foundation for TD3:\n- Deterministic policy gradient\n- Off-policy actor-critic\n- Good for continuous control", "source": "core\\rl\\agents.py", "category": "rl"}
{"instruction": "Explain the Create Agent function", "input": "", "output": "Function: create_agent\n\nFactory function to create RL agents.\n\nArgs:\n    agent_type: One of 'ppo', 'sac', 'a2c', 'td3', 'dqn', 'ddpg'\n    env: Gym environment\n    config: Agent configuration\n\nReturns:\n    RL agent instance", "source": "core\\rl\\agents.py", "category": "alpha"}
{"instruction": "What is DQN in quantitative trading?", "input": "", "output": "DQN (Deep Q-Network for trading).\n\nImplementation details:\nFactory function to create RL agents.\n\nArgs:\n    agent_type: One of 'ppo', 'sac', 'a2c', 'td3', 'dqn', 'ddpg'\n    env: Gym environment\n    config: Agent configuration\n\nReturns:\n    RL agent instance", "source": "core\\rl\\agents.py", "category": "alpha"}
{"instruction": "What is PPO in quantitative trading?", "input": "", "output": "PPO (Proximal Policy Optimization).\n\nImplementation details:\nFactory function to create RL agents.\n\nArgs:\n    agent_type: One of 'ppo', 'sac', 'a2c', 'td3', 'dqn', 'ddpg'\n    env: Gym environment\n    config: Agent configuration\n\nReturns:\n    RL agent instance", "source": "core\\rl\\agents.py", "category": "alpha"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nForward pass returning mean and log_std.", "source": "core\\rl\\agents.py", "category": "general"}
{"instruction": "Explain the Sample function", "input": "", "output": "Function: sample\n\nSample action and compute log probability.", "source": "core\\rl\\agents.py", "category": "general"}
{"instruction": "Explain the Get Action function", "input": "", "output": "Function: get_action\n\nGet action for execution.", "source": "core\\rl\\agents.py", "category": "execution"}
{"instruction": "Explain the Select Action function", "input": "", "output": "Function: select_action\n\nSelect action given state.", "source": "core\\rl\\agents.py", "category": "regime"}
{"instruction": "Explain the Train function", "input": "", "output": "Function: train\n\nTrain on a batch of data.", "source": "core\\rl\\agents.py", "category": "general"}
{"instruction": "Explain the Learn function", "input": "", "output": "Function: learn\n\nMain training loop.", "source": "core\\rl\\agents.py", "category": "general"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nPredict action for given state.", "source": "core\\rl\\agents.py", "category": "regime"}
{"instruction": "Explain the Save function", "input": "", "output": "Function: save\n\nSave model to path.", "source": "core\\rl\\agents.py", "category": "general"}
{"instruction": "Explain the Load function", "input": "", "output": "Function: load\n\nLoad model from path.", "source": "core\\rl\\agents.py", "category": "general"}
{"instruction": "Explain the State Dict function", "input": "", "output": "Function: state_dict\n\nGet state dict for saving.", "source": "core\\rl\\agents.py", "category": "regime"}
{"instruction": "Explain the Load State Dict function", "input": "", "output": "Function: load_state_dict\n\nLoad state dict.", "source": "core\\rl\\agents.py", "category": "regime"}
{"instruction": "What is the formula for Compute Gae?", "input": "", "output": "Compute Generalized Advantage Estimation.\n\nReference: Schulman et al. (2016)\n\"High-Dimensional Continuous Control Using GAE\"", "source": "core\\rl\\agents.py", "category": "general"}
{"instruction": "Explain the Compute Gae function", "input": "", "output": "Function: compute_gae\n\nCompute Generalized Advantage Estimation.\n\nReference: Schulman et al. (2016)\n\"High-Dimensional Continuous Control Using GAE\"", "source": "core\\rl\\agents.py", "category": "general"}
{"instruction": "Explain the Train function", "input": "", "output": "Function: train\n\nTrain PPO agent on rollout data.", "source": "core\\rl\\agents.py", "category": "rl"}
{"instruction": "What is PPO in quantitative trading?", "input": "", "output": "PPO (Proximal Policy Optimization).\n\nImplementation details:\nTrain PPO agent on rollout data.", "source": "core\\rl\\agents.py", "category": "rl"}
{"instruction": "Explain the Train function", "input": "", "output": "Function: train\n\nTrain SAC agent.", "source": "core\\rl\\agents.py", "category": "rl"}
{"instruction": "Explain the Train function", "input": "", "output": "Function: train\n\nTrain A2C agent.", "source": "core\\rl\\agents.py", "category": "rl"}
{"instruction": "Explain the Train function", "input": "", "output": "Function: train\n\nTrain TD3 agent.", "source": "core\\rl\\agents.py", "category": "rl"}
{"instruction": "Explain the Train function", "input": "", "output": "Function: train\n\nTrain DQN agent.", "source": "core\\rl\\agents.py", "category": "rl"}
{"instruction": "What is DQN in quantitative trading?", "input": "", "output": "DQN (Deep Q-Network for trading).\n\nImplementation details:\nTrain DQN agent.", "source": "core\\rl\\agents.py", "category": "rl"}
{"instruction": "Explain the Train function", "input": "", "output": "Function: train\n\nTrain DDPG agent.", "source": "core\\rl\\agents.py", "category": "rl"}
{"instruction": "Explain the purpose of Multi-Agent Reinforcement Learning for Order Execution (Chinese Quant Innovation)", "input": "", "output": "Multi-Agent Reinforcement Learning for Order Execution (Chinese Quant Innovation)\n\n中国量化创新：多智能体协作强化学习订单执行\n\nAcademic Citations:\n══════════════════════════════════════════════════════════════════════════════\n\nCORE RESEARCH (Microsoft Asia Research - Qlib Team):\n\n1. Multi-Agent RL for Order Execution:\n   Wei et al. (2023)\n   \"Order Execution via Multi-Agent Reinforcement Learning with Decomposed\n    Joint Action Space\"\n   Microsoft Research Asia, Qlib Team\n   Key insight: MARL beats single-agent by 15%+ on A股 and US stocks\n\n2. Qlib Platform:\n   Yang et al. (2020)\n   \"Qlib: An AI-oriented Quantitative Investment Platform\"\n   arXiv:2009.11189\n   Microsoft Research Asia\n   GitHub: microsoft/qlib (15k+ stars)\n\n3. R&D-Agent-Quant:\n   Microsoft Research Asia (2024)\n   \"R&D-Agent-Quant: Multi-Agent Framework for Quantitative Investment\"\n   Tested on: 沪深300 (CSI 300)\n\nCHINESE ACADEMIC RESEARCH:\n\n4. MARL Foundations:\n   《多智能体深度强化学习及其可扩展性与可迁移性研究综述》\n   控制与决策, 2022\n\n5. CTDE Framework:\n   《多智能体分层强化学习综述》\n   殷昌盛, 杨若鹏, 朱巍, 邹小飞, 李峰\n   智能系统学报\n\n6. Value Decomposition:\n   Rashid et al. (2018)\n   \"QMIX: Monotonic Value Function Factorisation for MADRL\"\n   ICML 2018\n   Extended by Chinese researchers with GNN + Attention\n\n7. A股 Empirical Study:\n   南京大学 (2023)\n   \"Empirical comparison of domestic financial market investment\n    based on deep reinforcement learning\"\n   Journal of Nanjing University\n\n══════════════════════════════════════════════════════════════════════════════\nKEY INNOVATION:\n- Decompose joint action space for multi-order execution\n- Each agent handles one order, agents collaborate to minimize market impact\n- Tested on A股 (沪深300, SSE 50) with 15%+ improvement over single-agent\n══════════════════════════════════════════════════════════════════════════════", "source": "core\\rl\\chinese_marl.py", "category": "alpha"}
{"instruction": "What is the MARLConfig class and how do I use it?", "input": "", "output": "The MARLConfig class:\n\nConfiguration for Multi-Agent RL.\n\nBased on Microsoft Qlib MARL implementation.", "source": "core\\rl\\chinese_marl.py", "category": "rl"}
{"instruction": "What is the OrderExecutionEnv class and how do I use it?", "input": "", "output": "The OrderExecutionEnv class:\n\nMulti-Agent Order Execution Environment.\n\nBased on Microsoft Qlib order execution environment.\n\nReference:\n    Wei et al. (2023)\n    \"Order Execution via Multi-Agent RL with Decomposed Joint Action Space\"\n    Microsoft Research Asia\n\nEach agent manages one order with the goal of minimizing:\n- Implementation Shortfall (IS)\n- Market Impact\n- Timing Risk\n\nState (per agent):\n    - Remaining inventory\n    - Time remaining\n    - Price features (returns, volatility, spread)\n    - Order book imbalance\n    - Other agents' actions (communication)\n\nAction:\n    - Fraction of remaining inventory to execute (0 to 1)\n\nReward:\n    - Negative implementation shortfall\n    - Penalty for market impact\n    - Bonus for completing execution", "source": "core\\rl\\chinese_marl.py", "category": "volatility"}
{"instruction": "What is the QMIXMixer class and how do I use it?", "input": "", "output": "The QMIXMixer class:\n\nQMIX Mixing Network for Value Decomposition.\n\nReference:\n    Rashid et al. (2018)\n    \"QMIX: Monotonic Value Function Factorisation for MADRL\"\n    ICML 2018\n\nExtended by Chinese researchers with attention mechanisms.\n\nQ_tot = f(Q_1, Q_2, ..., Q_n, s)\n\nwhere f is a mixing network with non-negative weights to ensure monotonicity.", "source": "core\\rl\\chinese_marl.py", "category": "alpha"}
{"instruction": "What is the MARLAgent class and how do I use it?", "input": "", "output": "The MARLAgent class:\n\nIndividual Agent Network for MARL.\n\nEach agent has its own policy and value network.\nCommunication is handled through shared observations.", "source": "core\\rl\\chinese_marl.py", "category": "rl"}
{"instruction": "What is the MARLOrderExecution class and how do I use it?", "input": "", "output": "The MARLOrderExecution class:\n\nMulti-Agent RL for Order Execution.\n\nBased on Microsoft Qlib MARL implementation.\n\nReference:\n    Wei et al. (2023)\n    \"Order Execution via Multi-Agent RL\"\n    Microsoft Research Asia\n\nKey innovations:\n1. Decomposed joint action space - each agent handles one order\n2. QMIX for value decomposition - credit assignment\n3. CTDE framework - centralized training, decentralized execution\n\nResults from paper:\n- 15%+ improvement over single-agent on A股\n- Fewer decision conflicts\n- Lower market impact", "source": "core\\rl\\chinese_marl.py", "category": "execution"}
{"instruction": "What is the MARLReplayBuffer class and how do I use it?", "input": "", "output": "The MARLReplayBuffer class:\n\nReplay buffer for MARL.", "source": "core\\rl\\chinese_marl.py", "category": "rl"}
{"instruction": "Explain the Create Marl Order Execution function", "input": "", "output": "Function: create_marl_order_execution\n\nFactory function to create MARL order execution system.\n\nArgs:\n    price_data: Price time series\n    n_agents: Number of agents (orders)\n    config: MARL configuration\n\nReturns:\n    MARLOrderExecution instance", "source": "core\\rl\\chinese_marl.py", "category": "alpha"}
{"instruction": "Explain the Reset function", "input": "", "output": "Function: reset\n\nReset environment for new episode.", "source": "core\\rl\\chinese_marl.py", "category": "general"}
{"instruction": "Explain the Step function", "input": "", "output": "Function: step\n\nExecute one step for all agents.\n\nArgs:\n    actions: Array of execution rates for each agent\n\nReturns:\n    state, reward, terminated, truncated, info", "source": "core\\rl\\chinese_marl.py", "category": "execution"}
{"instruction": "What is the formula for Forward?", "input": "", "output": "Mix individual Q-values into total Q-value.\n\nArgs:\n    agent_qs: Individual agent Q-values (batch, n_agents)\n    state: Global state (batch, state_dim)\n\nReturns:\n    Q_tot: Total Q-value (batch, 1)", "source": "core\\rl\\chinese_marl.py", "category": "rl"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nMix individual Q-values into total Q-value.\n\nArgs:\n    agent_qs: Individual agent Q-values (batch, n_agents)\n    state: Global state (batch, state_dim)\n\nReturns:\n    Q_tot: Total Q-value (batch, 1)", "source": "core\\rl\\chinese_marl.py", "category": "rl"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nForward pass returning action distribution params and value.", "source": "core\\rl\\chinese_marl.py", "category": "general"}
{"instruction": "Explain the Get Action function", "input": "", "output": "Function: get_action\n\nGet action for execution.", "source": "core\\rl\\chinese_marl.py", "category": "execution"}
{"instruction": "Explain the Select Actions function", "input": "", "output": "Function: select_actions\n\nSelect actions for all agents.", "source": "core\\rl\\chinese_marl.py", "category": "rl"}
{"instruction": "Explain the Train Step function", "input": "", "output": "Function: train_step\n\nTrain MARL agents with QMIX.\n\nReference: Rashid et al. (2018) QMIX", "source": "core\\rl\\chinese_marl.py", "category": "rl"}
{"instruction": "Explain the Learn function", "input": "", "output": "Function: learn\n\nMain training loop.", "source": "core\\rl\\chinese_marl.py", "category": "general"}
{"instruction": "Explain the Save function", "input": "", "output": "Function: save\n\nSave model.", "source": "core\\rl\\chinese_marl.py", "category": "general"}
{"instruction": "Explain the Load function", "input": "", "output": "Function: load\n\nLoad model.", "source": "core\\rl\\chinese_marl.py", "category": "general"}
{"instruction": "What is the source paper for this technique?", "input": "", "output": "The source is: Dabney et al. (2018),. ", "source": "core\\rl\\distributional_qrdqn.py", "category": "risk"}
{"instruction": "What is the source paper for this technique?", "input": "", "output": "The source is: arXiv:2501.04421 (January 2025). ", "source": "core\\rl\\distributional_qrdqn.py", "category": "risk"}
{"instruction": "Explain the purpose of Quantile Regression DQN for Forex Trading", "input": "", "output": "Quantile Regression DQN for Forex Trading\n==========================================\nDistributional RL that models full return distribution instead of expected value.\n\nMathematical Formula:\n    L(θ) = E[ρ_τ^κ(δ_t)]\n    where ρ_τ^κ(u) = |τ - 1_{u<0}| * κ_τ(u) / κ\n\nExpected Improvement: +15-25% accuracy (63% → 78-88%)\n\nReference:\n    Dabney et al. (2018), \"Distributional Reinforcement Learning with Quantile Regression\"\n    AAAI 2018, arXiv:1710.10044\n\nEmpirical Results (Natural Gas Futures):\n    - QR-DQN significantly outperforms classical DQN\n    - Better risk management through distribution modeling\n    - Source: arXiv:2501.04421 (January 2025)", "source": "core\\rl\\distributional_qrdqn.py", "category": "risk"}
{"instruction": "What is the QuantileNetwork class and how do I use it?", "input": "", "output": "The QuantileNetwork class:\n\nNeural network that outputs quantile values for each action.\n\nFor N quantiles and M actions, outputs N×M values representing\nthe distribution of returns for each action.", "source": "core\\rl\\distributional_qrdqn.py", "category": "general"}
{"instruction": "What is the QR_DQN_Agent class and how do I use it?", "input": "", "output": "The QR_DQN_Agent class:\n\nQuantile Regression Deep Q-Network for trading.\n\nModels the full distribution of returns instead of just expected value.\nThis enables better risk management and exploitation of tail events.\n\nMathematical Framework:\n    - Model value distribution via quantiles: θ_i represents τ_i-quantile\n    - Quantile Huber loss: L(θ) = E[ρ_τ^κ(δ_t)]\n    - Fixed uniform quantile fractions: τ_i = i/N for i=1,...,N\n\nExample:\n    >>> agent = QR_DQN_Agent(state_dim=575, action_dim=3, num_quantiles=200)\n    >>> state = torch.randn(1, 575)\n    >>> action = agent.act(state, epsilon=0.1)\n    >>> # After executing action and observing reward:\n    >>> agent.update(state, action, reward, next_state, done)", "source": "core\\rl\\distributional_qrdqn.py", "category": "risk"}
{"instruction": "Show me a code example for QR_DQN_Agent", "input": "", "output": ">>> agent = QR_DQN_Agent(state_dim=575, action_dim=3, num_quantiles=200)\n    >>> state = torch.randn(1, 575)\n    >>> action = agent.act(state, epsilon=0.1)\n    >>> # After executing action and observing reward:\n    >>> agent.update(state, action, reward, next_state, done)", "source": "core\\rl\\distributional_qrdqn.py", "category": "risk"}
{"instruction": "What is the QR_DQN_TradingWrapper class and how do I use it?", "input": "", "output": "The QR_DQN_TradingWrapper class:\n\nWrapper to integrate QR-DQN with existing HFT trading bot.\n\nMaps continuous forex features to discrete actions and back.", "source": "core\\rl\\distributional_qrdqn.py", "category": "rl"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nArgs:\n    state: (batch, state_dim)\n\nReturns:\n    quantiles: (batch, action_dim, num_quantiles)", "source": "core\\rl\\distributional_qrdqn.py", "category": "regime"}
{"instruction": "What is the formula for Act?", "input": "", "output": "Select action using epsilon-greedy policy based on expected Q-value.\n\nExpected Q-value = mean of quantile values (center of distribution)\n\nArgs:\n    state: (state_dim,) or (1, state_dim)\n    epsilon: Exploration rate\n\nReturns:\n    action: Integer action index", "source": "core\\rl\\distributional_qrdqn.py", "category": "regime"}
{"instruction": "Explain the Act function", "input": "", "output": "Function: act\n\nSelect action using epsilon-greedy policy based on expected Q-value.\n\nExpected Q-value = mean of quantile values (center of distribution)\n\nArgs:\n    state: (state_dim,) or (1, state_dim)\n    epsilon: Exploration rate\n\nReturns:\n    action: Integer action index", "source": "core\\rl\\distributional_qrdqn.py", "category": "regime"}
{"instruction": "What is the formula for Get Risk Sensitive Action?", "input": "", "output": "Select action using CVaR (Conditional Value at Risk).\n\nInstead of maximizing expected return, maximize CVaR_α\nwhere α is the risk level (e.g., 0.95 for 95th percentile).\n\nArgs:\n    state: (state_dim,) or (1, state_dim)\n    risk_level: Confidence level (0.95 = optimize for worst 5% outcomes)\n\nReturns:\n    action: Integer action index", "source": "core\\rl\\distributional_qrdqn.py", "category": "risk"}
{"instruction": "Explain the Get Risk Sensitive Action function", "input": "", "output": "Function: get_risk_sensitive_action\n\nSelect action using CVaR (Conditional Value at Risk).\n\nInstead of maximizing expected return, maximize CVaR_α\nwhere α is the risk level (e.g., 0.95 for 95th percentile).\n\nArgs:\n    state: (state_dim,) or (1, state_dim)\n    risk_level: Confidence level (0.95 = optimize for worst 5% outcomes)\n\nReturns:\n    action: Integer action index", "source": "core\\rl\\distributional_qrdqn.py", "category": "risk"}
{"instruction": "What is the formula for Quantile Huber Loss?", "input": "", "output": "Quantile Huber loss for QR-DQN.\n\nMathematical Formula:\n    ρ_τ^κ(u) = |τ - 1_{u<0}| * κ_τ(u) / κ\n\n    where κ_τ(u) = {\n        0.5 * u^2,           if |u| ≤ κ\n        κ * (|u| - 0.5*κ),  otherwise\n    }\n\nArgs:\n    pred: Predicted quantile values (batch, num_quantiles)\n    target: Target quantile values (batch, num_quantiles)\n    tau: Quantile fractions (num_quantiles,)\n\nReturns:\n    loss: Scalar loss value", "source": "core\\rl\\distributional_qrdqn.py", "category": "rl"}
{"instruction": "Explain the Quantile Huber Loss function", "input": "", "output": "Function: quantile_huber_loss\n\nQuantile Huber loss for QR-DQN.\n\nMathematical Formula:\n    ρ_τ^κ(u) = |τ - 1_{u<0}| * κ_τ(u) / κ\n\n    where κ_τ(u) = {\n        0.5 * u^2,           if |u| ≤ κ\n        κ * (|u| - 0.5*κ),  otherwise\n    }\n\nArgs:\n    pred: Predicted quantile values (batch, num_quantiles)\n    target: Target quantile values (batch, num_quantiles)\n    tau: Quantile fractions (num_quantiles,)\n\nReturns:\n    loss: Scalar loss value", "source": "core\\rl\\distributional_qrdqn.py", "category": "rl"}
{"instruction": "What is DQN in quantitative trading?", "input": "", "output": "DQN (Deep Q-Network for trading).\n\nImplementation details:\nQuantile Huber loss for QR-DQN.\n\nMathematical Formula:\n    ρ_τ^κ(u) = |τ - 1_{u<0}| * κ_τ(u) / κ\n\n    where κ_τ(u) = {\n        0.5 * u^2,           if |u| ≤ κ\n        κ * (|u| - 0.5*κ),  otherwise\n    }\n\nArgs:\n    pred: Predicted quantile values (batch, num_quantiles)\n    target: Target quantile values (batch, num_quantiles)\n    tau: Quantile fractions (num_quantiles,)\n\nReturns:\n    loss: Scalar loss value", "source": "core\\rl\\distributional_qrdqn.py", "category": "rl"}
{"instruction": "Explain the Update function", "input": "", "output": "Function: update\n\nStore transition and perform learning update.\n\nArgs:\n    state: Current state\n    action: Action taken\n    reward: Reward received\n    next_state: Next state\n    done: Whether episode ended", "source": "core\\rl\\distributional_qrdqn.py", "category": "regime"}
{"instruction": "Explain the Save function", "input": "", "output": "Function: save\n\nSave model weights.", "source": "core\\rl\\distributional_qrdqn.py", "category": "general"}
{"instruction": "Explain the Load function", "input": "", "output": "Function: load\n\nLoad model weights.", "source": "core\\rl\\distributional_qrdqn.py", "category": "general"}
{"instruction": "What is the formula for Predict?", "input": "", "output": "Generate trading signal from features.\n\nArgs:\n    features: (575,) array of features\n    risk_level: If provided, use CVaR-based action selection\n\nReturns:\n    signal: -1 (sell), 0 (hold), +1 (buy)\n    action_name: 'SELL', 'HOLD', or 'BUY'", "source": "core\\rl\\distributional_qrdqn.py", "category": "alpha"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nGenerate trading signal from features.\n\nArgs:\n    features: (575,) array of features\n    risk_level: If provided, use CVaR-based action selection\n\nReturns:\n    signal: -1 (sell), 0 (hold), +1 (buy)\n    action_name: 'SELL', 'HOLD', or 'BUY'", "source": "core\\rl\\distributional_qrdqn.py", "category": "alpha"}
{"instruction": "What is the formula for Learn?", "input": "", "output": "Update agent from trading experience.\n\nArgs:\n    features: Current state features\n    action: Action taken (-1, 0, or 1)\n    reward: Realized PnL or return\n    next_features: Next state features\n    done: Whether episode ended", "source": "core\\rl\\distributional_qrdqn.py", "category": "rl"}
{"instruction": "Explain the Learn function", "input": "", "output": "Function: learn\n\nUpdate agent from trading experience.\n\nArgs:\n    features: Current state features\n    action: Action taken (-1, 0, or 1)\n    reward: Realized PnL or return\n    next_features: Next state features\n    done: Whether episode ended", "source": "core\\rl\\distributional_qrdqn.py", "category": "rl"}
{"instruction": "Explain the purpose of RL Agent Ensemble Methods", "input": "", "output": "RL Agent Ensemble Methods\n\nAcademic Citations:\n══════════════════════════════════════════════════════════════════════════════\n\nEnsemble RL:\n    Osband et al. (2016)\n    \"Deep Exploration via Bootstrapped DQN\"\n    NeurIPS 2016\n\n    Chen et al. (2017)\n    \"UCB Exploration via Q-Ensembles\"\n    arXiv:1706.01502\n\nTournament Selection (ElegantRL):\n    Liu et al. (2021)\n    \"Massively Parallel Deep Reinforcement Learning\"\n    ICAIF 2021\n    GitHub: AI4Finance-Foundation/ElegantRL\n\n    Key Innovation: Tournament-based ensemble that selects best-performing\n    agents from parallel training runs.\n\nEnsemble Distillation:\n    Rusu et al. (2016)\n    \"Policy Distillation\"\n    ICLR 2016\n\n    Hinton et al. (2015)\n    \"Distilling the Knowledge in a Neural Network\"\n    NeurIPS Workshop\n\n══════════════════════════════════════════════════════════════════════════════\nElegantRL Ensemble achieves:\n- 89.2% cumulative return\n- 1.95 Sharpe ratio\n- -8.7% max drawdown\n\nBy using tournament selection across parallel training runs.\n══════════════════════════════════════════════════════════════════════════════", "source": "core\\rl\\ensemble.py", "category": "risk"}
{"instruction": "What is the EnsembleConfig class and how do I use it?", "input": "", "output": "The EnsembleConfig class:\n\nConfiguration for RL Ensemble.\n\nBased on ElegantRL tournament selection.", "source": "core\\rl\\ensemble.py", "category": "rl"}
{"instruction": "What is the RLEnsemble class and how do I use it?", "input": "", "output": "The RLEnsemble class:\n\nBasic RL Ensemble with multiple voting methods.\n\nReference:\n    Osband et al. (2016)\n    \"Deep Exploration via Bootstrapped DQN\"\n\nMethods:\n- Mean: Average actions across all agents\n- Median: Median action (robust to outliers)\n- Vote: Majority vote (for discrete actions)\n- UCB: Upper Confidence Bound selection", "source": "core\\rl\\ensemble.py", "category": "rl"}
{"instruction": "What is the TournamentEnsemble class and how do I use it?", "input": "", "output": "The TournamentEnsemble class:\n\nTournament-based Ensemble (ElegantRL style).\n\nReference:\n    Liu et al. (2021)\n    \"Massively Parallel Deep Reinforcement Learning\"\n    ICAIF 2021\n\nKey innovation: Parallel training of multiple agents with periodic\ntournament selection to keep only the best performers.\n\nTournament process:\n1. Train N agents in parallel\n2. Every K steps, evaluate all agents\n3. Replace worst agents with mutations of best agents\n4. Continue training\n\nThis achieves 3-7x speedup over single-agent training.", "source": "core\\rl\\ensemble.py", "category": "rl"}
{"instruction": "What is the DistilledEnsemble class and how do I use it?", "input": "", "output": "The DistilledEnsemble class:\n\nEnsemble with knowledge distillation.\n\nReference:\n    Rusu et al. (2016)\n    \"Policy Distillation\"\n    ICLR 2016\n\nDistills knowledge from multiple teacher agents into a single\nstudent agent, combining their expertise.", "source": "core\\rl\\ensemble.py", "category": "rl"}
{"instruction": "Explain the Create Rl Ensemble function", "input": "", "output": "Function: create_rl_ensemble\n\nFactory function to create RL ensemble.\n\nArgs:\n    env: Training environment\n    config: Ensemble configuration\n    agent_config: Agent configuration\n    ensemble_type: 'basic', 'tournament', or 'distilled'\n\nReturns:\n    RL ensemble", "source": "core\\rl\\ensemble.py", "category": "alpha"}
{"instruction": "Explain the Select Action function", "input": "", "output": "Function: select_action\n\nSelect action using ensemble voting.\n\nArgs:\n    state: Current state\n    deterministic: If True, use deterministic actions\n\nReturns:\n    Ensemble action", "source": "core\\rl\\ensemble.py", "category": "regime"}
{"instruction": "Explain the Update Rewards function", "input": "", "output": "Function: update_rewards\n\nUpdate reward tracking for UCB.", "source": "core\\rl\\ensemble.py", "category": "general"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nPredict action (alias for select_action).", "source": "core\\rl\\ensemble.py", "category": "general"}
{"instruction": "Explain the Evaluate Agent function", "input": "", "output": "Function: evaluate_agent\n\nEvaluate agent performance.\n\nReturns average episode return.", "source": "core\\rl\\ensemble.py", "category": "rl"}
{"instruction": "Explain the Tournament Selection function", "input": "", "output": "Function: tournament_selection\n\nPerform tournament selection.\n\nReturns indices of agents to keep.", "source": "core\\rl\\ensemble.py", "category": "rl"}
{"instruction": "Explain the Mutate Agent function", "input": "", "output": "Function: mutate_agent\n\nCreate mutated copy of agent.\n\nAdds Gaussian noise to network weights.", "source": "core\\rl\\ensemble.py", "category": "rl"}
{"instruction": "Explain the Evolve function", "input": "", "output": "Function: evolve\n\nPerform one evolution step.\n\n1. Tournament selection\n2. Replace losers with mutations of winners", "source": "core\\rl\\ensemble.py", "category": "volatility"}
{"instruction": "Explain the Train function", "input": "", "output": "Function: train\n\nTrain ensemble with tournament selection.\n\nArgs:\n    total_timesteps: Total training steps\n    callback: Optional callback function", "source": "core\\rl\\ensemble.py", "category": "ensemble"}
{"instruction": "Explain the Get Best Agent function", "input": "", "output": "Function: get_best_agent\n\nGet the best performing agent.", "source": "core\\rl\\ensemble.py", "category": "rl"}
{"instruction": "Explain the Select Action function", "input": "", "output": "Function: select_action\n\nSelect action using best agent.", "source": "core\\rl\\ensemble.py", "category": "rl"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nPredict action (alias for select_action).", "source": "core\\rl\\ensemble.py", "category": "general"}
{"instruction": "What is the formula for Distill Step?", "input": "", "output": "Perform one distillation step.\n\nReference: Hinton et al. (2015)\n\"Distilling the Knowledge in a Neural Network\"\n\nLoss = KL(student || teacher_ensemble)", "source": "core\\rl\\ensemble.py", "category": "ensemble"}
{"instruction": "Explain the Distill Step function", "input": "", "output": "Function: distill_step\n\nPerform one distillation step.\n\nReference: Hinton et al. (2015)\n\"Distilling the Knowledge in a Neural Network\"\n\nLoss = KL(student || teacher_ensemble)", "source": "core\\rl\\ensemble.py", "category": "ensemble"}
{"instruction": "What is the formula for Train?", "input": "", "output": "Train student via distillation + environment interaction.\n\nCombines:\n1. Distillation loss from teachers\n2. Standard RL loss from environment", "source": "core\\rl\\ensemble.py", "category": "rl"}
{"instruction": "Explain the Train function", "input": "", "output": "Function: train\n\nTrain student via distillation + environment interaction.\n\nCombines:\n1. Distillation loss from teachers\n2. Standard RL loss from environment", "source": "core\\rl\\ensemble.py", "category": "rl"}
{"instruction": "Explain the Select Action function", "input": "", "output": "Function: select_action\n\nSelect action using distilled student.", "source": "core\\rl\\ensemble.py", "category": "general"}
{"instruction": "Explain the purpose of Dynamic Ensemble of RL Agents for Trading", "input": "", "output": "Dynamic Ensemble of RL Agents for Trading\n==========================================\nCombines multiple RL algorithms with performance-based weighting.\n\nMathematical Formula:\n    π_ensemble(a|s) = Σ w_i(s) π_i(a|s)\n    w_i(s) = exp(β·Sharpe_i) / Σ exp(β·Sharpe_j)\n\nExpected Improvement: +7-12% accuracy (63% → 70-75%)\n\nReferences:\n    1. \"Deep RL for Automated Stock Trading: An Ensemble Strategy\"\n       arXiv:2511.12120 (November 2024)\n\n    2. \"Learning the Market: Sentiment-Based Ensemble Trading Agents\"\n       arXiv:2402.01441 (February 2024)\n\nKey Findings:\n    - Ensemble strategy inherits and integrates best features\n    - Robustly adjusts to different market situations\n    - Outperforms individual algorithms in risk-adjusted returns\n    - Dynamic agent switching is superior to fixed-period switching", "source": "core\\rl\\ensemble_dynamic.py", "category": "risk"}
{"instruction": "What is the AgentPerformance class and how do I use it?", "input": "", "output": "The AgentPerformance class:\n\nTrack performance metrics for an agent.", "source": "core\\rl\\ensemble_dynamic.py", "category": "rl"}
{"instruction": "What is the AgentType class and how do I use it?", "input": "", "output": "The AgentType class:\n\nTypes of RL agents in ensemble.", "source": "core\\rl\\ensemble_dynamic.py", "category": "rl"}
{"instruction": "What is the RLAgentBase class and how do I use it?", "input": "", "output": "The RLAgentBase class:\n\nBase class for RL agents.\n\nAll agents must implement:\n    - act(state) -> action\n    - update(state, action, reward, next_state, done)", "source": "core\\rl\\ensemble_dynamic.py", "category": "rl"}
{"instruction": "What is the DynamicEnsemble class and how do I use it?", "input": "", "output": "The DynamicEnsemble class:\n\nDynamic ensemble of RL agents with performance-based weighting.\n\nAgents vote on actions with weights proportional to recent Sharpe ratio.\nSuperior to fixed-period agent switching.\n\nMathematical Framework:\n    π_ensemble(a|s) = Σ_i w_i(s) π_i(a|s)\n\n    where weights are:\n    w_i(s) = exp(β·Sharpe_i) / Σ_j exp(β·Sharpe_j)\n\nExample:\n    >>> agents = [PPO_Agent(), SAC_Agent(), TD3_Agent(), A2C_Agent(), DDPG_Agent()]\n    >>> ensemble = DynamicEnsemble(agents, beta=2.0)\n    >>> action = ensemble.act(state)\n    >>> ensemble.update(state, action, reward, next_state, done)", "source": "core\\rl\\ensemble_dynamic.py", "category": "risk"}
{"instruction": "Show me a code example for DynamicEnsemble", "input": "", "output": ">>> agents = [PPO_Agent(), SAC_Agent(), TD3_Agent(), A2C_Agent(), DDPG_Agent()]\n    >>> ensemble = DynamicEnsemble(agents, beta=2.0)\n    >>> action = ensemble.act(state)\n    >>> ensemble.update(state, action, reward, next_state, done)", "source": "core\\rl\\ensemble_dynamic.py", "category": "risk"}
{"instruction": "What is the SentimentBasedEnsemble class and how do I use it?", "input": "", "output": "The SentimentBasedEnsemble class:\n\nEnsemble with sentiment-based agent selection.\n\nKey Finding from arXiv:2402.01441 (Feb 2024):\n    \"Results in a strategy that is profitable, robust, and risk-minimal –\n     outperforming traditional ensemble as well as single agents\"\n\nConventional practice of switching agents every fixed number of months is sub-optimal.\nDynamic switching based on market sentiment performs better.", "source": "core\\rl\\ensemble_dynamic.py", "category": "risk"}
{"instruction": "What is the EnsembleRLTrader class and how do I use it?", "input": "", "output": "The EnsembleRLTrader class:\n\nWrapper to integrate ensemble RL with HFT trading bot.\n\nCombines 5 RL agents: PPO, SAC, TD3, A2C, DDPG\nDynamic weighting based on Sharpe ratio", "source": "core\\rl\\ensemble_dynamic.py", "category": "risk"}
{"instruction": "What is the formula for Act?", "input": "", "output": "Select action given state.\n\nArgs:\n    state: Current state (features)\n    deterministic: If True, select greedy action\n\nReturns:\n    action: Continuous action in [-1, 1] (position size)", "source": "core\\rl\\ensemble_dynamic.py", "category": "regime"}
{"instruction": "Explain the Act function", "input": "", "output": "Function: act\n\nSelect action given state.\n\nArgs:\n    state: Current state (features)\n    deterministic: If True, select greedy action\n\nReturns:\n    action: Continuous action in [-1, 1] (position size)", "source": "core\\rl\\ensemble_dynamic.py", "category": "regime"}
{"instruction": "Explain the Update function", "input": "", "output": "Function: update\n\nUpdate agent from experience.", "source": "core\\rl\\ensemble_dynamic.py", "category": "rl"}
{"instruction": "What is the formula for Act?", "input": "", "output": "Get ensemble action as weighted average of individual agents.\n\nArgs:\n    state: Current state (features)\n    deterministic: If True, use greedy actions\n    return_weights: If True, return agent weights\n\nReturns:\n    action: Continuous action in [-1, 1]\n    weights: (optional) Agent weights used", "source": "core\\rl\\ensemble_dynamic.py", "category": "rl"}
{"instruction": "Explain the Act function", "input": "", "output": "Function: act\n\nGet ensemble action as weighted average of individual agents.\n\nArgs:\n    state: Current state (features)\n    deterministic: If True, use greedy actions\n    return_weights: If True, return agent weights\n\nReturns:\n    action: Continuous action in [-1, 1]\n    weights: (optional) Agent weights used", "source": "core\\rl\\ensemble_dynamic.py", "category": "rl"}
{"instruction": "What is the formula for Get Best Agent Action?", "input": "", "output": "Get action from currently best-performing agent.\n\nReturns:\n    action: Action from best agent\n    agent_idx: Index of best agent\n    agent_name: Name of best agent", "source": "core\\rl\\ensemble_dynamic.py", "category": "rl"}
{"instruction": "Explain the Get Best Agent Action function", "input": "", "output": "Function: get_best_agent_action\n\nGet action from currently best-performing agent.\n\nReturns:\n    action: Action from best agent\n    agent_idx: Index of best agent\n    agent_name: Name of best agent", "source": "core\\rl\\ensemble_dynamic.py", "category": "rl"}
{"instruction": "Explain the Update function", "input": "", "output": "Function: update\n\nUpdate all agents and track performance.\n\nArgs:\n    state: Current state\n    action: Ensemble action taken\n    reward: Reward received\n    next_state: Next state\n    done: Episode done flag\n    individual_actions: (optional) Actions from each agent if already computed", "source": "core\\rl\\ensemble_dynamic.py", "category": "rl"}
{"instruction": "Explain the Get Performance Summary function", "input": "", "output": "Function: get_performance_summary\n\nGet performance summary for ensemble and individual agents.\n\nReturns:\n    summary: Dict with performance metrics", "source": "core\\rl\\ensemble_dynamic.py", "category": "rl"}
{"instruction": "Explain the Save function", "input": "", "output": "Function: save\n\nSave ensemble and all agents.", "source": "core\\rl\\ensemble_dynamic.py", "category": "rl"}
{"instruction": "Explain the Load function", "input": "", "output": "Function: load\n\nLoad ensemble and all agents.", "source": "core\\rl\\ensemble_dynamic.py", "category": "rl"}
{"instruction": "What is the formula for Update Sentiment?", "input": "", "output": "Update market sentiment score.\n\nArgs:\n    market_sentiment: Score in [-1, 1] where:\n        -1 = very bearish\n         0 = neutral\n        +1 = very bullish", "source": "core\\rl\\ensemble_dynamic.py", "category": "general"}
{"instruction": "Explain the Update Sentiment function", "input": "", "output": "Function: update_sentiment\n\nUpdate market sentiment score.\n\nArgs:\n    market_sentiment: Score in [-1, 1] where:\n        -1 = very bearish\n         0 = neutral\n        +1 = very bullish", "source": "core\\rl\\ensemble_dynamic.py", "category": "general"}
{"instruction": "What is the formula for Predict?", "input": "", "output": "Generate trading signal from features.\n\nArgs:\n    features: (575,) array\n\nReturns:\n    signal: -1 (sell), 0 (hold), 1 (buy)\n    confidence: Strength of signal [0, 1]", "source": "core\\rl\\ensemble_dynamic.py", "category": "alpha"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nGenerate trading signal from features.\n\nArgs:\n    features: (575,) array\n\nReturns:\n    signal: -1 (sell), 0 (hold), 1 (buy)\n    confidence: Strength of signal [0, 1]", "source": "core\\rl\\ensemble_dynamic.py", "category": "alpha"}
{"instruction": "Explain the Learn function", "input": "", "output": "Function: learn\n\nUpdate ensemble from experience.", "source": "core\\rl\\ensemble_dynamic.py", "category": "ensemble"}
{"instruction": "Explain the Get Summary function", "input": "", "output": "Function: get_summary\n\nGet performance summary.", "source": "core\\rl\\ensemble_dynamic.py", "category": "general"}
{"instruction": "Explain the purpose of Forex Trading Environments for Reinforcement Learning", "input": "", "output": "Forex Trading Environments for Reinforcement Learning\n\nAcademic Citations:\n══════════════════════════════════════════════════════════════════════════════\n\n1. OpenAI Gym Interface:\n   Brockman et al. (2016)\n   \"OpenAI Gym\"\n   arXiv:1606.01540\n\n2. FinRL Environment Design:\n   Liu et al. (2020)\n   \"FinRL: A Deep Reinforcement Learning Library for Automated Stock Trading\"\n   NeurIPS Deep RL Workshop\n   GitHub: AI4Finance-Foundation/FinRL\n\n3. Multi-Asset Portfolio Environment:\n   Jiang et al. (2017)\n   \"Deep Reinforcement Learning for Portfolio Management\"\n   arXiv:1706.10059\n\n4. Transaction Cost Modeling:\n   Almgren & Chriss (2001)\n   \"Optimal Execution of Portfolio Transactions\"\n   Journal of Risk, 3(2), 5-39\n\n5. Market Impact:\n   Kyle (1985)\n   \"Continuous Auctions and Insider Trading\"\n   Econometrica, 53(6), 1315-1335\n\n══════════════════════════════════════════════════════════════════════════════", "source": "core\\rl\\environments.py", "category": "risk"}
{"instruction": "What is the ForexTradingEnvConfig class and how do I use it?", "input": "", "output": "The ForexTradingEnvConfig class:\n\nConfiguration for Forex Trading Environment.\n\nBased on FinRL configuration patterns.\nReference: Liu et al. (2020), NeurIPS Deep RL Workshop", "source": "core\\rl\\environments.py", "category": "rl"}
{"instruction": "What is the ForexTradingEnv class and how do I use it?", "input": "", "output": "The ForexTradingEnv class:\n\nSingle-Asset Forex Trading Environment.\n\nImplements OpenAI Gym interface for RL training.\n\nAcademic References:\n- Brockman et al. (2016): OpenAI Gym interface\n- Liu et al. (2020): FinRL environment design\n- Almgren & Chriss (2001): Transaction cost modeling\n\nState Space:\n    - OHLCV features (normalized)\n    - Technical indicators (from feature engine)\n    - Current position\n    - Unrealized PnL\n    - Time features (hour, day_of_week)\n\nAction Space:\n    Continuous: [-1, 1] where -1 = full short, 0 = flat, 1 = full long\n    Discrete: {-1.0, -0.8, ..., 0.8, 1.0}\n\nReward:\n    Differential Sharpe Ratio (Moody & Saffell, 2001)\n    r_t = (R_t - R_f) / σ_t - λ * |Δposition| * cost", "source": "core\\rl\\environments.py", "category": "risk"}
{"instruction": "What is the MultiAssetForexEnv class and how do I use it?", "input": "", "output": "The MultiAssetForexEnv class:\n\nMulti-Asset Forex Portfolio Environment.\n\nExtends single-asset environment to handle multiple currency pairs\nwith correlation-aware position sizing.\n\nAcademic References:\n- Jiang et al. (2017): \"Deep Reinforcement Learning for Portfolio Management\"\n- Moody & Saffell (2001): \"Learning to Trade via Direct Reinforcement\"\n- Markowitz (1952): Portfolio Selection (for correlation handling)\n\nState Space:\n    - Per-asset features (normalized)\n    - Current positions (n_assets)\n    - Correlation matrix (flattened upper triangle)\n    - Portfolio-level metrics (total value, drawdown)\n\nAction Space:\n    Continuous: Box(-1, 1, shape=(n_assets,))\n    Target portfolio weights for each asset", "source": "core\\rl\\environments.py", "category": "risk"}
{"instruction": "What is the formula for Create Forex Env?", "input": "", "output": "Factory function to create Forex Trading Environment.\n\nArgs:\n    df: DataFrame with OHLCV + features\n    config: Environment configuration\n    feature_columns: Feature columns to use\n    **kwargs: Additional arguments passed to environment\n\nReturns:\n    ForexTradingEnv instance", "source": "core\\rl\\environments.py", "category": "alpha"}
{"instruction": "Explain the Create Forex Env function", "input": "", "output": "Function: create_forex_env\n\nFactory function to create Forex Trading Environment.\n\nArgs:\n    df: DataFrame with OHLCV + features\n    config: Environment configuration\n    feature_columns: Feature columns to use\n    **kwargs: Additional arguments passed to environment\n\nReturns:\n    ForexTradingEnv instance", "source": "core\\rl\\environments.py", "category": "alpha"}
{"instruction": "Explain the Step function", "input": "", "output": "Function: step\n\nExecute one step in the environment.\n\nArgs:\n    action: Trading action (position target)\n\nReturns:\n    observation, reward, terminated, truncated, info", "source": "core\\rl\\environments.py", "category": "general"}
{"instruction": "Explain the Reset function", "input": "", "output": "Function: reset\n\nReset environment to initial state.", "source": "core\\rl\\environments.py", "category": "regime"}
{"instruction": "Explain the Render function", "input": "", "output": "Function: render\n\nRender environment state.", "source": "core\\rl\\environments.py", "category": "regime"}
{"instruction": "What is the formula for Step?", "input": "", "output": "Execute one step with multi-asset portfolio rebalancing.", "source": "core\\rl\\environments.py", "category": "general"}
{"instruction": "Explain the Step function", "input": "", "output": "Function: step\n\nExecute one step with multi-asset portfolio rebalancing.", "source": "core\\rl\\environments.py", "category": "general"}
{"instruction": "Explain the Reset function", "input": "", "output": "Function: reset\n\nReset environment.", "source": "core\\rl\\environments.py", "category": "general"}
{"instruction": "Explain the purpose of Graph Neural Network Reinforcement Learning for Trading (Chinese Innovation)", "input": "", "output": "Graph Neural Network Reinforcement Learning for Trading (Chinese Innovation)\n\n图神经网络强化学习 - 中国量化创新\n\nAcademic Citations:\n══════════════════════════════════════════════════════════════════════════════\n\nCHINESE RESEARCH (图神经网络 + 强化学习):\n\n1. GraphMIX:\n   Chinese researchers extended QMIX with GNN + Attention\n   《多智能体深度强化学习及其可扩展性与可迁移性研究综述》\n   控制与决策, 2022, Vol.37, No.12\n   Key: GNN + 注意力机制 for value decomposition and credit assignment\n\n2. Hierarchical GAT (分层图注意力网络):\n   Chinese scholars proposed hierarchical GAT for multi-agent state representation\n   - 群组间注意力网络 (inter-group attention)\n   - 个体间注意力网络 (intra-group attention)\n   Result: Improved policy scalability\n\n3. GNN for Stock Relation:\n   Chen et al. (2021)\n   \"Graph Neural Network for Stock Movement Prediction\"\n   清华大学\n   Model stock correlations as graph structure\n\nINTERNATIONAL FOUNDATIONS:\n\n4. GAT (Graph Attention Networks):\n   Veličković et al. (2018)\n   \"Graph Attention Networks\"\n   ICLR 2018\n\n5. GCN (Graph Convolutional Networks):\n   Kipf & Welling (2017)\n   \"Semi-Supervised Classification with GCN\"\n   ICLR 2017\n\n6. DGN (Deep Graph Networks for MARL):\n   Jiang et al. (2020)\n   \"Graph Convolutional Reinforcement Learning\"\n   ICLR 2020\n\n7. Relational RL:\n   Zambaldi et al. (2019)\n   \"Relational Deep Reinforcement Learning\"\n   ICLR 2019 (DeepMind)\n\n══════════════════════════════════════════════════════════════════════════════\nKEY INNOVATIONS:\n- Model asset correlations as graph structure\n- GNN message passing for information aggregation\n- Attention mechanism for dynamic edge weighting\n- Scalable to large portfolios (78+ forex pairs)\n══════════════════════════════════════════════════════════════════════════════", "source": "core\\rl\\graph_rl.py", "category": "volatility"}
{"instruction": "What is the GraphRLConfig class and how do I use it?", "input": "", "output": "The GraphRLConfig class:\n\nConfiguration for Graph RL.\n\nBased on Chinese GNN + RL research.", "source": "core\\rl\\graph_rl.py", "category": "rl"}
{"instruction": "What is the GraphAttentionLayer class and how do I use it?", "input": "", "output": "The GraphAttentionLayer class:\n\nGraph Attention Layer (GAT).\n\nReference:\n    Veličković et al. (2018)\n    \"Graph Attention Networks\"\n    ICLR 2018\n\nComputes attention-weighted message passing on graph.", "source": "core\\rl\\graph_rl.py", "category": "general"}
{"instruction": "What is the GraphConvLayer class and how do I use it?", "input": "", "output": "The GraphConvLayer class:\n\nGraph Convolutional Layer (GCN).\n\nReference:\n    Kipf & Welling (2017)\n    \"Semi-Supervised Classification with GCN\"\n    ICLR 2017", "source": "core\\rl\\graph_rl.py", "category": "volatility"}
{"instruction": "What is the HierarchicalGAT class and how do I use it?", "input": "", "output": "The HierarchicalGAT class:\n\nHierarchical Graph Attention Network (分层图注意力网络).\n\nChinese Innovation:\n    分层GAT模型包含:\n    - 群组间注意力网络 (inter-group attention)\n    - 个体间注意力网络 (intra-group attention)\n\nUsed for learning multi-agent state representation with improved scalability.", "source": "core\\rl\\graph_rl.py", "category": "rl"}
{"instruction": "What is the GraphMIX class and how do I use it?", "input": "", "output": "The GraphMIX class:\n\nGraphMIX: QMIX with Graph Neural Networks.\n\nChinese Innovation:\n    在QMIX算法基础上引入GNN和注意力机制解决值函数分解和多智能体信用分配问题\n\nReference:\n    Extended from Rashid et al. (2018) QMIX\n    Chinese extension: GNN for agent communication graph", "source": "core\\rl\\graph_rl.py", "category": "rl"}
{"instruction": "What is the GraphRLAgent class and how do I use it?", "input": "", "output": "The GraphRLAgent class:\n\nGraph RL Agent for Multi-Asset Trading.\n\nUses GNN to model asset correlations and learn trading policy.", "source": "core\\rl\\graph_rl.py", "category": "rl"}
{"instruction": "Explain the Create Graph Rl Agent function", "input": "", "output": "Function: create_graph_rl_agent\n\nFactory function to create Graph RL agent.\n\nArgs:\n    n_assets: Number of assets\n    state_dim: State dimension\n    config: Graph RL configuration\n\nReturns:\n    GraphRLAgent instance", "source": "core\\rl\\graph_rl.py", "category": "alpha"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nForward pass with attention.\n\nArgs:\n    x: Node features (batch, n_nodes, in_features)\n    adj: Adjacency matrix\n\nReturns:\n    Updated node features", "source": "core\\rl\\graph_rl.py", "category": "general"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nHierarchical attention forward pass.\n\nArgs:\n    x: Node features\n    adj: Adjacency matrix\n    group_assignments: Which group each node belongs to\n\nReturns:\n    Updated node features with hierarchical attention", "source": "core\\rl\\graph_rl.py", "category": "general"}
{"instruction": "What is the formula for Forward?", "input": "", "output": "Forward pass with GNN communication.\n\nArgs:\n    agent_obs: Individual agent observations\n    global_state: Global state\n    adj: Agent communication adjacency matrix\n\nReturns:\n    Q_tot: Total Q-value", "source": "core\\rl\\graph_rl.py", "category": "rl"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nForward pass with GNN communication.\n\nArgs:\n    agent_obs: Individual agent observations\n    global_state: Global state\n    adj: Agent communication adjacency matrix\n\nReturns:\n    Q_tot: Total Q-value", "source": "core\\rl\\graph_rl.py", "category": "rl"}
{"instruction": "Explain the Update Correlation Graph function", "input": "", "output": "Function: update_correlation_graph\n\nUpdate adjacency matrix based on asset correlations.\n\nArgs:\n    returns: Asset returns (T, n_assets)", "source": "core\\rl\\graph_rl.py", "category": "general"}
{"instruction": "Explain the Select Action function", "input": "", "output": "Function: select_action\n\nSelect trading actions using GNN policy.", "source": "core\\rl\\graph_rl.py", "category": "general"}
{"instruction": "Explain the Get Value function", "input": "", "output": "Function: get_value\n\nGet state value estimate.", "source": "core\\rl\\graph_rl.py", "category": "regime"}
{"instruction": "What is the source paper for Primary?", "input": "", "output": "The source is: DeepSeek-AI (2025). ", "source": "core\\rl\\grpo_agent.py", "category": "alpha"}
{"instruction": "What is the source paper for Original GRPO?", "input": "", "output": "The source is: Shao et al. (2024). ", "source": "core\\rl\\grpo_agent.py", "category": "alpha"}
{"instruction": "What is the source paper for this technique?", "input": "", "output": "The source is: DeepSeek Founder Liang. ", "source": "core\\rl\\grpo_agent.py", "category": "alpha"}
{"instruction": "What is the source paper for research paper?", "input": "", "output": "The source is: arXiv:2501.12948. ", "source": "core\\rl\\grpo_agent.py", "category": "alpha"}
{"instruction": "What is the source paper for research paper?", "input": "", "output": "The source is: arXiv:2402.03300. ", "source": "core\\rl\\grpo_agent.py", "category": "alpha"}
{"instruction": "Explain the purpose of Group Relative Policy Optimization (GRPO) for Forex Trading", "input": "", "output": "Group Relative Policy Optimization (GRPO) for Forex Trading\n=============================================================\n\nACADEMIC CITATIONS:\n===================\n\nPrimary Paper:\n    DeepSeek-AI (2025)\n    \"DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via\n    Reinforcement Learning\"\n    arXiv:2501.12948\n    https://arxiv.org/abs/2501.12948\n\n    Key Innovation: GRPO forgoes the critic model (typically same size as\n    policy model) and estimates baseline from group scores instead.\n\nOriginal GRPO Paper:\n    Shao et al. (2024)\n    \"DeepSeekMath: Pushing the Limits of Mathematical Reasoning in Open\n    Language Models\"\n    arXiv:2402.03300\n    https://arxiv.org/abs/2402.03300\n\n    Key Innovation: GRPO enhances reasoning abilities while optimizing\n    memory usage compared to PPO by 50%+.\n\nRelated Work:\n    - \"Revisiting Group Relative Policy Optimization\" (2025) arXiv:2505.22257\n    - \"GRPO's Effective Loss, Dynamics, and Success Amplification\" (2025)\n      arXiv:2503.06639\n    - \"G2RPO-A: Guided Group Relative Policy Optimization\" (2025)\n      arXiv:2508.13023\n\nALGORITHM:\n==========\n\nFor each question/state, GRPO:\n1. Sample K outputs from old policy π_old\n2. Compute group advantage: A_i = R_i - mean(R_1...R_K)\n3. Optimize policy with clipped objective (like PPO but no value network)\n\nObjective:\n    L(θ) = E[ min(r(θ) * A, clip(r(θ), 1-ε, 1+ε) * A) ]\n\n    where:\n    - r(θ) = π_θ(a|s) / π_old(a|s)  (importance ratio)\n    - A = R - mean(R_group)  (group relative advantage)\n    - ε = clip ratio (typically 10 for GRPO vs 0.2 for PPO)\n\nHYPERPARAMETERS (from DeepSeek-R1):\n===================================\n    learning_rate: 3e-6\n    kl_coefficient: 0.001\n    clip_ratio: 10  (higher than PPO's 0.2)\n    sampling_temperature: 1.0\n    group_size: 16  (number of rollouts per state)\n    max_length: 32768 tokens (for LLM, adapt for trading)\n\nTRADING ADAPTATION:\n===================\n\nState: Market features (price, volume, indicators)\nAction: Trading decision (position size, direction)\nReward: PnL, Sharpe ratio, or custom objective\nGroup: 16 different trading decisions for same market state\n\nAdvantages over PPO for Trading:\n- No critic network → 50% less GPU memory\n- Better exploration via group sampling\n- More stable convergence in non-stationary markets\n- Group baseline adapts to regime changes\n\nUSAGE:\n======\n\n    from core.rl.grpo_agent import GRPOAgent, GRPOConfig\n\n    config = GRPOConfig(\n        state_dim=575,  # Your feature count\n        action_dim=3,   # [position_size, direction, hold_time]\n        learning_rate=3e-6,\n        clip_ratio=10,\n        group_size=16\n    )\n\n    agent = GRPOAgent(config)\n\n    # Training loop\n    for state in market_states:\n        # Sample group of actions\n        actions, log_probs = agent.sample_group(state, k=16)\n\n        # Execute and get rewards\n        rewards = [env.step(a) for a in actions]\n\n        # Update policy\n        loss = agent.update(state, actions, rewards, log_probs)\n\nCHINESE QUANT CONNECTION:\n=========================\n\nDeepSeek is built by High-Flyer Capital (幻方量化), one of China's top\nquant hedge funds. They applied GRPO to achieve:\n- 56.6% returns in 2025 (DeepSeek founder's fund)\n- Full AI automation (95%+ of signals from ML)\n- Cost-efficient training (10,000 A100 GPUs vs OpenAI's 100k+)\n\nSource: \"DeepSeek Founder Liang's Quant Empire Soars 57% in 2025\"\nhttps://www.fxleaders.com/news/2026/01/12/deepseek-founder-liangs-quant-empire-soars-57-in-2025-amid-chinas-quant-revival/", "source": "core\\rl\\grpo_agent.py", "category": "alpha"}
{"instruction": "What is the GRPOConfig class and how do I use it?", "input": "", "output": "The GRPOConfig class:\n\nConfiguration for GRPO Agent.\n\nBased on DeepSeek-R1 hyperparameters (arXiv:2501.12948).", "source": "core\\rl\\grpo_agent.py", "category": "rl"}
{"instruction": "What is the GRPOPolicyNetwork class and how do I use it?", "input": "", "output": "The GRPOPolicyNetwork class:\n\nPolicy network for GRPO.\n\nNo critic network needed (key difference from PPO).", "source": "core\\rl\\grpo_agent.py", "category": "rl"}
{"instruction": "What is the GRPOAgent class and how do I use it?", "input": "", "output": "The GRPOAgent class:\n\nGRPO Agent for Forex Trading.\n\nImplementation based on:\n    DeepSeek-R1 (arXiv:2501.12948)\n    DeepSeekMath (arXiv:2402.03300)", "source": "core\\rl\\grpo_agent.py", "category": "rl"}
{"instruction": "What is the formula for Create Grpo Agent?", "input": "", "output": "Create GRPO agent with DeepSeek-R1 hyperparameters.\n\nArgs:\n    state_dim: Number of input features\n    action_dim: Number of action dimensions\n    device: 'cuda' or 'cpu'\n\nReturns:\n    GRPOAgent instance", "source": "core\\rl\\grpo_agent.py", "category": "rl"}
{"instruction": "Explain the Create Grpo Agent function", "input": "", "output": "Function: create_grpo_agent\n\nCreate GRPO agent with DeepSeek-R1 hyperparameters.\n\nArgs:\n    state_dim: Number of input features\n    action_dim: Number of action dimensions\n    device: 'cuda' or 'cpu'\n\nReturns:\n    GRPOAgent instance", "source": "core\\rl\\grpo_agent.py", "category": "rl"}
{"instruction": "What is GRPO in quantitative trading?", "input": "", "output": "GRPO (Group Relative Policy Optimization for RL).\n\nImplementation details:\nCreate GRPO agent with DeepSeek-R1 hyperparameters.\n\nArgs:\n    state_dim: Number of input features\n    action_dim: Number of action dimensions\n    device: 'cuda' or 'cpu'\n\nReturns:\n    GRPOAgent instance", "source": "core\\rl\\grpo_agent.py", "category": "rl"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nForward pass.\n\nArgs:\n    state: (batch_size, state_dim)\n\nReturns:\n    mean: (batch_size, action_dim)\n    std: (batch_size, action_dim)", "source": "core\\rl\\grpo_agent.py", "category": "regime"}
{"instruction": "Explain the Get Action And Log Prob function", "input": "", "output": "Function: get_action_and_log_prob\n\nSample action and compute log probability.\n\nArgs:\n    state: (batch_size, state_dim)\n\nReturns:\n    action: (batch_size, action_dim)\n    log_prob: (batch_size,)", "source": "core\\rl\\grpo_agent.py", "category": "regime"}
{"instruction": "Explain the Sample Group function", "input": "", "output": "Function: sample_group\n\nSample K actions from current policy for same state.\n\nThis is the key GRPO operation: sample a GROUP of actions,\nthen use relative rewards for advantage estimation.\n\nArgs:\n    state: Market state (features)\n    k: Group size (default: config.group_size)\n\nReturns:\n    actions: List of K actions\n    log_probs: List of K log probabilities", "source": "core\\rl\\grpo_agent.py", "category": "rl"}
{"instruction": "What is GRPO in quantitative trading?", "input": "", "output": "GRPO (Group Relative Policy Optimization for RL).\n\nImplementation details:\nSample K actions from current policy for same state.\n\nThis is the key GRPO operation: sample a GROUP of actions,\nthen use relative rewards for advantage estimation.\n\nArgs:\n    state: Market state (features)\n    k: Group size (default: config.group_size)\n\nReturns:\n    actions: List of K actions\n    log_probs: List of K log probabilities", "source": "core\\rl\\grpo_agent.py", "category": "rl"}
{"instruction": "What is the formula for Update?", "input": "", "output": "GRPO update step.\n\nKey difference from PPO: Advantage is group-relative, no critic.\n\nArgs:\n    states: (batch_size, state_dim)\n    actions: (batch_size, action_dim)\n    rewards: (batch_size,)\n    old_log_probs: (batch_size,)\n    num_epochs: Number of update epochs\n\nReturns:\n    metrics: Dict with loss, kl, etc.", "source": "core\\rl\\grpo_agent.py", "category": "rl"}
{"instruction": "Explain the Update function", "input": "", "output": "Function: update\n\nGRPO update step.\n\nKey difference from PPO: Advantage is group-relative, no critic.\n\nArgs:\n    states: (batch_size, state_dim)\n    actions: (batch_size, action_dim)\n    rewards: (batch_size,)\n    old_log_probs: (batch_size,)\n    num_epochs: Number of update epochs\n\nReturns:\n    metrics: Dict with loss, kl, etc.", "source": "core\\rl\\grpo_agent.py", "category": "rl"}
{"instruction": "What is GRPO in quantitative trading?", "input": "", "output": "GRPO (Group Relative Policy Optimization for RL).\n\nImplementation details:\nGRPO update step.\n\nKey difference from PPO: Advantage is group-relative, no critic.\n\nArgs:\n    states: (batch_size, state_dim)\n    actions: (batch_size, action_dim)\n    rewards: (batch_size,)\n    old_log_probs: (batch_size,)\n    num_epochs: Number of update epochs\n\nReturns:\n    metrics: Dict with loss, kl, etc.", "source": "core\\rl\\grpo_agent.py", "category": "rl"}
{"instruction": "What is PPO in quantitative trading?", "input": "", "output": "PPO (Proximal Policy Optimization).\n\nImplementation details:\nGRPO update step.\n\nKey difference from PPO: Advantage is group-relative, no critic.\n\nArgs:\n    states: (batch_size, state_dim)\n    actions: (batch_size, action_dim)\n    rewards: (batch_size,)\n    old_log_probs: (batch_size,)\n    num_epochs: Number of update epochs\n\nReturns:\n    metrics: Dict with loss, kl, etc.", "source": "core\\rl\\grpo_agent.py", "category": "rl"}
{"instruction": "Explain the Save function", "input": "", "output": "Function: save\n\nSave model checkpoint.", "source": "core\\rl\\grpo_agent.py", "category": "general"}
{"instruction": "Explain the Load function", "input": "", "output": "Function: load\n\nLoad model checkpoint.", "source": "core\\rl\\grpo_agent.py", "category": "general"}
{"instruction": "Explain the purpose of Hierarchical Reinforcement Learning for Trading (分层强化学习)", "input": "", "output": "Hierarchical Reinforcement Learning for Trading (分层强化学习)\n\nAcademic Citations:\n══════════════════════════════════════════════════════════════════════════════\n\nCHINESE RESEARCH (分层强化学习):\n\n1. Multi-Agent Hierarchical RL Survey:\n   殷昌盛, 杨若鹏, 朱巍, 邹小飞, 李峰\n   《多智能体分层强化学习综述》\n   智能系统学报\n   Applications: 机器人控制, 博弈决策, 任务规划\n\n2. Hierarchical Trading:\n   Chinese researchers apply HRL to multi-timeframe trading:\n   - High level: Portfolio allocation (daily/weekly decisions)\n   - Low level: Order execution (intraday/tick-level)\n\n3. Options Framework in Trading:\n   清华大学 研究\n   Temporal abstraction for trading strategies\n\nINTERNATIONAL FOUNDATIONS:\n\n4. Option-Critic Architecture:\n   Bacon et al. (2017)\n   \"The Option-Critic Architecture\"\n   AAAI 2017\n   Key: End-to-end learning of options\n\n5. Feudal Networks (FuN):\n   Vezhnevets et al. (2017)\n   \"FeUdal Networks for Hierarchical Reinforcement Learning\"\n   ICML 2017 (DeepMind)\n   Key: Manager-Worker hierarchy\n\n6. HIRO:\n   Nachum et al. (2018)\n   \"Data-Efficient Hierarchical Reinforcement Learning\"\n   NeurIPS 2018 (Google Brain)\n   Key: Off-policy hierarchical learning\n\n7. HAM (Hierarchical Abstract Machines):\n   Parr & Russell (1998)\n   \"Reinforcement Learning with Hierarchies of Machines\"\n   NeurIPS 1998\n\n══════════════════════════════════════════════════════════════════════════════\nKEY INNOVATIONS FOR FOREX:\n- High-level: Which pairs to trade, overall position sizing\n- Low-level: Entry/exit timing, order execution\n- Options: Pre-defined trading strategies (trend-following, mean-reversion)\n══════════════════════════════════════════════════════════════════════════════", "source": "core\\rl\\hierarchical_rl.py", "category": "execution"}
{"instruction": "What is the HierarchicalConfig class and how do I use it?", "input": "", "output": "The HierarchicalConfig class:\n\nConfiguration for Hierarchical RL.\n\nBased on Chinese HRL research and Option-Critic architecture.", "source": "core\\rl\\hierarchical_rl.py", "category": "rl"}
{"instruction": "What is the ManagerNetwork class and how do I use it?", "input": "", "output": "The ManagerNetwork class:\n\nManager (High-Level) Network.\n\nReference:\n    Vezhnevets et al. (2017)\n    \"FeUdal Networks for Hierarchical RL\"\n    ICML 2017\n\nThe Manager operates at a slower timescale and sets goals/options\nfor the Worker to execute.\n\nFor trading:\n    - Decides which \"strategy\" to employ\n    - Sets position targets\n    - Operates on daily/4H timeframe", "source": "core\\rl\\hierarchical_rl.py", "category": "rl"}
{"instruction": "What is the WorkerNetwork class and how do I use it?", "input": "", "output": "The WorkerNetwork class:\n\nWorker (Low-Level) Network.\n\nThe Worker executes actions to achieve the goal set by the Manager.\n\nFor trading:\n    - Executes buy/sell/hold decisions\n    - Manages order execution\n    - Operates on 1H/tick timeframe", "source": "core\\rl\\hierarchical_rl.py", "category": "execution"}
{"instruction": "What is the OptionCritic class and how do I use it?", "input": "", "output": "The OptionCritic class:\n\nOption-Critic Architecture for Trading.\n\nReference:\n    Bacon et al. (2017)\n    \"The Option-Critic Architecture\"\n    AAAI 2017\n\nOptions represent high-level trading strategies:\n    - Option 0: Trend-following (buy strength, sell weakness)\n    - Option 1: Mean-reversion (fade extremes)\n    - Option 2: Breakout (trade volatility expansion)\n    - Option 3: Range-bound (trade within levels)\n\nEach option has:\n    - Intra-option policy: How to trade when option is active\n    - Termination function: When to switch to another option", "source": "core\\rl\\hierarchical_rl.py", "category": "volatility"}
{"instruction": "What is the HierarchicalTradingAgent class and how do I use it?", "input": "", "output": "The HierarchicalTradingAgent class:\n\nHierarchical RL Agent for Multi-Timeframe Trading.\n\nChinese Innovation:\n    分层强化学习应用于多时间框架交易:\n    - 高层 (Manager): 组合配置, 仓位目标 (日/周决策)\n    - 低层 (Worker): 订单执行, 入场/出场时机 (日内/tick级)\n\nThis addresses the challenge of:\n1. Long-term strategic decisions (what to trade)\n2. Short-term tactical decisions (when/how to trade)", "source": "core\\rl\\hierarchical_rl.py", "category": "microstructure"}
{"instruction": "What is the OptionCriticTrader class and how do I use it?", "input": "", "output": "The OptionCriticTrader class:\n\nOption-Critic based Trader.\n\nUses pre-defined trading \"options\" (strategies) with learned\nintra-option policies and termination conditions.", "source": "core\\rl\\hierarchical_rl.py", "category": "general"}
{"instruction": "What is the formula for Create Hierarchical Agent?", "input": "", "output": "Factory function to create hierarchical RL agent.\n\nArgs:\n    state_dim: State dimension\n    agent_type: 'feudal' (Manager-Worker) or 'option_critic'\n    config: Hierarchical RL configuration\n\nReturns:\n    Hierarchical RL agent", "source": "core\\rl\\hierarchical_rl.py", "category": "alpha"}
{"instruction": "Explain the Create Hierarchical Agent function", "input": "", "output": "Function: create_hierarchical_agent\n\nFactory function to create hierarchical RL agent.\n\nArgs:\n    state_dim: State dimension\n    agent_type: 'feudal' (Manager-Worker) or 'option_critic'\n    config: Hierarchical RL configuration\n\nReturns:\n    Hierarchical RL agent", "source": "core\\rl\\hierarchical_rl.py", "category": "alpha"}
{"instruction": "What is the formula for Create Option Critic Trader?", "input": "", "output": "Factory function to create Option-Critic trader.\n\nArgs:\n    state_dim: State dimension\n    config: Hierarchical RL configuration\n\nReturns:\n    OptionCriticTrader instance", "source": "core\\rl\\hierarchical_rl.py", "category": "alpha"}
{"instruction": "Explain the Create Option Critic Trader function", "input": "", "output": "Function: create_option_critic_trader\n\nFactory function to create Option-Critic trader.\n\nArgs:\n    state_dim: State dimension\n    config: Hierarchical RL configuration\n\nReturns:\n    OptionCriticTrader instance", "source": "core\\rl\\hierarchical_rl.py", "category": "alpha"}
{"instruction": "What is the formula for Forward?", "input": "", "output": "Forward pass.\n\nArgs:\n    state: Current state\n\nReturns:\n    goal: Goal/option selection logits\n    value: State value estimate", "source": "core\\rl\\hierarchical_rl.py", "category": "regime"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nForward pass.\n\nArgs:\n    state: Current state\n\nReturns:\n    goal: Goal/option selection logits\n    value: State value estimate", "source": "core\\rl\\hierarchical_rl.py", "category": "regime"}
{"instruction": "Explain the Get Goal function", "input": "", "output": "Function: get_goal\n\nSample goal for worker.", "source": "core\\rl\\hierarchical_rl.py", "category": "general"}
{"instruction": "What is the formula for Forward?", "input": "", "output": "Forward pass conditioned on goal.\n\nArgs:\n    state: Current state\n    goal: Goal from manager (one-hot or embedding)\n\nReturns:\n    action_dist_params: Action distribution parameters\n    value: State-goal value estimate", "source": "core\\rl\\hierarchical_rl.py", "category": "regime"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nForward pass conditioned on goal.\n\nArgs:\n    state: Current state\n    goal: Goal from manager (one-hot or embedding)\n\nReturns:\n    action_dist_params: Action distribution parameters\n    value: State-goal value estimate", "source": "core\\rl\\hierarchical_rl.py", "category": "regime"}
{"instruction": "Explain the Get Action function", "input": "", "output": "Function: get_action\n\nGet action conditioned on goal.", "source": "core\\rl\\hierarchical_rl.py", "category": "general"}
{"instruction": "What is the formula for Forward?", "input": "", "output": "Forward pass.\n\nReturns:\n    q_options: Q-values for each option\n    policies: Action probabilities for each option\n    terminations: Termination probabilities for each option", "source": "core\\rl\\hierarchical_rl.py", "category": "general"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nForward pass.\n\nReturns:\n    q_options: Q-values for each option\n    policies: Action probabilities for each option\n    terminations: Termination probabilities for each option", "source": "core\\rl\\hierarchical_rl.py", "category": "general"}
{"instruction": "What is the formula for Get Option?", "input": "", "output": "Select option using epsilon-greedy over Q-values.", "source": "core\\rl\\hierarchical_rl.py", "category": "general"}
{"instruction": "Explain the Get Option function", "input": "", "output": "Function: get_option\n\nSelect option using epsilon-greedy over Q-values.", "source": "core\\rl\\hierarchical_rl.py", "category": "general"}
{"instruction": "Explain the Get Action function", "input": "", "output": "Function: get_action\n\nGet action for given option.", "source": "core\\rl\\hierarchical_rl.py", "category": "general"}
{"instruction": "Explain the Should Terminate function", "input": "", "output": "Function: should_terminate\n\nCheck if option should terminate.", "source": "core\\rl\\hierarchical_rl.py", "category": "general"}
{"instruction": "What is the formula for Select Action?", "input": "", "output": "Select hierarchical action.\n\nReturns:\n    goal: Current goal/option\n    action: Low-level action", "source": "core\\rl\\hierarchical_rl.py", "category": "general"}
{"instruction": "Explain the Select Action function", "input": "", "output": "Function: select_action\n\nSelect hierarchical action.\n\nReturns:\n    goal: Current goal/option\n    action: Low-level action", "source": "core\\rl\\hierarchical_rl.py", "category": "general"}
{"instruction": "Explain the Reset function", "input": "", "output": "Function: reset\n\nReset for new episode.", "source": "core\\rl\\hierarchical_rl.py", "category": "general"}
{"instruction": "What is the formula for Select Action?", "input": "", "output": "Select action using Option-Critic.\n\nReturns:\n    option: Current trading strategy\n    action: Action within that strategy", "source": "core\\rl\\hierarchical_rl.py", "category": "general"}
{"instruction": "Explain the Select Action function", "input": "", "output": "Function: select_action\n\nSelect action using Option-Critic.\n\nReturns:\n    option: Current trading strategy\n    action: Action within that strategy", "source": "core\\rl\\hierarchical_rl.py", "category": "general"}
{"instruction": "Explain the Update Epsilon function", "input": "", "output": "Function: update_epsilon\n\nDecay exploration rate.", "source": "core\\rl\\hierarchical_rl.py", "category": "general"}
{"instruction": "Explain the Reset function", "input": "", "output": "Function: reset\n\nReset for new episode.", "source": "core\\rl\\hierarchical_rl.py", "category": "general"}
{"instruction": "Explain the purpose of Imitation Learning for Forex Trading", "input": "", "output": "Imitation Learning for Forex Trading\n\nAcademic Citations:\n══════════════════════════════════════════════════════════════════════════════\n\nBehavioral Cloning (BC):\n    Pomerleau (1988)\n    \"ALVINN: An Autonomous Land Vehicle in a Neural Network\"\n    NeurIPS 1988\n    - Supervised learning from expert demonstrations\n    - Simple but suffers from distribution shift\n    - Best for: Initial policy before RL fine-tuning\n\nGAIL - Generative Adversarial Imitation Learning:\n    Ho & Ermon (2016)\n    \"Generative Adversarial Imitation Learning\"\n    NeurIPS 2016\n    - Learns reward function from demonstrations\n    - Adversarial training (generator=policy, discriminator=reward)\n    - Best for: Complex trading patterns\n\nDAgger - Dataset Aggregation:\n    Ross et al. (2011)\n    \"A Reduction of Imitation Learning and Structured Prediction to No-Regret Online Learning\"\n    AISTATS 2011\n    - Iterative expert querying to fix distribution shift\n    - Aggregates on-policy data with expert labels\n    - Best for: When expert feedback is available\n\nKey Benefits for Forex:\n══════════════════════════════════════════════════════════════════════════════\n1. Cold-Start Solution: Bootstrap policy from historical winners\n2. Transfer Learning: Learn from professional traders\n3. Risk Reduction: Start from known-good strategy\n4. Faster Convergence: Pre-train before RL fine-tuning\n\nPerformance:\n| Algorithm | Win Rate | Sharpe | vs Random Policy |\n|-----------|----------|--------|------------------|\n| BC        | 58%      | 1.6    | +200%            |\n| GAIL      | 62%      | 1.9    | +280%            |\n| DAgger    | 60%      | 1.8    | +250%            |\n══════════════════════════════════════════════════════════════════════════════", "source": "core\\rl\\imitation.py", "category": "risk"}
{"instruction": "What is the ImitationConfig class and how do I use it?", "input": "", "output": "The ImitationConfig class:\n\nConfiguration for Imitation Learning algorithms.", "source": "core\\rl\\imitation.py", "category": "general"}
{"instruction": "What is the ExpertDataset class and how do I use it?", "input": "", "output": "The ExpertDataset class:\n\nDataset of expert demonstrations.\n\nStores (state, action, reward) tuples from expert policy.", "source": "core\\rl\\imitation.py", "category": "regime"}
{"instruction": "What is the BehavioralCloningTrader class and how do I use it?", "input": "", "output": "The BehavioralCloningTrader class:\n\nBehavioral Cloning Trader.\n\nReference:\n    Pomerleau (1988) - \"ALVINN\"\n    Bain & Sammut (1999) - \"A Framework for Behavioural Cloning\"\n\nKey Idea:\n- Treat imitation as supervised learning\n- Minimize L2 loss between policy and expert actions\n- Simple, fast, but suffers from distribution shift\n\nAlgorithm:\n```\nFor epoch = 1..N:\n    Sample batch (s, a) from expert dataset\n    Update policy: θ = θ - α * ∇_θ ||π_θ(s) - a||^2\n```\n\nWhy it works for forex:\n- Fast to train on historical winners\n- Good initialization for RL fine-tuning\n- Low computational cost\n- Interpretable policy\n\nLimitations:\n- Compounding errors from distribution shift\n- No exploration, just mimics\n- Assumes expert is optimal", "source": "core\\rl\\imitation.py", "category": "rl"}
{"instruction": "What is the Discriminator class and how do I use it?", "input": "", "output": "The Discriminator class:\n\nGAIL Discriminator.\n\nReference: Ho & Ermon (2016), Section 3\n\nClassifies (state, action) pairs as:\n- Expert (label=1)\n- Policy (label=0)\n\nOutput is used as reward signal for policy.", "source": "core\\rl\\imitation.py", "category": "alpha"}
{"instruction": "What is the GAILTrader class and how do I use it?", "input": "", "output": "The GAILTrader class:\n\nGenerative Adversarial Imitation Learning Trader.\n\nReference:\n    Ho & Ermon (2016)\n    \"Generative Adversarial Imitation Learning\"\n    NeurIPS 2016\n\nKey Innovations:\n- Learns reward function from demonstrations\n- Adversarial training of generator (policy) and discriminator\n- Recovers expert reward without manual design\n- Works with limited demonstrations\n\nAlgorithm:\n```\nFor iteration = 1..N:\n    1. Sample trajectories from policy π_θ\n    2. Sample expert demonstrations\n    3. Update discriminator to distinguish expert from policy\n    4. Update policy to maximize E[r_D(s,a)] where r_D = -log(1-D(s,a))\n```\n\nWhy it works for forex:\n- Learns implicit reward from winners\n- No need to specify reward manually\n- Captures complex trading patterns\n- Generalizes beyond exact demonstrations", "source": "core\\rl\\imitation.py", "category": "general"}
{"instruction": "What is the DAggerTrader class and how do I use it?", "input": "", "output": "The DAggerTrader class:\n\nDataset Aggregation (DAgger) Trader.\n\nReference:\n    Ross et al. (2011)\n    \"A Reduction of Imitation Learning and Structured Prediction to No-Regret Online Learning\"\n    AISTATS 2011\n\nKey Innovations:\n- Iteratively queries expert on policy-induced states\n- Aggregates new data with previous demonstrations\n- Fixes distribution shift problem of pure BC\n- Theoretical no-regret guarantees\n\nAlgorithm:\n```\nD = expert_dataset\nFor iteration = 1..N:\n    1. Train policy π_i on D\n    2. Run π_i to collect states\n    3. Query expert for actions at those states\n    4. Aggregate: D = D ∪ {new (state, expert_action) pairs}\n```\n\nWhy it works for forex:\n- Handles distribution shift in trading\n- Works with live expert feedback\n- Builds robust policy over time\n- Adapts to policy's actual trajectory", "source": "core\\rl\\imitation.py", "category": "regime"}
{"instruction": "Explain the Create Expert From Historical Trades function", "input": "", "output": "Function: create_expert_from_historical_trades\n\nCreate expert dataset from historical profitable trades.\n\nArgs:\n    df: DataFrame with trading data\n    state_cols: Columns to use as state features\n    action_col: Column with trading action (position)\n    reward_col: Column with returns (for filtering)\n    success_threshold: Minimum return to include\n\nReturns:\n    ExpertDataset with winning trades", "source": "core\\rl\\imitation.py", "category": "regime"}
{"instruction": "What is OFI in quantitative trading?", "input": "", "output": "OFI (Order Flow Imbalance).\n\nImplementation details:\nCreate expert dataset from historical profitable trades.\n\nArgs:\n    df: DataFrame with trading data\n    state_cols: Columns to use as state features\n    action_col: Column with trading action (position)\n    reward_col: Column with returns (for filtering)\n    success_threshold: Minimum return to include\n\nReturns:\n    ExpertDataset with winning trades", "source": "core\\rl\\imitation.py", "category": "regime"}
{"instruction": "Explain the Create Expert From Model function", "input": "", "output": "Function: create_expert_from_model\n\nCreate expert policy function from trained model.\n\nArgs:\n    model: Trained RL agent\n    noise: Add Gaussian noise to actions\n\nReturns:\n    Expert policy function", "source": "core\\rl\\imitation.py", "category": "rl"}
{"instruction": "What is the formula for Create Imitation Trader?", "input": "", "output": "Factory function to create imitation learning traders.\n\nArgs:\n    agent_type: One of 'bc', 'gail', 'dagger'\n    env: Gym environment\n    config: Imitation configuration\n    **kwargs: Additional arguments (e.g., expert_policy for DAgger)\n\nReturns:\n    Imitation learning trader instance", "source": "core\\rl\\imitation.py", "category": "alpha"}
{"instruction": "Explain the Create Imitation Trader function", "input": "", "output": "Function: create_imitation_trader\n\nFactory function to create imitation learning traders.\n\nArgs:\n    agent_type: One of 'bc', 'gail', 'dagger'\n    env: Gym environment\n    config: Imitation configuration\n    **kwargs: Additional arguments (e.g., expert_policy for DAgger)\n\nReturns:\n    Imitation learning trader instance", "source": "core\\rl\\imitation.py", "category": "alpha"}
{"instruction": "Explain the Add function", "input": "", "output": "Function: add\n\nAdd single transition.", "source": "core\\rl\\imitation.py", "category": "general"}
{"instruction": "Explain the Add Trajectory function", "input": "", "output": "Function: add_trajectory\n\nAdd trajectory of (state, action, reward, next_state, done) tuples.", "source": "core\\rl\\imitation.py", "category": "regime"}
{"instruction": "Explain the Load From Numpy function", "input": "", "output": "Function: load_from_numpy\n\nLoad from numpy arrays.", "source": "core\\rl\\imitation.py", "category": "general"}
{"instruction": "Explain the Sample function", "input": "", "output": "Function: sample\n\nSample batch of transitions.", "source": "core\\rl\\imitation.py", "category": "general"}
{"instruction": "What is the formula for Sample States Actions?", "input": "", "output": "Sample only states and actions (for BC/GAIL).", "source": "core\\rl\\imitation.py", "category": "regime"}
{"instruction": "Explain the Sample States Actions function", "input": "", "output": "Function: sample_states_actions\n\nSample only states and actions (for BC/GAIL).", "source": "core\\rl\\imitation.py", "category": "regime"}
{"instruction": "Explain the Select Action function", "input": "", "output": "Function: select_action\n\nSelect action from learned policy.", "source": "core\\rl\\imitation.py", "category": "general"}
{"instruction": "Explain the Train function", "input": "", "output": "Function: train\n\nTrain policy via supervised learning on expert actions.", "source": "core\\rl\\imitation.py", "category": "general"}
{"instruction": "Explain the Learn From Expert function", "input": "", "output": "Function: learn_from_expert\n\nTrain policy on expert demonstrations.\n\nArgs:\n    expert_dataset: Dataset of expert (state, action) pairs\n    epochs: Number of training epochs\n    callback: Optional callback for logging", "source": "core\\rl\\imitation.py", "category": "regime"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nOutput logit (before sigmoid).", "source": "core\\rl\\imitation.py", "category": "general"}
{"instruction": "What is the formula for Compute Reward?", "input": "", "output": "Compute GAIL reward: -log(1 - D(s, a)).", "source": "core\\rl\\imitation.py", "category": "general"}
{"instruction": "Explain the Compute Reward function", "input": "", "output": "Function: compute_reward\n\nCompute GAIL reward: -log(1 - D(s, a)).", "source": "core\\rl\\imitation.py", "category": "general"}
{"instruction": "Explain the Select Action function", "input": "", "output": "Function: select_action\n\nSelect action from policy.", "source": "core\\rl\\imitation.py", "category": "general"}
{"instruction": "What is the formula for Train?", "input": "", "output": "Train GAIL (discriminator + policy).", "source": "core\\rl\\imitation.py", "category": "general"}
{"instruction": "Explain the Train function", "input": "", "output": "Function: train\n\nTrain GAIL (discriminator + policy).", "source": "core\\rl\\imitation.py", "category": "general"}
{"instruction": "Explain the Learn function", "input": "", "output": "Function: learn\n\nTrain GAIL with expert demonstrations.\n\nArgs:\n    total_timesteps: Total environment steps\n    expert_dataset: Dataset of expert demonstrations\n    callback: Optional callback for logging", "source": "core\\rl\\imitation.py", "category": "general"}
{"instruction": "Explain the Select Action function", "input": "", "output": "Function: select_action\n\nSelect action from learned policy.", "source": "core\\rl\\imitation.py", "category": "general"}
{"instruction": "Explain the Learn function", "input": "", "output": "Function: learn\n\nTrain DAgger iteratively.\n\nArgs:\n    initial_dataset: Initial expert demonstrations\n    iterations: Number of DAgger iterations\n    samples_per_iter: Samples to collect per iteration\n    callback: Optional callback for logging", "source": "core\\rl\\imitation.py", "category": "general"}
{"instruction": "Explain the purpose of Meta-Learning for Forex Trading", "input": "", "output": "Meta-Learning for Forex Trading\n\nAcademic Citations:\n══════════════════════════════════════════════════════════════════════════════\n\nMAML - Model-Agnostic Meta-Learning:\n    Finn et al. (2017)\n    \"Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks\"\n    ICML 2017\n    - Learns initialization for fast adaptation\n    - Second-order optimization (compute gradients of gradients)\n    - Few-shot adaptation to new tasks\n    - Best for: Market regime changes\n\nReptile:\n    Nichol et al. (2018)\n    \"On First-Order Meta-Learning Algorithms\"\n    arXiv:1803.02999\n    - First-order approximation of MAML\n    - Much simpler, scales better\n    - Comparable performance to MAML\n    - Best for: Large-scale deployment\n\nRL² (Meta-RL):\n    Duan et al. (2016)\n    \"RL²: Fast Reinforcement Learning via Slow Reinforcement Learning\"\n    arXiv:1611.02779\n    - RNN-based meta-learning\n    - Learns to learn from experience\n    - Best for: Online adaptation\n\nKey Benefits for Forex:\n══════════════════════════════════════════════════════════════════════════════\n1. Fast Regime Adaptation: Adapt in 100-200 ticks vs thousands\n2. Transfer Learning: Leverage knowledge across currency pairs\n3. Few-Shot Learning: Learn from limited data in new regime\n4. Robustness: Handle distribution shift gracefully\n\nPerformance (regime adaptation):\n| Algorithm | Adaptation Ticks | Sharpe After Adapt |\n|-----------|------------------|-------------------|\n| MAML      | 100              | 2.1               |\n| Reptile   | 150              | 1.9               |\n| RL²       | 200              | 1.8               |\n| No Meta   | 5000+            | 1.5               |\n══════════════════════════════════════════════════════════════════════════════", "source": "core\\rl\\meta_learning.py", "category": "risk"}
{"instruction": "What is the MetaLearningConfig class and how do I use it?", "input": "", "output": "The MetaLearningConfig class:\n\nConfiguration for Meta-Learning algorithms.", "source": "core\\rl\\meta_learning.py", "category": "ensemble"}
{"instruction": "What is the MetaTask class and how do I use it?", "input": "", "output": "The MetaTask class:\n\nRepresents a meta-learning task.\n\nFor forex: Each task is a market regime (trending, ranging, volatile, etc.)", "source": "core\\rl\\meta_learning.py", "category": "volatility"}
{"instruction": "What is the TaskDistribution class and how do I use it?", "input": "", "output": "The TaskDistribution class:\n\nDistribution of meta-learning tasks.\n\nFor forex: Generates tasks representing different market regimes.", "source": "core\\rl\\meta_learning.py", "category": "microstructure"}
{"instruction": "What is the RegimeTaskDistribution class and how do I use it?", "input": "", "output": "The RegimeTaskDistribution class:\n\nTask distribution based on market regimes.\n\nExtracts different market regimes from historical data\nand treats each as a separate task.", "source": "core\\rl\\meta_learning.py", "category": "microstructure"}
{"instruction": "What is the MAMLPolicy class and how do I use it?", "input": "", "output": "The MAMLPolicy class:\n\nPolicy network compatible with MAML second-order gradients.\n\nUses functional API for gradient computation.", "source": "core\\rl\\meta_learning.py", "category": "general"}
{"instruction": "What is the MAMLTrader class and how do I use it?", "input": "", "output": "The MAMLTrader class:\n\nModel-Agnostic Meta-Learning Trader.\n\nReference:\n    Finn et al. (2017)\n    \"Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks\"\n    ICML 2017\n\nKey Innovations:\n- Learns initialization for fast adaptation\n- Second-order gradients (gradients of gradients)\n- Task-agnostic: works with any differentiable model\n- Few-shot learning: adapt with ~5 gradient steps\n\nAlgorithm:\n```\nθ = initial parameters\nFor each meta-iteration:\n    Sample batch of tasks T_1, ..., T_n\n    For each task T_i:\n        θ'_i = θ - α * ∇_θ L_Ti(θ)  # Inner loop\n        Compute meta-gradient ∇_θ L_Ti(θ'_i)\n    θ = θ - β * sum(∇_θ L_Ti(θ'_i))  # Outer loop\n```\n\nWhy it works for forex:\n- Fast adaptation to new market regimes\n- Learns common structure across regimes\n- Few-shot learning (100-200 ticks to adapt)\n- Robust to distribution shift", "source": "core\\rl\\meta_learning.py", "category": "microstructure"}
{"instruction": "What is the ReptileTrader class and how do I use it?", "input": "", "output": "The ReptileTrader class:\n\nReptile Meta-Learning Trader.\n\nReference:\n    Nichol et al. (2018)\n    \"On First-Order Meta-Learning Algorithms\"\n    arXiv:1803.02999\n\nKey Innovations:\n- First-order approximation of MAML\n- Much simpler: just interpolate between task-specific and meta params\n- No second-order gradients needed\n- Comparable performance to MAML, better scalability\n\nAlgorithm:\n```\nθ = initial parameters\nFor each meta-iteration:\n    Sample task T\n    θ' = SGD on T for k steps starting from θ\n    θ = θ + ε * (θ' - θ)  # Move towards task solution\n```\n\nWhy it works for forex:\n- Simple and stable training\n- Scales to larger models\n- Fast adaptation like MAML\n- Works well with limited compute", "source": "core\\rl\\meta_learning.py", "category": "microstructure"}
{"instruction": "What is the RL2Policy class and how do I use it?", "input": "", "output": "The RL2Policy class:\n\nRNN-based policy for RL².\n\nReference: Duan et al. (2016) - \"RL²\"\n\nThe RNN hidden state serves as implicit task embedding.", "source": "core\\rl\\meta_learning.py", "category": "microstructure"}
{"instruction": "What is the RL2Trader class and how do I use it?", "input": "", "output": "The RL2Trader class:\n\nRL² Meta-Reinforcement Learning Trader.\n\nReference:\n    Duan et al. (2016)\n    \"RL²: Fast Reinforcement Learning via Slow Reinforcement Learning\"\n    arXiv:1611.02779\n\nKey Innovations:\n- RNN hidden state encodes task information\n- Learns to learn from experience\n- No explicit task encoding needed\n- Online adaptation during episode\n\nWhy it works for forex:\n- Automatically infers market regime\n- Adapts online as market changes\n- No need to define regime explicitly\n- Robust to gradual distribution shift", "source": "core\\rl\\meta_learning.py", "category": "microstructure"}
{"instruction": "What is the formula for Create Meta Trader?", "input": "", "output": "Factory function to create meta-learning traders.\n\nArgs:\n    agent_type: One of 'maml', 'reptile', 'rl2'\n    env: Gym environment\n    config: Meta-learning configuration\n\nReturns:\n    Meta-learning trader instance", "source": "core\\rl\\meta_learning.py", "category": "alpha"}
{"instruction": "Explain the Create Meta Trader function", "input": "", "output": "Function: create_meta_trader\n\nFactory function to create meta-learning traders.\n\nArgs:\n    agent_type: One of 'maml', 'reptile', 'rl2'\n    env: Gym environment\n    config: Meta-learning configuration\n\nReturns:\n    Meta-learning trader instance", "source": "core\\rl\\meta_learning.py", "category": "alpha"}
{"instruction": "What is the formula for Create Regime Tasks?", "input": "", "output": "Create task distribution from historical data.\n\nArgs:\n    data: Dictionary with 'states', 'actions', 'rewards', etc.\n    config: Meta-learning configuration\n\nReturns:\n    RegimeTaskDistribution for meta-training", "source": "core\\rl\\meta_learning.py", "category": "microstructure"}
{"instruction": "Explain the Create Regime Tasks function", "input": "", "output": "Function: create_regime_tasks\n\nCreate task distribution from historical data.\n\nArgs:\n    data: Dictionary with 'states', 'actions', 'rewards', etc.\n    config: Meta-learning configuration\n\nReturns:\n    RegimeTaskDistribution for meta-training", "source": "core\\rl\\meta_learning.py", "category": "microstructure"}
{"instruction": "Explain the From Buffer function", "input": "", "output": "Function: from_buffer\n\nCreate task from replay buffer by sampling.", "source": "core\\rl\\meta_learning.py", "category": "microstructure"}
{"instruction": "Explain the Sample Tasks function", "input": "", "output": "Function: sample_tasks\n\nSample n_tasks tasks from distribution.", "source": "core\\rl\\meta_learning.py", "category": "microstructure"}
{"instruction": "Explain the Collect Data function", "input": "", "output": "Function: collect_data\n\nCollect data for all tasks using given policy.", "source": "core\\rl\\meta_learning.py", "category": "microstructure"}
{"instruction": "Explain the Sample Tasks function", "input": "", "output": "Function: sample_tasks\n\nSample n_tasks regime tasks.", "source": "core\\rl\\meta_learning.py", "category": "microstructure"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nForward pass with optional external parameters.\n\nArgs:\n    state: Input state\n    params: If provided, use these parameters instead of self.parameters()", "source": "core\\rl\\meta_learning.py", "category": "regime"}
{"instruction": "Explain the Sample function", "input": "", "output": "Function: sample\n\nSample action from policy.", "source": "core\\rl\\meta_learning.py", "category": "general"}
{"instruction": "Explain the Get Params function", "input": "", "output": "Function: get_params\n\nGet named parameters as dictionary.", "source": "core\\rl\\meta_learning.py", "category": "general"}
{"instruction": "What is the formula for Meta Train Step?", "input": "", "output": "Perform one meta-training step on batch of tasks.", "source": "core\\rl\\meta_learning.py", "category": "microstructure"}
{"instruction": "Explain the Meta Train Step function", "input": "", "output": "Function: meta_train_step\n\nPerform one meta-training step on batch of tasks.", "source": "core\\rl\\meta_learning.py", "category": "microstructure"}
{"instruction": "What is the formula for Adapt?", "input": "", "output": "Adapt policy to new task/regime.\n\nArgs:\n    data: Dictionary with 'states', 'actions', 'rewards'\n    n_steps: Number of adaptation steps\n\nReturns:\n    Self with adapted parameters", "source": "core\\rl\\meta_learning.py", "category": "microstructure"}
{"instruction": "Explain the Adapt function", "input": "", "output": "Function: adapt\n\nAdapt policy to new task/regime.\n\nArgs:\n    data: Dictionary with 'states', 'actions', 'rewards'\n    n_steps: Number of adaptation steps\n\nReturns:\n    Self with adapted parameters", "source": "core\\rl\\meta_learning.py", "category": "microstructure"}
{"instruction": "Explain the Select Action function", "input": "", "output": "Function: select_action\n\nSelect action from policy.", "source": "core\\rl\\meta_learning.py", "category": "general"}
{"instruction": "What is the formula for Train?", "input": "", "output": "Standard training on batch (for non-meta updates).", "source": "core\\rl\\meta_learning.py", "category": "ensemble"}
{"instruction": "Explain the Train function", "input": "", "output": "Function: train\n\nStandard training on batch (for non-meta updates).", "source": "core\\rl\\meta_learning.py", "category": "ensemble"}
{"instruction": "What is the formula for Meta Learn?", "input": "", "output": "Main meta-learning loop.\n\nArgs:\n    task_distribution: Distribution over tasks\n    iterations: Number of meta-iterations\n    callback: Optional callback for logging", "source": "core\\rl\\meta_learning.py", "category": "microstructure"}
{"instruction": "Explain the Meta Learn function", "input": "", "output": "Function: meta_learn\n\nMain meta-learning loop.\n\nArgs:\n    task_distribution: Distribution over tasks\n    iterations: Number of meta-iterations\n    callback: Optional callback for logging", "source": "core\\rl\\meta_learning.py", "category": "microstructure"}
{"instruction": "What is the formula for Meta Train Step?", "input": "", "output": "Perform one Reptile meta-training step.", "source": "core\\rl\\meta_learning.py", "category": "ensemble"}
{"instruction": "Explain the Meta Train Step function", "input": "", "output": "Function: meta_train_step\n\nPerform one Reptile meta-training step.", "source": "core\\rl\\meta_learning.py", "category": "ensemble"}
{"instruction": "What is the formula for Adapt?", "input": "", "output": "Adapt policy to new task/regime.\n\nArgs:\n    data: Dictionary with 'states', 'actions', 'rewards'\n    n_steps: Number of adaptation steps", "source": "core\\rl\\meta_learning.py", "category": "microstructure"}
{"instruction": "Explain the Adapt function", "input": "", "output": "Function: adapt\n\nAdapt policy to new task/regime.\n\nArgs:\n    data: Dictionary with 'states', 'actions', 'rewards'\n    n_steps: Number of adaptation steps", "source": "core\\rl\\meta_learning.py", "category": "microstructure"}
{"instruction": "Explain the Select Action function", "input": "", "output": "Function: select_action\n\nSelect action from policy.", "source": "core\\rl\\meta_learning.py", "category": "general"}
{"instruction": "Explain the Train function", "input": "", "output": "Function: train\n\nStandard training on batch.", "source": "core\\rl\\meta_learning.py", "category": "general"}
{"instruction": "What is the formula for Meta Learn?", "input": "", "output": "Main Reptile meta-learning loop.\n\nArgs:\n    task_distribution: Distribution over tasks\n    iterations: Number of meta-iterations\n    callback: Optional callback for logging", "source": "core\\rl\\meta_learning.py", "category": "microstructure"}
{"instruction": "Explain the Meta Learn function", "input": "", "output": "Function: meta_learn\n\nMain Reptile meta-learning loop.\n\nArgs:\n    task_distribution: Distribution over tasks\n    iterations: Number of meta-iterations\n    callback: Optional callback for logging", "source": "core\\rl\\meta_learning.py", "category": "microstructure"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nForward pass.\n\nReturns: mean, log_std, new_hidden", "source": "core\\rl\\meta_learning.py", "category": "general"}
{"instruction": "Explain the Sample function", "input": "", "output": "Function: sample\n\nSample action from policy.", "source": "core\\rl\\meta_learning.py", "category": "general"}
{"instruction": "Explain the Select Action function", "input": "", "output": "Function: select_action\n\nSelect action using RNN policy.", "source": "core\\rl\\meta_learning.py", "category": "general"}
{"instruction": "Explain the Update Reward function", "input": "", "output": "Function: update_reward\n\nUpdate previous reward for next action selection.", "source": "core\\rl\\meta_learning.py", "category": "general"}
{"instruction": "Explain the Reset Hidden function", "input": "", "output": "Function: reset_hidden\n\nReset RNN hidden state (call at episode start).", "source": "core\\rl\\meta_learning.py", "category": "regime"}
{"instruction": "Explain the Train function", "input": "", "output": "Function: train\n\nTrain RL² on batch of sequences.", "source": "core\\rl\\meta_learning.py", "category": "rl"}
{"instruction": "Explain the purpose of Multi-Agent Reinforcement Learning for Forex Trading", "input": "", "output": "Multi-Agent Reinforcement Learning for Forex Trading\n\nAcademic Citations:\n══════════════════════════════════════════════════════════════════════════════\n\nA3C - Asynchronous Advantage Actor-Critic:\n    Mnih et al. (2016)\n    \"Asynchronous Methods for Deep Reinforcement Learning\"\n    ICML 2016\n    Extended for Forex: Shobayo et al. (2024), arXiv:2405.19982\n    - Parallel workers for multi-currency trading\n    - Lock vs no-lock variants\n    - Best for: Single currency (lock), Multi-currency (no-lock)\n\nMAPPO - Multi-Agent Proximal Policy Optimization:\n    Yu et al. (2022)\n    \"The Surprising Effectiveness of PPO in Cooperative Multi-Agent Games\"\n    NeurIPS 2022\n    Extended for HFT: ResearchGate (2024), Sharpe 2.87\n    - Centralized training, decentralized execution (CTDE)\n    - Value Decomposition Network (VDN) architecture\n    - Best for: Portfolio coordination, HFT\n\nJPMorgan MARL:\n    Vadori et al. (2024)\n    \"Multi-Agent Reinforcement Learning in a Realistic Limit Order Book Market\"\n    Mathematical Finance Journal\n    - Liquidity provider + taker agents\n    - OTC market simulation\n    - Parameterized reward families\n\nPerformance (from papers):\n══════════════════════════════════════════════════════════════════════════════\n| Algorithm    | Sharpe | Annual Return | Max Drawdown |\n|--------------|--------|---------------|--------------|\n| A3C-NoLock   | 2.34   | +9.8%         | -8.2%        |\n| MAPPO-HFT    | 2.87   | +12.3%        | -6.1%        |\n| JP Morgan    | 2.15   | +8.7%         | -7.8%        |\n══════════════════════════════════════════════════════════════════════════════", "source": "core\\rl\\multi_agent.py", "category": "risk"}
{"instruction": "What is the MultiAgentConfig class and how do I use it?", "input": "", "output": "The MultiAgentConfig class:\n\nConfiguration for Multi-Agent RL.\n\nExtends base AgentConfig with multi-agent specific settings.", "source": "core\\rl\\multi_agent.py", "category": "rl"}
{"instruction": "What is the SharedActorCritic class and how do I use it?", "input": "", "output": "The SharedActorCritic class:\n\nShared Actor-Critic Network for A3C/MAPPO.\n\nReference: Mnih et al. (2016) - \"Asynchronous Methods for DRL\"\n\nArchitecture:\n    - Shared backbone for efficiency\n    - Separate policy and value heads\n    - Optional LSTM for temporal dependencies", "source": "core\\rl\\multi_agent.py", "category": "rl"}
{"instruction": "What is the CentralizedCritic class and how do I use it?", "input": "", "output": "The CentralizedCritic class:\n\nCentralized Critic for CTDE (Centralized Training Decentralized Execution).\n\nReference: Lowe et al. (2017) - \"Multi-Agent Actor-Critic\"\n\nTakes all agents' observations and actions to estimate joint value.", "source": "core\\rl\\multi_agent.py", "category": "execution"}
{"instruction": "What is the VDNMixer class and how do I use it?", "input": "", "output": "The VDNMixer class:\n\nValue Decomposition Network Mixer.\n\nReference: Sunehag et al. (2018) - \"Value-Decomposition Networks\"\n\nQ_tot = sum(Q_i)  # Simple additive decomposition\n\nFor forex: Each agent's Q contributes additively to portfolio value.", "source": "core\\rl\\multi_agent.py", "category": "rl"}
{"instruction": "What is the A3CWorker class and how do I use it?", "input": "", "output": "The A3CWorker class:\n\nA3C Worker Process.\n\nReference: Mnih et al. (2016), Section 4\n\nEach worker:\n1. Runs T_MAX steps in its own environment copy\n2. Computes gradients\n3. Applies gradients to shared network (async)", "source": "core\\rl\\multi_agent.py", "category": "general"}
{"instruction": "What is the A3CTrader class and how do I use it?", "input": "", "output": "The A3CTrader class:\n\nAsynchronous Advantage Actor-Critic Trader.\n\nReference:\n    Mnih et al. (2016) - \"Asynchronous Methods for Deep RL\"\n    Shobayo et al. (2024) - arXiv:2405.19982 (Forex extension)\n\nKey Innovations:\n- Parallel workers explore different parts of state space\n- Async updates stabilize training without replay buffer\n- Lock variant for single-currency (synchronized updates)\n- No-lock variant for multi-currency (faster, more exploration)\n\nPerformance (arXiv:2405.19982):\n- Annual Return: +9.8% (no-lock on multi-currency)\n- Sharpe Ratio: 2.34", "source": "core\\rl\\multi_agent.py", "category": "risk"}
{"instruction": "What is the MAPPOAgent class and how do I use it?", "input": "", "output": "The MAPPOAgent class:\n\nSingle Agent in MAPPO System.\n\nEach agent has:\n- Individual actor (decentralized policy)\n- Shared/individual critic (centralized value)", "source": "core\\rl\\multi_agent.py", "category": "rl"}
{"instruction": "What is the MAPPOTrader class and how do I use it?", "input": "", "output": "The MAPPOTrader class:\n\nMulti-Agent Proximal Policy Optimization Trader.\n\nReference:\n    Yu et al. (2022)\n    \"The Surprising Effectiveness of PPO in Cooperative Multi-Agent Games\"\n    NeurIPS 2022\n\n    Extended for HFT: ResearchGate (2024)\n    - Achieves Sharpe 2.87 on forex HFT\n\nKey Innovations:\n- Centralized Training, Decentralized Execution (CTDE)\n- Centralized critic sees all agents' observations\n- Each agent executes using only local observation\n- Value Decomposition for credit assignment\n\nArchitecture:\n    - N individual actors (one per trading agent)\n    - 1 centralized critic (sees global state)\n    - Optional VDN mixer for value decomposition\n\nUse Cases:\n- Portfolio coordination across multiple pairs\n- Multi-strategy ensemble (each agent = different strategy)\n- HFT market making (bid/ask agents)", "source": "core\\rl\\multi_agent.py", "category": "risk"}
{"instruction": "What is the MultiAgentRolloutBuffer class and how do I use it?", "input": "", "output": "The MultiAgentRolloutBuffer class:\n\nRollout buffer for multi-agent setting.", "source": "core\\rl\\multi_agent.py", "category": "rl"}
{"instruction": "What is the LiquidityProviderAgent class and how do I use it?", "input": "", "output": "The LiquidityProviderAgent class:\n\nLiquidity Provider Agent (Market Maker).\n\nReference: Vadori et al. (2024), Math Finance\n\nProvides liquidity by posting bid/ask quotes.\nObjective: Maximize spread capture while managing inventory risk.", "source": "core\\rl\\multi_agent.py", "category": "risk"}
{"instruction": "What is the LiquidityTakerAgent class and how do I use it?", "input": "", "output": "The LiquidityTakerAgent class:\n\nLiquidity Taker Agent (Informed Trader).\n\nReference: Vadori et al. (2024), Math Finance\n\nTrades based on private signal/alpha.\nObjective: Maximize returns from directional bets.", "source": "core\\rl\\multi_agent.py", "category": "alpha"}
{"instruction": "What is the JPMorganMARL class and how do I use it?", "input": "", "output": "The JPMorganMARL class:\n\nJ.P. Morgan Multi-Agent RL for Forex.\n\nReference:\n    Vadori et al. (2024)\n    \"Multi-Agent RL in a Realistic Limit Order Book Market\"\n    Mathematical Finance Journal\n\nKey Innovations:\n- Heterogeneous agents (liquidity providers vs takers)\n- Realistic OTC market simulation\n- Market impact modeling (Kyle's lambda)\n- Parameterized reward families\n\nAgent Types:\n1. Liquidity Providers (Market Makers)\n   - Post bid/ask quotes\n   - Earn spread\n   - Manage inventory risk\n\n2. Liquidity Takers (Informed Traders)\n   - Trade on signals\n   - Consume liquidity\n   - Pay spread\n\nReward Design:\n- LP: spread_earned - inventory_penalty - adverse_selection_cost\n- LT: trade_pnl - transaction_costs", "source": "core\\rl\\multi_agent.py", "category": "alpha"}
{"instruction": "What is the MAForexEnv class and how do I use it?", "input": "", "output": "The MAForexEnv class:\n\nMulti-Agent Forex Environment.\n\nWraps base environment to support multiple agents trading simultaneously.", "source": "core\\rl\\multi_agent.py", "category": "rl"}
{"instruction": "What is the formula for Create Multi Agent Trader?", "input": "", "output": "Factory function to create multi-agent RL traders.\n\nArgs:\n    agent_type: One of 'a3c', 'mappo', 'jpmorgan'\n    env: Gym environment\n    config: Multi-agent configuration\n\nReturns:\n    Multi-agent RL trader instance", "source": "core\\rl\\multi_agent.py", "category": "alpha"}
{"instruction": "Explain the Create Multi Agent Trader function", "input": "", "output": "Function: create_multi_agent_trader\n\nFactory function to create multi-agent RL traders.\n\nArgs:\n    agent_type: One of 'a3c', 'mappo', 'jpmorgan'\n    env: Gym environment\n    config: Multi-agent configuration\n\nReturns:\n    Multi-agent RL trader instance", "source": "core\\rl\\multi_agent.py", "category": "alpha"}
{"instruction": "What is PPO in quantitative trading?", "input": "", "output": "PPO (Proximal Policy Optimization).\n\nImplementation details:\nFactory function to create multi-agent RL traders.\n\nArgs:\n    agent_type: One of 'a3c', 'mappo', 'jpmorgan'\n    env: Gym environment\n    config: Multi-agent configuration\n\nReturns:\n    Multi-agent RL trader instance", "source": "core\\rl\\multi_agent.py", "category": "alpha"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nForward pass.\n\nReturns:\n    action_mean, action_log_std, value, new_hidden", "source": "core\\rl\\multi_agent.py", "category": "general"}
{"instruction": "Explain the Get Action function", "input": "", "output": "Function: get_action\n\nSample action from policy.", "source": "core\\rl\\multi_agent.py", "category": "general"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nEstimate joint value for each agent.", "source": "core\\rl\\multi_agent.py", "category": "rl"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nMix agent values into team value.\n\nArgs:\n    agent_values: [batch, n_agents] individual agent values\n\nReturns:\n    team_value: [batch, 1] decomposed team value", "source": "core\\rl\\multi_agent.py", "category": "rl"}
{"instruction": "Explain the Sync With Global function", "input": "", "output": "Function: sync_with_global\n\nCopy global network parameters to local.", "source": "core\\rl\\multi_agent.py", "category": "general"}
{"instruction": "What is the formula for Run?", "input": "", "output": "Run worker until global max steps reached.\n\nAlgorithm from Mnih et al. (2016):\n```\nrepeat:\n    sync_with_global()\n    t_start = t\n    while t - t_start < T_MAX and not terminal:\n        take action, observe reward\n    R = 0 if terminal else V(s_t)\n    for i in [t-1, ..., t_start]:\n        R = r_i + gamma * R\n        accumulate gradients\n    perform async update\n```", "source": "core\\rl\\multi_agent.py", "category": "general"}
{"instruction": "Explain the Run function", "input": "", "output": "Function: run\n\nRun worker until global max steps reached.\n\nAlgorithm from Mnih et al. (2016):\n```\nrepeat:\n    sync_with_global()\n    t_start = t\n    while t - t_start < T_MAX and not terminal:\n        take action, observe reward\n    R = 0 if terminal else V(s_t)\n    for i in [t-1, ..., t_start]:\n        R = r_i + gamma * R\n        accumulate gradients\n    perform async update\n```", "source": "core\\rl\\multi_agent.py", "category": "general"}
{"instruction": "Explain the Learn function", "input": "", "output": "Function: learn\n\nTrain A3C with parallel workers.\n\nArgs:\n    total_timesteps: Maximum training steps\n    callback: Optional callback function", "source": "core\\rl\\multi_agent.py", "category": "general"}
{"instruction": "Explain the Select Action function", "input": "", "output": "Function: select_action\n\nSelect action using global network.", "source": "core\\rl\\multi_agent.py", "category": "general"}
{"instruction": "What is the formula for Train?", "input": "", "output": "Not used - A3C trains asynchronously.", "source": "core\\rl\\multi_agent.py", "category": "general"}
{"instruction": "Explain the Train function", "input": "", "output": "Function: train\n\nNot used - A3C trains asynchronously.", "source": "core\\rl\\multi_agent.py", "category": "general"}
{"instruction": "Explain the Select Action function", "input": "", "output": "Function: select_action\n\nSelect action from individual policy.", "source": "core\\rl\\multi_agent.py", "category": "general"}
{"instruction": "Explain the Select Action function", "input": "", "output": "Function: select_action\n\nSelect action using ensemble of agents.", "source": "core\\rl\\multi_agent.py", "category": "rl"}
{"instruction": "Explain the Select Actions All Agents function", "input": "", "output": "Function: select_actions_all_agents\n\nSelect actions for all agents.", "source": "core\\rl\\multi_agent.py", "category": "rl"}
{"instruction": "Explain the Train function", "input": "", "output": "Function: train\n\nTrain MAPPO with centralized critic.\n\nPPO update for each agent's actor, centralized critic update.", "source": "core\\rl\\multi_agent.py", "category": "rl"}
{"instruction": "What is PPO in quantitative trading?", "input": "", "output": "PPO (Proximal Policy Optimization).\n\nImplementation details:\nTrain MAPPO with centralized critic.\n\nPPO update for each agent's actor, centralized critic update.", "source": "core\\rl\\multi_agent.py", "category": "rl"}
{"instruction": "What is the formula for Get Quotes?", "input": "", "output": "Generate bid/ask quotes.\n\nReturns: (bid_price, ask_price, bid_size, ask_size)", "source": "core\\rl\\multi_agent.py", "category": "microstructure"}
{"instruction": "Explain the Get Quotes function", "input": "", "output": "Function: get_quotes\n\nGenerate bid/ask quotes.\n\nReturns: (bid_price, ask_price, bid_size, ask_size)", "source": "core\\rl\\multi_agent.py", "category": "microstructure"}
{"instruction": "What is the formula for Get Order?", "input": "", "output": "Generate market order.\n\nReturns: (side 'buy'/'sell'/'hold', price, size)", "source": "core\\rl\\multi_agent.py", "category": "general"}
{"instruction": "Explain the Get Order function", "input": "", "output": "Function: get_order\n\nGenerate market order.\n\nReturns: (side 'buy'/'sell'/'hold', price, size)", "source": "core\\rl\\multi_agent.py", "category": "general"}
{"instruction": "Explain the Select Action function", "input": "", "output": "Function: select_action\n\nSelect combined action from all agents.\n\nFor execution, use the average taker signal as trading direction.", "source": "core\\rl\\multi_agent.py", "category": "alpha"}
{"instruction": "Explain the Train function", "input": "", "output": "Function: train\n\nTrain all agents using PPO.", "source": "core\\rl\\multi_agent.py", "category": "rl"}
{"instruction": "What is PPO in quantitative trading?", "input": "", "output": "PPO (Proximal Policy Optimization).\n\nImplementation details:\nTrain all agents using PPO.", "source": "core\\rl\\multi_agent.py", "category": "rl"}
{"instruction": "Explain the Learn function", "input": "", "output": "Function: learn\n\nTrain JPMorgan MARL system.", "source": "core\\rl\\multi_agent.py", "category": "rl"}
{"instruction": "Explain the purpose of Offline Reinforcement Learning for Forex Trading", "input": "", "output": "Offline Reinforcement Learning for Forex Trading\n\nAcademic Citations:\n══════════════════════════════════════════════════════════════════════════════\n\nCQL - Conservative Q-Learning:\n    Kumar et al. (2020)\n    \"Conservative Q-Learning for Offline Reinforcement Learning\"\n    NeurIPS 2020\n    - Penalizes Q-values for OOD (out-of-distribution) actions\n    - Only 20 lines on top of SAC\n    - Achieves 2-5x return improvement on offline data\n    - Best for: Learning from historical forex data safely\n\nBCQ - Batch-Constrained Q-Learning:\n    Fujimoto et al. (2019)\n    \"Off-Policy Deep Reinforcement Learning without Exploration\"\n    ICML 2019\n    - Constrains policy to stay close to behavior policy\n    - Uses VAE to model data distribution\n    - Best for: Limited historical data, high-stakes trading\n\nCFCQL - Counterfactual Conservative Q-Learning:\n    Shao et al. (2023)\n    \"Counterfactual Conservative Q Learning for Offline Multi-Agent RL\"\n    NeurIPS 2023 (OpenReview)\n    - Extends CQL to multi-agent setting\n    - Uses counterfactual baselines for credit assignment\n    - Best for: Multi-currency portfolio optimization\n\nKey Insight:\n══════════════════════════════════════════════════════════════════════════════\nOffline RL is CRITICAL for forex because:\n1. Real trading data is expensive (spread, slippage, commissions)\n2. Historical data is abundant (tick data, OHLCV)\n3. Safe learning without live market risk\n4. Can leverage years of historical patterns\n\nPerformance (from papers):\n| Algorithm | Sharpe | Return vs Behavior Policy |\n|-----------|--------|---------------------------|\n| CQL       | 2.1    | +180%                     |\n| BCQ       | 1.9    | +120%                     |\n| CFCQL     | 2.3    | +210% (multi-agent)       |\n══════════════════════════════════════════════════════════════════════════════", "source": "core\\rl\\offline_rl.py", "category": "risk"}
{"instruction": "What is the OfflineRLConfig class and how do I use it?", "input": "", "output": "The OfflineRLConfig class:\n\nConfiguration for Offline RL algorithms.\n\nExtends base AgentConfig with offline-specific settings.", "source": "core\\rl\\offline_rl.py", "category": "rl"}
{"instruction": "What is the OfflineReplayBuffer class and how do I use it?", "input": "", "output": "The OfflineReplayBuffer class:\n\nStatic Replay Buffer for Offline RL.\n\nStores entire offline dataset without adding new transitions.\nSupports weighted sampling based on reward or priority.", "source": "core\\rl\\offline_rl.py", "category": "rl"}
{"instruction": "What is the CQLCritic class and how do I use it?", "input": "", "output": "The CQLCritic class:\n\nConservative Q-Function for CQL.\n\nReference: Kumar et al. (2020), Section 3\n\nKey insight: Add conservative regularization term:\n    L_CQL = α * E[log(sum_a exp(Q(s,a))) - E_π[Q(s,a)]]\n\nThis penalizes Q-values for OOD actions (not in dataset).", "source": "core\\rl\\offline_rl.py", "category": "general"}
{"instruction": "What is the CQLTrader class and how do I use it?", "input": "", "output": "The CQLTrader class:\n\nConservative Q-Learning Trader.\n\nReference:\n    Kumar et al. (2020)\n    \"Conservative Q-Learning for Offline Reinforcement Learning\"\n    NeurIPS 2020\n\nKey Innovations:\n- Conservative Q-function that lower-bounds true value\n- Penalizes Q(s,a) for actions not in dataset\n- Only ~20 lines added to SAC\n- Safe learning from historical data\n\nAlgorithm:\n```\nL_CQL = α * (E_μ[log(sum_a exp(Q(s,a)))] - E_D[Q(s,a)])\n             + standard SAC loss\n\nwhere:\n- μ is uniform or policy distribution\n- D is the offline dataset\n- α controls conservatism\n```\n\nWhy it works for forex:\n- Historical data contains profitable patterns\n- CQL won't hallucinate returns for untested strategies\n- Safe to deploy after offline training", "source": "core\\rl\\offline_rl.py", "category": "rl"}
{"instruction": "What is the VAE class and how do I use it?", "input": "", "output": "The VAE class:\n\nVariational Autoencoder for BCQ.\n\nReference: Fujimoto et al. (2019), Section 4.1\n\nModels the data distribution p(a|s) to constrain policy.", "source": "core\\rl\\offline_rl.py", "category": "risk"}
{"instruction": "What is the PerturbationNetwork class and how do I use it?", "input": "", "output": "The PerturbationNetwork class:\n\nAction Perturbation Network for BCQ.\n\nReference: Fujimoto et al. (2019), Section 4.2\n\nLearns small perturbations to VAE actions to maximize Q.", "source": "core\\rl\\offline_rl.py", "category": "general"}
{"instruction": "What is the BCQTrader class and how do I use it?", "input": "", "output": "The BCQTrader class:\n\nBatch-Constrained Q-Learning Trader.\n\nReference:\n    Fujimoto et al. (2019)\n    \"Off-Policy Deep Reinforcement Learning without Exploration\"\n    ICML 2019\n\nKey Innovations:\n- VAE models data distribution to constrain policy\n- Only considers actions similar to dataset\n- Perturbation network fine-tunes VAE actions\n- Avoids extrapolation error from OOD actions\n\nAlgorithm:\n```\n1. Train VAE on (s, a) pairs to model p(a|s)\n2. For each state:\n   a. Sample N actions from VAE\n   b. Filter to top-k most likely\n   c. Apply perturbation network\n   d. Select action with highest Q\n```\n\nWhy it works for forex:\n- Only trades strategies seen in historical data\n- No catastrophic exploration in live markets\n- Conservative by design", "source": "core\\rl\\offline_rl.py", "category": "rl"}
{"instruction": "What is the CFCQLTrader class and how do I use it?", "input": "", "output": "The CFCQLTrader class:\n\nCounterfactual Conservative Q-Learning for Multi-Agent.\n\nReference:\n    Shao et al. (2023)\n    \"Counterfactual Conservative Q Learning for Offline Multi-Agent RL\"\n    NeurIPS 2023 Workshop (OpenReview 2024)\n\nKey Innovations:\n- Extends CQL to multi-agent setting\n- Counterfactual baseline for credit assignment\n- Handles coordination in multi-currency portfolio\n\nFor Forex Portfolio:\n- Each currency pair can be modeled as an agent\n- CFCQL assigns credit for portfolio returns\n- Conservative on joint OOD actions", "source": "core\\rl\\offline_rl.py", "category": "rl"}
{"instruction": "What is the formula for Create Offline Trader?", "input": "", "output": "Factory function to create offline RL traders.\n\nArgs:\n    agent_type: One of 'cql', 'bcq', 'cfcql'\n    env: Gym environment\n    config: Offline RL configuration\n    **kwargs: Additional arguments\n\nReturns:\n    Offline RL trader instance", "source": "core\\rl\\offline_rl.py", "category": "alpha"}
{"instruction": "Explain the Create Offline Trader function", "input": "", "output": "Function: create_offline_trader\n\nFactory function to create offline RL traders.\n\nArgs:\n    agent_type: One of 'cql', 'bcq', 'cfcql'\n    env: Gym environment\n    config: Offline RL configuration\n    **kwargs: Additional arguments\n\nReturns:\n    Offline RL trader instance", "source": "core\\rl\\offline_rl.py", "category": "alpha"}
{"instruction": "Explain the Load Forex Dataset function", "input": "", "output": "Function: load_forex_dataset\n\nLoad forex data into offline buffer.\n\nArgs:\n    parquet_path: Path to parquet file\n    state_cols: Column names for state features\n    action_col: Column name for action (position)\n    reward_col: Column name for reward (return)\n    max_size: Maximum buffer size\n\nReturns:\n    OfflineReplayBuffer with loaded data", "source": "core\\rl\\offline_rl.py", "category": "regime"}
{"instruction": "Explain the Load From Numpy function", "input": "", "output": "Function: load_from_numpy\n\nLoad entire dataset at once.", "source": "core\\rl\\offline_rl.py", "category": "general"}
{"instruction": "Explain the Load From Dataframe function", "input": "", "output": "Function: load_from_dataframe\n\nLoad from pandas DataFrame.", "source": "core\\rl\\offline_rl.py", "category": "general"}
{"instruction": "Explain the Sample function", "input": "", "output": "Function: sample\n\nSample batch uniformly.", "source": "core\\rl\\offline_rl.py", "category": "general"}
{"instruction": "What is the formula for Sample Weighted?", "input": "", "output": "Sample batch with reward-weighted priorities.", "source": "core\\rl\\offline_rl.py", "category": "general"}
{"instruction": "Explain the Sample Weighted function", "input": "", "output": "Function: sample_weighted\n\nSample batch with reward-weighted priorities.", "source": "core\\rl\\offline_rl.py", "category": "general"}
{"instruction": "What is the formula for Compute Priorities From Rewards?", "input": "", "output": "Set priorities based on rewards (higher reward = higher priority).", "source": "core\\rl\\offline_rl.py", "category": "general"}
{"instruction": "Explain the Compute Priorities From Rewards function", "input": "", "output": "Function: compute_priorities_from_rewards\n\nSet priorities based on rewards (higher reward = higher priority).", "source": "core\\rl\\offline_rl.py", "category": "general"}
{"instruction": "What is the formula for Forward?", "input": "", "output": "Forward pass returning both Q-values.", "source": "core\\rl\\offline_rl.py", "category": "general"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nForward pass returning both Q-values.", "source": "core\\rl\\offline_rl.py", "category": "general"}
{"instruction": "Explain the Q1 Forward function", "input": "", "output": "Function: q1_forward\n\nForward pass for Q1 only.", "source": "core\\rl\\offline_rl.py", "category": "general"}
{"instruction": "Explain the Select Action function", "input": "", "output": "Function: select_action\n\nSelect action using trained policy.", "source": "core\\rl\\offline_rl.py", "category": "general"}
{"instruction": "What is the formula for Train?", "input": "", "output": "Train CQL on offline batch.\n\nCQL = SAC + Conservative Penalty", "source": "core\\rl\\offline_rl.py", "category": "general"}
{"instruction": "Explain the Train function", "input": "", "output": "Function: train\n\nTrain CQL on offline batch.\n\nCQL = SAC + Conservative Penalty", "source": "core\\rl\\offline_rl.py", "category": "general"}
{"instruction": "Explain the Learn Offline function", "input": "", "output": "Function: learn_offline\n\nTrain on offline dataset.\n\nArgs:\n    dataset: Offline replay buffer with historical data\n    iterations: Number of gradient updates\n    callback: Optional callback for logging", "source": "core\\rl\\offline_rl.py", "category": "general"}
{"instruction": "Explain the Encode function", "input": "", "output": "Function: encode\n\nEncode (s, a) to latent distribution.", "source": "core\\rl\\offline_rl.py", "category": "general"}
{"instruction": "Explain the Decode function", "input": "", "output": "Function: decode\n\nDecode (s, z) to action.", "source": "core\\rl\\offline_rl.py", "category": "general"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nForward pass with reparameterization.", "source": "core\\rl\\offline_rl.py", "category": "general"}
{"instruction": "Explain the Sample function", "input": "", "output": "Function: sample\n\nSample actions from prior.", "source": "core\\rl\\offline_rl.py", "category": "general"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nApply perturbation to action.", "source": "core\\rl\\offline_rl.py", "category": "general"}
{"instruction": "Explain the Select Action function", "input": "", "output": "Function: select_action\n\nSelect action using BCQ procedure.\n\n1. Sample N actions from VAE\n2. Apply perturbation\n3. Select best according to Q", "source": "core\\rl\\offline_rl.py", "category": "general"}
{"instruction": "Explain the Train function", "input": "", "output": "Function: train\n\nTrain BCQ on offline batch.", "source": "core\\rl\\offline_rl.py", "category": "general"}
{"instruction": "Explain the Learn Offline function", "input": "", "output": "Function: learn_offline\n\nTrain on offline dataset.", "source": "core\\rl\\offline_rl.py", "category": "general"}
{"instruction": "Explain the Select Action function", "input": "", "output": "Function: select_action\n\nSelect joint action from all agents.", "source": "core\\rl\\offline_rl.py", "category": "rl"}
{"instruction": "Explain the Train function", "input": "", "output": "Function: train\n\nTrain CFCQL on offline batch.", "source": "core\\rl\\offline_rl.py", "category": "general"}
{"instruction": "Explain the Learn Offline function", "input": "", "output": "Function: learn_offline\n\nTrain on offline dataset.", "source": "core\\rl\\offline_rl.py", "category": "general"}
{"instruction": "Explain the purpose of RL-Based Portfolio Optimization for Forex Trading", "input": "", "output": "RL-Based Portfolio Optimization for Forex Trading\n\nAcademic Citations:\n══════════════════════════════════════════════════════════════════════════════\n\nPortfolio RL:\n    Jiang et al. (2017)\n    \"Deep Reinforcement Learning for Portfolio Management\"\n    arXiv:1706.10059\n\n    Liang et al. (2018)\n    \"Adversarial Deep Reinforcement Learning in Portfolio Management\"\n    arXiv:1808.09940\n\nMean-Variance Optimization:\n    Markowitz (1952)\n    \"Portfolio Selection\"\n    The Journal of Finance, 7(1), 77-91\n\nRisk Parity:\n    Maillard et al. (2010)\n    \"The Properties of Equally Weighted Risk Contribution Portfolios\"\n    The Journal of Portfolio Management\n\nBlack-Litterman:\n    Black & Litterman (1992)\n    \"Global Portfolio Optimization\"\n    Financial Analysts Journal, 48(5), 28-43\n\nKelly Criterion:\n    Kelly (1956)\n    \"A New Interpretation of Information Rate\"\n    Bell System Technical Journal, 35(4), 917-926\n\n══════════════════════════════════════════════════════════════════════════════", "source": "core\\rl\\portfolio.py", "category": "risk"}
{"instruction": "What is the PortfolioConfig class and how do I use it?", "input": "", "output": "The PortfolioConfig class:\n\nConfiguration for Portfolio Optimization.\n\nExtends trading environment config with portfolio-specific settings.", "source": "core\\rl\\portfolio.py", "category": "general"}
{"instruction": "What is the PortfolioEnv class and how do I use it?", "input": "", "output": "The PortfolioEnv class:\n\nMulti-Asset Portfolio Environment with RL-based allocation.\n\nReference:\n    Jiang et al. (2017)\n    \"Deep Reinforcement Learning for Portfolio Management\"\n\nState:\n    - Price returns for each asset (lookback window)\n    - Current portfolio weights\n    - Portfolio statistics (Sharpe, volatility, drawdown)\n\nAction:\n    - Target portfolio weights (sums to max_leverage)\n\nReward:\n    - Risk-adjusted returns (Sharpe ratio component)\n    - Transaction cost penalty\n    - Volatility penalty (if above target)", "source": "core\\rl\\portfolio.py", "category": "volatility"}
{"instruction": "What is the RLPortfolioOptimizer class and how do I use it?", "input": "", "output": "The RLPortfolioOptimizer class:\n\nRL-Based Portfolio Optimizer.\n\nCombines RL with classical portfolio theory:\n- Mean-Variance (Markowitz 1952)\n- Risk Parity (Maillard et al. 2010)\n- Black-Litterman (Black & Litterman 1992)\n- Kelly Criterion (Kelly 1956)\n\nThe RL agent learns to adjust classical portfolio weights\nbased on market conditions.", "source": "core\\rl\\portfolio.py", "category": "risk"}
{"instruction": "What is the formula for Optimize Portfolio Rl?", "input": "", "output": "Train RL-based portfolio optimizer.\n\nArgs:\n    data_dict: Dict mapping asset name -> price array\n    config: Portfolio configuration\n    total_timesteps: Training timesteps\n\nReturns:\n    Trained portfolio optimizer", "source": "core\\rl\\portfolio.py", "category": "rl"}
{"instruction": "Explain the Optimize Portfolio Rl function", "input": "", "output": "Function: optimize_portfolio_rl\n\nTrain RL-based portfolio optimizer.\n\nArgs:\n    data_dict: Dict mapping asset name -> price array\n    config: Portfolio configuration\n    total_timesteps: Training timesteps\n\nReturns:\n    Trained portfolio optimizer", "source": "core\\rl\\portfolio.py", "category": "rl"}
{"instruction": "Explain the Step function", "input": "", "output": "Function: step\n\nExecute portfolio rebalancing step.", "source": "core\\rl\\portfolio.py", "category": "general"}
{"instruction": "Explain the Reset function", "input": "", "output": "Function: reset\n\nReset environment.", "source": "core\\rl\\portfolio.py", "category": "general"}
{"instruction": "What is the formula for Compute Markowitz Weights?", "input": "", "output": "Compute Markowitz mean-variance optimal weights.\n\nReference: Markowitz (1952)\n\"Portfolio Selection\"\n\nw* = (1/γ) * Σ^(-1) * μ\n\nwhere γ is risk aversion, Σ is covariance matrix, μ is expected returns", "source": "core\\rl\\portfolio.py", "category": "risk"}
{"instruction": "Explain the Compute Markowitz Weights function", "input": "", "output": "Function: compute_markowitz_weights\n\nCompute Markowitz mean-variance optimal weights.\n\nReference: Markowitz (1952)\n\"Portfolio Selection\"\n\nw* = (1/γ) * Σ^(-1) * μ\n\nwhere γ is risk aversion, Σ is covariance matrix, μ is expected returns", "source": "core\\rl\\portfolio.py", "category": "risk"}
{"instruction": "Explain the Compute Risk Parity Weights function", "input": "", "output": "Function: compute_risk_parity_weights\n\nCompute Risk Parity weights (equal risk contribution).\n\nReference: Maillard et al. (2010)\n\"The Properties of Equally Weighted Risk Contribution Portfolios\"\n\nEach asset contributes equally to portfolio risk.", "source": "core\\rl\\portfolio.py", "category": "risk"}
{"instruction": "What is the formula for Compute Kelly Weights?", "input": "", "output": "Compute Kelly Criterion optimal weights.\n\nReference: Kelly (1956)\n\"A New Interpretation of Information Rate\"\n\nFractional Kelly: w* = f * (μ / σ²)\n\nwhere f is the Kelly fraction (typically 0.25 for safety)", "source": "core\\rl\\portfolio.py", "category": "risk"}
{"instruction": "Explain the Compute Kelly Weights function", "input": "", "output": "Function: compute_kelly_weights\n\nCompute Kelly Criterion optimal weights.\n\nReference: Kelly (1956)\n\"A New Interpretation of Information Rate\"\n\nFractional Kelly: w* = f * (μ / σ²)\n\nwhere f is the Kelly fraction (typically 0.25 for safety)", "source": "core\\rl\\portfolio.py", "category": "risk"}
{"instruction": "What is Kelly Criterion in quantitative trading?", "input": "", "output": "Kelly Criterion (position sizing formula that maximizes long-term growth).\n\nImplementation details:\nCompute Kelly Criterion optimal weights.\n\nReference: Kelly (1956)\n\"A New Interpretation of Information Rate\"\n\nFractional Kelly: w* = f * (μ / σ²)\n\nwhere f is the Kelly fraction (typically 0.25 for safety)", "source": "core\\rl\\portfolio.py", "category": "risk"}
{"instruction": "Explain the Select Action function", "input": "", "output": "Function: select_action\n\nSelect portfolio weights.", "source": "core\\rl\\portfolio.py", "category": "general"}
{"instruction": "What is the formula for Train?", "input": "", "output": "Train portfolio optimizer (SAC-style).", "source": "core\\rl\\portfolio.py", "category": "general"}
{"instruction": "Explain the Train function", "input": "", "output": "Function: train\n\nTrain portfolio optimizer (SAC-style).", "source": "core\\rl\\portfolio.py", "category": "general"}
{"instruction": "Explain the purpose of Risk-Sensitive Reinforcement Learning for Forex Trading", "input": "", "output": "Risk-Sensitive Reinforcement Learning for Forex Trading\n\nAcademic Citations:\n══════════════════════════════════════════════════════════════════════════════\n\nCVaR (Conditional Value at Risk) RL:\n    Tamar et al. (2015)\n    \"Policy Gradients with Variance Related Risk Criteria\"\n    ICML 2015\n\n    Chow et al. (2017)\n    \"Risk-Constrained Reinforcement Learning with Percentile Risk Criteria\"\n    JMLR 18(1), 1-51\n\n    Urpi et al. (2021)\n    \"Risk-Averse Offline Reinforcement Learning\"\n    ICLR 2021\n\nDrawdown-Constrained RL:\n    Yang et al. (2021)\n    \"Risk-Aware Portfolio Optimization with Deep RL\"\n    NeurIPS 2021 Workshop\n\n    Tamar et al. (2012)\n    \"Policy Gradients with Expected Quadratic Risk Constraints\"\n\nTail Risk and Safe RL:\n    Garcıa & Fernández (2015)\n    \"A Comprehensive Survey on Safe RL\"\n    JMLR 16(1), 1437-1480\n\n    Achiam et al. (2017)\n    \"Constrained Policy Optimization\"\n    ICML 2017\n\n    Bharadhwaj et al. (2021)\n    \"Conservative Safety Critics for Exploration\"\n    ICLR 2021\n\nMulti-Agent Forex RL:\n    arXiv:2405.19982\n    \"Multi-Agent Reinforcement Learning for Forex Trading\"\n\n══════════════════════════════════════════════════════════════════════════════\nRisk-sensitive RL is CRITICAL for forex trading because:\n1. CVaR controls tail risk (worst 5% of outcomes)\n2. Drawdown constraints prevent account blowup\n3. Safe RL ensures trading within risk limits\n══════════════════════════════════════════════════════════════════════════════", "source": "core\\rl\\risk_sensitive.py", "category": "risk"}
{"instruction": "What is the RiskSensitiveConfig class and how do I use it?", "input": "", "output": "The RiskSensitiveConfig class:\n\nConfiguration for Risk-Sensitive RL Agents.\n\nExtends base AgentConfig with risk parameters.", "source": "core\\rl\\risk_sensitive.py", "category": "risk"}
{"instruction": "What is the CVaRPPO class and how do I use it?", "input": "", "output": "The CVaRPPO class:\n\nCVaR-Constrained Proximal Policy Optimization.\n\nReference:\n    Tamar et al. (2015)\n    \"Policy Gradients with Variance Related Risk Criteria\"\n    ICML 2015\n\n    Chow et al. (2017)\n    \"Risk-Constrained RL with Percentile Risk Criteria\"\n    JMLR\n\nCVaR (Conditional Value at Risk) focuses on the expected value in the\nWORST α% of outcomes. For α=0.05, this is the average of the worst 5%\nof returns - critical for avoiding tail risk in forex trading.\n\nThe objective becomes:\n    max E[R] - λ * CVaR_α(-R)\n\nWhere CVaR_α(-R) is the expected loss in the worst α% of scenarios.", "source": "core\\rl\\risk_sensitive.py", "category": "risk"}
{"instruction": "What is the DrawdownConstrainedPPO class and how do I use it?", "input": "", "output": "The DrawdownConstrainedPPO class:\n\nDrawdown-Constrained PPO using Lagrangian relaxation.\n\nReference:\n    Yang et al. (2021)\n    \"Risk-Aware Portfolio Optimization with Deep RL\"\n    NeurIPS Workshop\n\n    Achiam et al. (2017)\n    \"Constrained Policy Optimization\"\n    ICML 2017\n\nThis agent maximizes returns while constraining maximum drawdown:\n    max E[R]\n    s.t. E[Drawdown] ≤ d_max\n\nThe Lagrangian relaxation becomes:\n    L = E[R] - λ * (E[Drawdown] - d_max)\n\nWhere λ is learned via dual gradient ascent.", "source": "core\\rl\\risk_sensitive.py", "category": "risk"}
{"instruction": "What is the DrawdownBuffer class and how do I use it?", "input": "", "output": "The DrawdownBuffer class:\n\nExtended rollout buffer with drawdown tracking.", "source": "core\\rl\\risk_sensitive.py", "category": "risk"}
{"instruction": "What is the TailSafePPO class and how do I use it?", "input": "", "output": "The TailSafePPO class:\n\nTail-Safe PPO with extreme event protection.\n\nReference:\n    Garcıa & Fernández (2015)\n    \"A Comprehensive Survey on Safe RL\"\n    JMLR\n\n    Bharadhwaj et al. (2021)\n    \"Conservative Safety Critics for Exploration\"\n    ICLR 2021\n\nThis agent combines multiple risk measures:\n1. CVaR for tail risk\n2. Drawdown constraints for account protection\n3. Position limits for exposure control\n\nThe objective is:\n    max E[R]\n    s.t. CVaR_α(-R) ≤ c_1\n         max_drawdown ≤ c_2\n         |position| ≤ c_3", "source": "core\\rl\\risk_sensitive.py", "category": "risk"}
{"instruction": "What is the formula for Create Risk Sensitive Agent?", "input": "", "output": "Factory function to create risk-sensitive RL agents.\n\nArgs:\n    agent_type: One of 'cvar_ppo', 'drawdown_ppo', 'tail_safe'\n    env: Gym environment\n    config: Agent configuration\n\nReturns:\n    Risk-sensitive RL agent", "source": "core\\rl\\risk_sensitive.py", "category": "alpha"}
{"instruction": "Explain the Create Risk Sensitive Agent function", "input": "", "output": "Function: create_risk_sensitive_agent\n\nFactory function to create risk-sensitive RL agents.\n\nArgs:\n    agent_type: One of 'cvar_ppo', 'drawdown_ppo', 'tail_safe'\n    env: Gym environment\n    config: Agent configuration\n\nReturns:\n    Risk-sensitive RL agent", "source": "core\\rl\\risk_sensitive.py", "category": "alpha"}
{"instruction": "What is PPO in quantitative trading?", "input": "", "output": "PPO (Proximal Policy Optimization).\n\nImplementation details:\nFactory function to create risk-sensitive RL agents.\n\nArgs:\n    agent_type: One of 'cvar_ppo', 'drawdown_ppo', 'tail_safe'\n    env: Gym environment\n    config: Agent configuration\n\nReturns:\n    Risk-sensitive RL agent", "source": "core\\rl\\risk_sensitive.py", "category": "alpha"}
{"instruction": "What is the formula for Compute Cvar?", "input": "", "output": "Compute CVaR (Conditional Value at Risk).\n\nReference: Rockafellar & Uryasev (2000)\n\"Optimization of Conditional Value-at-Risk\"\nJournal of Risk\n\nCVaR_α(X) = E[X | X ≤ VaR_α(X)]\n\nReturns:\n    var: Value at Risk (α-quantile)\n    cvar: Conditional Value at Risk", "source": "core\\rl\\risk_sensitive.py", "category": "risk"}
{"instruction": "Explain the Compute Cvar function", "input": "", "output": "Function: compute_cvar\n\nCompute CVaR (Conditional Value at Risk).\n\nReference: Rockafellar & Uryasev (2000)\n\"Optimization of Conditional Value-at-Risk\"\nJournal of Risk\n\nCVaR_α(X) = E[X | X ≤ VaR_α(X)]\n\nReturns:\n    var: Value at Risk (α-quantile)\n    cvar: Conditional Value at Risk", "source": "core\\rl\\risk_sensitive.py", "category": "risk"}
{"instruction": "What is the formula for Compute Cvar Loss?", "input": "", "output": "Compute CVaR loss using the dual formulation.\n\nReference: Chow et al. (2017)\n\nL_CVaR = var_threshold + (1/α) * E[max(0, -R - var_threshold)]", "source": "core\\rl\\risk_sensitive.py", "category": "risk"}
{"instruction": "Explain the Compute Cvar Loss function", "input": "", "output": "Function: compute_cvar_loss\n\nCompute CVaR loss using the dual formulation.\n\nReference: Chow et al. (2017)\n\nL_CVaR = var_threshold + (1/α) * E[max(0, -R - var_threshold)]", "source": "core\\rl\\risk_sensitive.py", "category": "risk"}
{"instruction": "What is the formula for Train?", "input": "", "output": "Train CVaR-PPO agent.", "source": "core\\rl\\risk_sensitive.py", "category": "risk"}
{"instruction": "Explain the Train function", "input": "", "output": "Function: train\n\nTrain CVaR-PPO agent.", "source": "core\\rl\\risk_sensitive.py", "category": "risk"}
{"instruction": "What is PPO in quantitative trading?", "input": "", "output": "PPO (Proximal Policy Optimization).\n\nImplementation details:\nTrain CVaR-PPO agent.", "source": "core\\rl\\risk_sensitive.py", "category": "risk"}
{"instruction": "Explain the Update Drawdown function", "input": "", "output": "Function: update_drawdown\n\nUpdate drawdown tracking.", "source": "core\\rl\\risk_sensitive.py", "category": "risk"}
{"instruction": "What is the formula for Compute Drawdown Cost?", "input": "", "output": "Compute drawdown constraint violation.\n\nCost = max(0, drawdown - max_drawdown)", "source": "core\\rl\\risk_sensitive.py", "category": "risk"}
{"instruction": "Explain the Compute Drawdown Cost function", "input": "", "output": "Function: compute_drawdown_cost\n\nCompute drawdown constraint violation.\n\nCost = max(0, drawdown - max_drawdown)", "source": "core\\rl\\risk_sensitive.py", "category": "risk"}
{"instruction": "What is the formula for Train?", "input": "", "output": "Train Drawdown-Constrained PPO.", "source": "core\\rl\\risk_sensitive.py", "category": "risk"}
{"instruction": "Explain the Train function", "input": "", "output": "Function: train\n\nTrain Drawdown-Constrained PPO.", "source": "core\\rl\\risk_sensitive.py", "category": "risk"}
{"instruction": "What is PPO in quantitative trading?", "input": "", "output": "PPO (Proximal Policy Optimization).\n\nImplementation details:\nTrain Drawdown-Constrained PPO.", "source": "core\\rl\\risk_sensitive.py", "category": "risk"}
{"instruction": "Explain the Select Action function", "input": "", "output": "Function: select_action\n\nSelect action with safety check.", "source": "core\\rl\\risk_sensitive.py", "category": "general"}
{"instruction": "Explain the Compute Tail Risk Penalty function", "input": "", "output": "Function: compute_tail_risk_penalty\n\nCompute tail risk penalty.\n\nCombines CVaR and extreme event detection.", "source": "core\\rl\\risk_sensitive.py", "category": "risk"}
{"instruction": "What is the formula for Train?", "input": "", "output": "Train Tail-Safe PPO.", "source": "core\\rl\\risk_sensitive.py", "category": "rl"}
{"instruction": "Explain the Train function", "input": "", "output": "Function: train\n\nTrain Tail-Safe PPO.", "source": "core\\rl\\risk_sensitive.py", "category": "rl"}
{"instruction": "What is PPO in quantitative trading?", "input": "", "output": "PPO (Proximal Policy Optimization).\n\nImplementation details:\nTrain Tail-Safe PPO.", "source": "core\\rl\\risk_sensitive.py", "category": "rl"}
{"instruction": "Explain the purpose of TradeMaster Trading Algorithms (南洋理工大学)", "input": "", "output": "TradeMaster Trading Algorithms (南洋理工大学)\n\nAcademic Citations:\n══════════════════════════════════════════════════════════════════════════════\n\nTRADEMASTER PLATFORM:\n\n1. TradeMaster:\n   Sun et al. (2023)\n   \"TradeMaster: A Holistic Quantitative Trading Platform Empowered by RL\"\n   南洋理工大学 AMI Research Group\n   GitHub: TradeMaster-NTU/TradeMaster (1.2k+ stars)\n   NeurIPS 2023 Workshop\n\n   Platform covers:\n   - 4 financial markets (中国, US, Crypto, Forex)\n   - 6 trading scenarios\n   - 15 RL algorithms\n   - 17 evaluation metrics\n\nSPECIALIZED TRADING ALGORITHMS:\n\n2. DeepScalper:\n   \"Deep Scalping: Intraday Trading via DRL\"\n   High-frequency intraday trading with tick-level execution\n\n3. OPD (Optimal Portfolio Diversification):\n   \"Optimal Portfolio Diversification via RL\"\n   Risk-aware portfolio construction\n\n4. DeepTrader:\n   Wang et al. (2021)\n   \"DeepTrader: A DRL Approach for Risk-Return Balanced Portfolio\"\n   AAAI 2021\n\n5. SARL (State-Augmented RL):\n   \"State Augmentation for Robust Trading\"\n   Handles distribution shift in financial markets\n\n6. ETTO (Efficient Two-Timescale Optimization):\n   \"Two-Timescale RL for Order Execution\"\n   Separates strategic and tactical decisions\n\n7. Investor-Imitator:\n   \"Learning from Expert Investors via Imitation\"\n   Behavioral cloning + RL fine-tuning\n\n8. EIIE (Ensemble of Identical Independent Evaluators):\n   Jiang et al. (2017)\n   \"Deep Reinforcement Learning for Portfolio Management\"\n   arXiv:1706.10059\n\nCHINESE ACADEMIC RESEARCH:\n\n9. T-DQN (同济本科生):\n   \"Transformer-enhanced DQN for Stock Trading\"\n   Result: 280% max return in volatile markets\n\n10. 百度飞桨 (PaddlePaddle) DRL:\n    DDPG, TD3, SAC implementations for forex/stock\n\n══════════════════════════════════════════════════════════════════════════════\nTRADEMASTER 6 TRADING SCENARIOS:\n1. 加密货币交易 (Crypto Trading)\n2. 资产组合管理 (Portfolio Management)\n3. 日内交易 (Intraday Trading)\n4. 订单执行 (Order Execution)\n5. 高频交易 (HFT)\n6. 做市 (Market Making)\n══════════════════════════════════════════════════════════════════════════════", "source": "core\\rl\\trademaster.py", "category": "volatility"}
{"instruction": "What is the TradeMasterConfig class and how do I use it?", "input": "", "output": "The TradeMasterConfig class:\n\nConfiguration for TradeMaster algorithms.\n\nBased on TradeMaster platform configuration.", "source": "core\\rl\\trademaster.py", "category": "general"}
{"instruction": "What is the DeepScalper class and how do I use it?", "input": "", "output": "The DeepScalper class:\n\nDeepScalper: High-Frequency Intraday Trading.\n\nReference:\n    TradeMaster Team (2023)\n    \"Deep Scalping: Intraday Trading via DRL\"\n\nSpecialized for:\n- Tick-level decision making\n- Very short holding periods (seconds to minutes)\n- High trade frequency with small profits per trade\n\nState includes:\n- Order book features (bid/ask, depth, imbalance)\n- Recent tick returns\n- Current position and PnL\n- Time features", "source": "core\\rl\\trademaster.py", "category": "microstructure"}
{"instruction": "What is the DeepTrader class and how do I use it?", "input": "", "output": "The DeepTrader class:\n\nDeepTrader: Risk-Return Balanced Portfolio Management.\n\nReference:\n    Wang et al. (2021)\n    \"DeepTrader: A DRL Approach for Risk-Return Balanced Portfolio\"\n    AAAI 2021\n\nKey innovations:\n- Explicit risk modeling in state representation\n- Multi-objective reward (return + risk penalty)\n- Adaptive position sizing based on volatility", "source": "core\\rl\\trademaster.py", "category": "volatility"}
{"instruction": "What is the EIIE class and how do I use it?", "input": "", "output": "The EIIE class:\n\nEIIE: Ensemble of Identical Independent Evaluators.\n\nReference:\n    Jiang et al. (2017)\n    \"Deep Reinforcement Learning for Portfolio Management\"\n    arXiv:1706.10059\n\nKey innovations:\n- CNN for price pattern recognition\n- Independent evaluators for each asset\n- Portfolio vector memory for temporal consistency", "source": "core\\rl\\trademaster.py", "category": "rl"}
{"instruction": "What is the SARL class and how do I use it?", "input": "", "output": "The SARL class:\n\nSARL: State-Augmented Reinforcement Learning.\n\nHandles distribution shift in financial markets by augmenting\nstate with market regime indicators and historical performance.", "source": "core\\rl\\trademaster.py", "category": "rl"}
{"instruction": "What is the InvestorImitator class and how do I use it?", "input": "", "output": "The InvestorImitator class:\n\nInvestor-Imitator: Learning from Expert Investors.\n\nCombines behavioral cloning (imitation) with RL fine-tuning.\n\nTraining process:\n1. Pre-train on expert trader data (behavioral cloning)\n2. Fine-tune with RL in simulated environment", "source": "core\\rl\\trademaster.py", "category": "rl"}
{"instruction": "What is the TradeMasterAgent class and how do I use it?", "input": "", "output": "The TradeMasterAgent class:\n\nUnified TradeMaster Agent.\n\nProvides access to all TradeMaster algorithms with consistent interface.", "source": "core\\rl\\trademaster.py", "category": "rl"}
{"instruction": "What is the formula for Create Trademaster Agent?", "input": "", "output": "Factory function to create TradeMaster agent.\n\nArgs:\n    algorithm: Algorithm name\n    state_dim: State dimension\n    action_dim: Action dimension\n    config: Configuration\n    **kwargs: Algorithm-specific parameters\n\nReturns:\n    TradeMasterAgent instance", "source": "core\\rl\\trademaster.py", "category": "alpha"}
{"instruction": "Explain the Create Trademaster Agent function", "input": "", "output": "Function: create_trademaster_agent\n\nFactory function to create TradeMaster agent.\n\nArgs:\n    algorithm: Algorithm name\n    state_dim: State dimension\n    action_dim: Action dimension\n    config: Configuration\n    **kwargs: Algorithm-specific parameters\n\nReturns:\n    TradeMasterAgent instance", "source": "core\\rl\\trademaster.py", "category": "alpha"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nForward pass.", "source": "core\\rl\\trademaster.py", "category": "general"}
{"instruction": "Explain the Get Action function", "input": "", "output": "Function: get_action\n\nGet scalping action with profit filter.\n\nOnly trades if profit probability > threshold.", "source": "core\\rl\\trademaster.py", "category": "general"}
{"instruction": "What is OFI in quantitative trading?", "input": "", "output": "OFI (Order Flow Imbalance).\n\nImplementation details:\nGet scalping action with profit filter.\n\nOnly trades if profit probability > threshold.", "source": "core\\rl\\trademaster.py", "category": "general"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nForward pass with risk awareness.", "source": "core\\rl\\trademaster.py", "category": "risk"}
{"instruction": "Explain the Get Weights function", "input": "", "output": "Function: get_weights\n\nGet portfolio weights.", "source": "core\\rl\\trademaster.py", "category": "general"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nForward pass.\n\nArgs:\n    price_tensor: Price features for each asset\n    previous_weights: Previous portfolio weights (including cash)\n\nReturns:\n    New portfolio weights (including cash)", "source": "core\\rl\\trademaster.py", "category": "general"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nForward pass with state augmentation.", "source": "core\\rl\\trademaster.py", "category": "regime"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nForward pass.", "source": "core\\rl\\trademaster.py", "category": "general"}
{"instruction": "Explain the Imitation Loss function", "input": "", "output": "Function: imitation_loss\n\nBehavioral cloning loss.", "source": "core\\rl\\trademaster.py", "category": "general"}
{"instruction": "Explain the Select Action function", "input": "", "output": "Function: select_action\n\nSelect action using the chosen algorithm.", "source": "core\\rl\\trademaster.py", "category": "general"}
{"instruction": "Explain the purpose of RL Training Utilities for Forex Trading", "input": "", "output": "RL Training Utilities for Forex Trading\n\nAcademic Citations:\n══════════════════════════════════════════════════════════════════════════════\n\nTraining Best Practices:\n    Henderson et al. (2018)\n    \"Deep Reinforcement Learning that Matters\"\n    AAAI 2018\n    Key insight: Hyperparameter tuning and evaluation methodology matter more\n    than algorithm choice for many tasks.\n\nEvaluation Metrics:\n    Colas et al. (2019)\n    \"How Many Random Seeds? Statistical Power Analysis in Deep RL\"\n    arXiv:1806.08295\n    Recommendation: Use 10+ seeds for reliable comparisons.\n\nCurriculum Learning:\n    Bengio et al. (2009)\n    \"Curriculum Learning\"\n    ICML 2009\n    Start with easy samples, gradually increase difficulty.\n\nFinRL Training:\n    Liu et al. (2020)\n    \"FinRL: A Deep RL Library for Automated Stock Trading\"\n    NeurIPS Deep RL Workshop\n    Training pipeline for financial RL.\n\n══════════════════════════════════════════════════════════════════════════════", "source": "core\\rl\\trainer.py", "category": "microstructure"}
{"instruction": "What is the TrainingConfig class and how do I use it?", "input": "", "output": "The TrainingConfig class:\n\nConfiguration for RL training.\n\nBased on Henderson et al. (2018) best practices.", "source": "core\\rl\\trainer.py", "category": "rl"}
{"instruction": "What is the RLTrainer class and how do I use it?", "input": "", "output": "The RLTrainer class:\n\nRL Training Pipeline for Forex Trading.\n\nFeatures:\n- Multi-seed training (Colas et al. 2019)\n- Curriculum learning (Bengio et al. 2009)\n- Early stopping\n- Logging and checkpointing\n- Hyperparameter optimization with Optuna\n\nReference:\n    Liu et al. (2020)\n    \"FinRL: A Deep RL Library for Automated Stock Trading\"", "source": "core\\rl\\trainer.py", "category": "rl"}
{"instruction": "What is the CurriculumTrainer class and how do I use it?", "input": "", "output": "The CurriculumTrainer class:\n\nCurriculum Learning Trainer.\n\nReference:\n    Bengio et al. (2009)\n    \"Curriculum Learning\"\n    ICML 2009\n\nStarts with easy samples and gradually increases difficulty.\nFor forex: start with low volatility periods, progress to high volatility.", "source": "core\\rl\\trainer.py", "category": "volatility"}
{"instruction": "Explain the Train Rl Agent function", "input": "", "output": "Function: train_rl_agent\n\nConvenience function to train RL agent.\n\nArgs:\n    env: Training environment\n    agent_type: Type of agent ('ppo', 'sac', 'a2c', 'td3', 'dqn', 'ddpg')\n    agent_config: Agent configuration\n    training_config: Training configuration\n    callback: Optional callback\n\nReturns:\n    Trained agent and training results", "source": "core\\rl\\trainer.py", "category": "rl"}
{"instruction": "What is DQN in quantitative trading?", "input": "", "output": "DQN (Deep Q-Network for trading).\n\nImplementation details:\nConvenience function to train RL agent.\n\nArgs:\n    env: Training environment\n    agent_type: Type of agent ('ppo', 'sac', 'a2c', 'td3', 'dqn', 'ddpg')\n    agent_config: Agent configuration\n    training_config: Training configuration\n    callback: Optional callback\n\nReturns:\n    Trained agent and training results", "source": "core\\rl\\trainer.py", "category": "rl"}
{"instruction": "What is PPO in quantitative trading?", "input": "", "output": "PPO (Proximal Policy Optimization).\n\nImplementation details:\nConvenience function to train RL agent.\n\nArgs:\n    env: Training environment\n    agent_type: Type of agent ('ppo', 'sac', 'a2c', 'td3', 'dqn', 'ddpg')\n    agent_config: Agent configuration\n    training_config: Training configuration\n    callback: Optional callback\n\nReturns:\n    Trained agent and training results", "source": "core\\rl\\trainer.py", "category": "rl"}
{"instruction": "Explain the Evaluate Agent function", "input": "", "output": "Function: evaluate_agent\n\nComprehensive agent evaluation.\n\nReturns detailed performance metrics.", "source": "core\\rl\\trainer.py", "category": "rl"}
{"instruction": "Explain the Evaluate function", "input": "", "output": "Function: evaluate\n\nEvaluate agent performance.\n\nReference: Henderson et al. (2018)\n\"Deep Reinforcement Learning that Matters\"", "source": "core\\rl\\trainer.py", "category": "rl"}
{"instruction": "Explain the Train Single Seed function", "input": "", "output": "Function: train_single_seed\n\nTrain agent with single seed.\n\nArgs:\n    seed: Random seed\n    callback: Optional callback function\n\nReturns:\n    Trained agent and training history", "source": "core\\rl\\trainer.py", "category": "rl"}
{"instruction": "Explain the Train function", "input": "", "output": "Function: train\n\nTrain agent with multiple seeds.\n\nReference: Colas et al. (2019)\n\"How Many Random Seeds? Statistical Power Analysis in Deep RL\"", "source": "core\\rl\\trainer.py", "category": "rl"}
{"instruction": "Explain the Should Advance function", "input": "", "output": "Function: should_advance\n\nCheck if should advance to next curriculum stage.", "source": "core\\rl\\trainer.py", "category": "general"}
{"instruction": "Explain the Train Curriculum function", "input": "", "output": "Function: train_curriculum\n\nTrain with curriculum learning.\n\nProgress through increasingly difficult environments.", "source": "core\\rl\\trainer.py", "category": "general"}
{"instruction": "Explain the purpose of World Model Reinforcement Learning for Forex Trading", "input": "", "output": "World Model Reinforcement Learning for Forex Trading\n\nAcademic Citations:\n══════════════════════════════════════════════════════════════════════════════\n\nDreamerV3:\n    Hafner et al. (2025)\n    \"Mastering Diverse Domains through World Models\"\n    Nature (originally arXiv:2301.04104)\n    - Learns latent dynamics model of environment\n    - Plans in imagination without real interactions\n    - 10-15% sample efficiency improvement\n    - State-of-the-art on diverse benchmarks\n\nSafeDreamer:\n    Zhang et al. (2024)\n    \"SafeDreamer: World Models for Safe Robot Learning\"\n    ICLR 2024 (PKU)\n    - Extends Dreamer with Lagrangian safety constraints\n    - Safe policy learning in imagination\n    - Best for: Risk-controlled trading\n\nWorld Models:\n    Ha & Schmidhuber (2018)\n    \"World Models\"\n    NeurIPS 2018\n    - VAE for visual encoding + RNN for dynamics\n    - Foundation for Dreamer series\n\nRSSM (Recurrent State-Space Model):\n    Hafner et al. (2019)\n    \"Learning Latent Dynamics for Planning from Pixels\"\n    ICML 2019\n    - Stochastic + deterministic latent state\n    - Captures uncertainty in dynamics\n\nKey Benefits for Forex:\n══════════════════════════════════════════════════════════════════════════════\n1. Sample Efficiency: Learn from fewer real trades\n2. Rare Event Handling: Imagine black swan scenarios\n3. Risk-Free Planning: Test strategies in imagination\n4. Multi-step Planning: Look ahead without execution\n\nPerformance:\n| Algorithm    | Sample Eff. | Sharpe | Max DD  |\n|--------------|-------------|--------|---------|\n| DreamerV3    | +15%        | 2.4    | -5.2%   |\n| SafeDreamer  | +12%        | 2.1    | -3.8%   |\n══════════════════════════════════════════════════════════════════════════════", "source": "core\\rl\\world_model.py", "category": "volatility"}
{"instruction": "What is the WorldModelConfig class and how do I use it?", "input": "", "output": "The WorldModelConfig class:\n\nConfiguration for World Model RL.\n\nExtends base AgentConfig with world model specific settings.", "source": "core\\rl\\world_model.py", "category": "rl"}
{"instruction": "What is the RSSM class and how do I use it?", "input": "", "output": "The RSSM class:\n\nRecurrent State-Space Model.\n\nReference: Hafner et al. (2019), \"PlaNet\"\n\nState = (stochastic z, deterministic h)\n- h: GRU hidden state (captures history)\n- z: Stochastic latent (captures uncertainty)\n\nTransitions:\n    Prior:     p(z_t | h_t) = Cat(softmax(W_prior * h_t))\n    Posterior: q(z_t | h_t, o_t) = Cat(softmax(W_post * [h_t, embed(o_t)]))\n    Recurrent: h_t = GRU(h_{t-1}, z_{t-1}, a_{t-1})", "source": "core\\rl\\world_model.py", "category": "volatility"}
{"instruction": "What is the Encoder class and how do I use it?", "input": "", "output": "The Encoder class:\n\nObservation Encoder.\n\nFor forex: Encodes price/feature vector to embedding.", "source": "core\\rl\\world_model.py", "category": "general"}
{"instruction": "What is the Decoder class and how do I use it?", "input": "", "output": "The Decoder class:\n\nObservation Decoder.\n\nReconstructs observation from RSSM state.", "source": "core\\rl\\world_model.py", "category": "regime"}
{"instruction": "What is the RewardPredictor class and how do I use it?", "input": "", "output": "The RewardPredictor class:\n\nPredicts reward from RSSM state.", "source": "core\\rl\\world_model.py", "category": "regime"}
{"instruction": "What is the ContinuePredictor class and how do I use it?", "input": "", "output": "The ContinuePredictor class:\n\nPredicts episode continuation (1 - done).", "source": "core\\rl\\world_model.py", "category": "general"}
{"instruction": "What is the CostPredictor class and how do I use it?", "input": "", "output": "The CostPredictor class:\n\nPredicts cost/risk from RSSM state (for SafeDreamer).", "source": "core\\rl\\world_model.py", "category": "risk"}
{"instruction": "What is the DreamerActor class and how do I use it?", "input": "", "output": "The DreamerActor class:\n\nActor Network for Dreamer.\n\nOperates in latent space (RSSM features).", "source": "core\\rl\\world_model.py", "category": "general"}
{"instruction": "What is the DreamerCritic class and how do I use it?", "input": "", "output": "The DreamerCritic class:\n\nCritic Network for Dreamer.\n\nEstimates value in latent space.", "source": "core\\rl\\world_model.py", "category": "general"}
{"instruction": "What is the DreamerTrader class and how do I use it?", "input": "", "output": "The DreamerTrader class:\n\nDreamerV3 Trader.\n\nReference:\n    Hafner et al. (2025)\n    \"Mastering Diverse Domains through World Models\"\n    Nature\n\nKey Innovations:\n- Learns latent dynamics model (RSSM)\n- Plans in imagination without real interactions\n- 10-15% sample efficiency improvement\n- Handles multi-step credit assignment\n\nAlgorithm:\n```\n1. Collect real experience\n2. Train world model on real data\n3. Imagine trajectories from model\n4. Train actor/critic on imagined data\n5. Execute actor in real environment\n```\n\nWhy it works for forex:\n- Sample efficient (fewer real trades needed)\n- Can imagine rare market conditions\n- Multi-step planning for swing trades\n- Model uncertainty guides exploration", "source": "core\\rl\\world_model.py", "category": "rl"}
{"instruction": "What is the SafeDreamerTrader class and how do I use it?", "input": "", "output": "The SafeDreamerTrader class:\n\nSafeDreamer Trader with Lagrangian Constraints.\n\nReference:\n    Zhang et al. (2024)\n    \"SafeDreamer: World Models for Safe Robot Learning\"\n    ICLR 2024 (PKU)\n\nKey Innovations:\n- Adds cost predictor to world model\n- Lagrangian dual optimization for constraints\n- Safe policy learning in imagination\n- Prevents drawdown/risk violations\n\nObjective:\n    max E[Σ r_t]\n    s.t. E[Σ c_t] ≤ d\n\nwhere c_t is trading cost/risk and d is threshold.\n\nWhy it works for forex:\n- Enforces max drawdown constraint\n- Controls tail risk in imagination\n- Safe exploration of new strategies", "source": "core\\rl\\world_model.py", "category": "risk"}
{"instruction": "Explain the Create World Model Trader function", "input": "", "output": "Function: create_world_model_trader\n\nFactory function to create world model RL traders.\n\nArgs:\n    agent_type: One of 'dreamer', 'safe_dreamer'\n    env: Gym environment\n    config: World model configuration\n\nReturns:\n    World model RL trader instance", "source": "core\\rl\\world_model.py", "category": "alpha"}
{"instruction": "Explain the Initial State function", "input": "", "output": "Function: initial_state\n\nGet initial RSSM state.", "source": "core\\rl\\world_model.py", "category": "regime"}
{"instruction": "What is the formula for Get Stoch?", "input": "", "output": "Sample stochastic state from logits using straight-through Gumbel-Softmax.", "source": "core\\rl\\world_model.py", "category": "volatility"}
{"instruction": "Explain the Get Stoch function", "input": "", "output": "Function: get_stoch\n\nSample stochastic state from logits using straight-through Gumbel-Softmax.", "source": "core\\rl\\world_model.py", "category": "volatility"}
{"instruction": "What is the formula for Img Step?", "input": "", "output": "Imagination step (no observation, use prior).\n\nh_t = GRU(h_{t-1}, z_{t-1}, a_{t-1})\nz_t ~ Prior(h_t)", "source": "core\\rl\\world_model.py", "category": "general"}
{"instruction": "Explain the Img Step function", "input": "", "output": "Function: img_step\n\nImagination step (no observation, use prior).\n\nh_t = GRU(h_{t-1}, z_{t-1}, a_{t-1})\nz_t ~ Prior(h_t)", "source": "core\\rl\\world_model.py", "category": "general"}
{"instruction": "Explain the Obs Step function", "input": "", "output": "Function: obs_step\n\nObservation step (use posterior).\n\nReturns both prior and posterior states for KL loss.", "source": "core\\rl\\world_model.py", "category": "regime"}
{"instruction": "What is the formula for Get Feature?", "input": "", "output": "Get feature vector from RSSM state (for actor/critic).", "source": "core\\rl\\world_model.py", "category": "regime"}
{"instruction": "Explain the Get Feature function", "input": "", "output": "Function: get_feature\n\nGet feature vector from RSSM state (for actor/critic).", "source": "core\\rl\\world_model.py", "category": "regime"}
{"instruction": "Explain the Forward function", "input": "", "output": "Function: forward\n\nForward pass returning mean and std.", "source": "core\\rl\\world_model.py", "category": "general"}
{"instruction": "Explain the Sample function", "input": "", "output": "Function: sample\n\nSample action with log probability.", "source": "core\\rl\\world_model.py", "category": "general"}
{"instruction": "Explain the Select Action function", "input": "", "output": "Function: select_action\n\nSelect action using actor in latent space.", "source": "core\\rl\\world_model.py", "category": "general"}
{"instruction": "What is the formula for Train?", "input": "", "output": "Train Dreamer on batch.\n\n1. Train world model on real data\n2. Imagine trajectories\n3. Train actor-critic on imagined data", "source": "core\\rl\\world_model.py", "category": "rl"}
{"instruction": "Explain the Train function", "input": "", "output": "Function: train\n\nTrain Dreamer on batch.\n\n1. Train world model on real data\n2. Imagine trajectories\n3. Train actor-critic on imagined data", "source": "core\\rl\\world_model.py", "category": "rl"}
{"instruction": "Explain the Learn function", "input": "", "output": "Function: learn\n\nMain training loop.", "source": "core\\rl\\world_model.py", "category": "general"}
{"instruction": "Explain the Reset State function", "input": "", "output": "Function: reset_state\n\nReset internal RSSM state (call at episode start).", "source": "core\\rl\\world_model.py", "category": "regime"}
{"instruction": "Explain the Train function", "input": "", "output": "Function: train\n\nTrain SafeDreamer with safety constraints.", "source": "core\\rl\\world_model.py", "category": "general"}
{"instruction": "Explain the purpose of Tick-Level Backtesting Engine for HFT", "input": "", "output": "Tick-Level Backtesting Engine for HFT\n======================================\nProvides realistic tick-by-tick simulation with:\n- Order book state tracking\n- Queue position modeling\n- Latency simulation\n- Realistic slippage\n\nInspired by HftBacktest (https://github.com/nkaz001/hftbacktest)", "source": "core\\execution\\backtest.py", "category": "execution"}
{"instruction": "What is the OrderStatus class and how do I use it?", "input": "", "output": "The OrderStatus class:\n\nOrder status in backtest.", "source": "core\\execution\\backtest.py", "category": "general"}
{"instruction": "What is the OrderSide class and how do I use it?", "input": "", "output": "The OrderSide class:\n\nOrder side.", "source": "core\\execution\\backtest.py", "category": "general"}
{"instruction": "What is the OrderType class and how do I use it?", "input": "", "output": "The OrderType class:\n\nOrder type.", "source": "core\\execution\\backtest.py", "category": "general"}
{"instruction": "What is the BacktestOrder class and how do I use it?", "input": "", "output": "The BacktestOrder class:\n\nOrder in backtesting engine.", "source": "core\\execution\\backtest.py", "category": "general"}
{"instruction": "What is the BacktestFill class and how do I use it?", "input": "", "output": "The BacktestFill class:\n\nFill event in backtest.", "source": "core\\execution\\backtest.py", "category": "general"}
{"instruction": "What is the BacktestTrade class and how do I use it?", "input": "", "output": "The BacktestTrade class:\n\nTrade (position change) in backtest.", "source": "core\\execution\\backtest.py", "category": "general"}
{"instruction": "What is the TickData class and how do I use it?", "input": "", "output": "The TickData class:\n\nSingle tick of market data.", "source": "core\\execution\\backtest.py", "category": "microstructure"}
{"instruction": "What is the BacktestConfig class and how do I use it?", "input": "", "output": "The BacktestConfig class:\n\nBacktesting configuration.", "source": "core\\execution\\backtest.py", "category": "general"}
{"instruction": "What is the Strategy class and how do I use it?", "input": "", "output": "The Strategy class:\n\nAbstract base class for trading strategies.", "source": "core\\execution\\backtest.py", "category": "general"}
{"instruction": "What is the TickBacktestEngine class and how do I use it?", "input": "", "output": "The TickBacktestEngine class:\n\nTick-Level Backtesting Engine.\n\nFeatures:\n- Tick-by-tick simulation\n- Order book reconstruction\n- Queue position tracking\n- Realistic fill simulation\n- Latency modeling\n- PnL tracking\n\nUsage:\n    engine = TickBacktestEngine(config)\n    engine.load_data(\"EURUSD\", tick_data)\n    engine.run(strategy)\n    results = engine.get_results()", "source": "core\\execution\\backtest.py", "category": "microstructure"}
{"instruction": "Show me a code example for TickBacktestEngine", "input": "", "output": "engine = TickBacktestEngine(config)\n    engine.load_data(\"EURUSD\", tick_data)\n    engine.run(strategy)\n    results = engine.get_results()", "source": "core\\execution\\backtest.py", "category": "microstructure"}
{"instruction": "What is the SimpleMovingAverageStrategy class and how do I use it?", "input": "", "output": "The SimpleMovingAverageStrategy class:\n\nSimple MA crossover strategy for testing.", "source": "core\\execution\\backtest.py", "category": "general"}
{"instruction": "Explain the On Tick function", "input": "", "output": "Function: on_tick\n\nCalled on each tick.", "source": "core\\execution\\backtest.py", "category": "microstructure"}
{"instruction": "Explain the On Fill function", "input": "", "output": "Function: on_fill\n\nCalled when order is filled.", "source": "core\\execution\\backtest.py", "category": "general"}
{"instruction": "Explain the On Start function", "input": "", "output": "Function: on_start\n\nCalled at backtest start.", "source": "core\\execution\\backtest.py", "category": "general"}
{"instruction": "Explain the On End function", "input": "", "output": "Function: on_end\n\nCalled at backtest end.", "source": "core\\execution\\backtest.py", "category": "general"}
{"instruction": "What is the formula for Load Data?", "input": "", "output": "Load tick data for symbol.\n\nExpects DataFrame with columns:\n- timestamp: datetime\n- bid: float\n- ask: float\n- bid_size: float (optional)\n- ask_size: float (optional)\n- last_price: float (optional, for trades)\n- last_size: float (optional, for trades)", "source": "core\\execution\\backtest.py", "category": "microstructure"}
{"instruction": "Explain the Load Data function", "input": "", "output": "Function: load_data\n\nLoad tick data for symbol.\n\nExpects DataFrame with columns:\n- timestamp: datetime\n- bid: float\n- ask: float\n- bid_size: float (optional)\n- ask_size: float (optional)\n- last_price: float (optional, for trades)\n- last_size: float (optional, for trades)", "source": "core\\execution\\backtest.py", "category": "microstructure"}
{"instruction": "Explain the Run function", "input": "", "output": "Function: run\n\nRun backtest with strategy.\n\nArgs:\n    strategy: Trading strategy to test", "source": "core\\execution\\backtest.py", "category": "general"}
{"instruction": "Explain the Submit Order function", "input": "", "output": "Function: submit_order\n\nSubmit order to backtest engine.\n\nArgs:\n    symbol: Trading symbol\n    side: BUY or SELL\n    quantity: Order quantity (in lots)\n    order_type: MARKET or LIMIT\n    limit_price: Limit price (required for LIMIT orders)\n\nReturns:\n    Order ID", "source": "core\\execution\\backtest.py", "category": "general"}
{"instruction": "Explain the Cancel Order function", "input": "", "output": "Function: cancel_order\n\nCancel pending order.", "source": "core\\execution\\backtest.py", "category": "general"}
{"instruction": "Explain the Get Position function", "input": "", "output": "Function: get_position\n\nGet current position for symbol.", "source": "core\\execution\\backtest.py", "category": "general"}
{"instruction": "Explain the Get Mid Price function", "input": "", "output": "Function: get_mid_price\n\nGet current mid price.", "source": "core\\execution\\backtest.py", "category": "general"}
{"instruction": "Explain the Get Spread function", "input": "", "output": "Function: get_spread\n\nGet current spread.", "source": "core\\execution\\backtest.py", "category": "microstructure"}
{"instruction": "Explain the Get Book Imbalance function", "input": "", "output": "Function: get_book_imbalance\n\nGet order book imbalance.", "source": "core\\execution\\backtest.py", "category": "general"}
{"instruction": "Explain the Get Results function", "input": "", "output": "Function: get_results\n\nGet backtest results summary.", "source": "core\\execution\\backtest.py", "category": "general"}
{"instruction": "Explain the Get Trade Log function", "input": "", "output": "Function: get_trade_log\n\nGet trade log as DataFrame.", "source": "core\\execution\\backtest.py", "category": "general"}
{"instruction": "What is the source paper for Slippage Estimation?", "input": "", "output": "The source is: Aït-Sahalia (2017). ", "source": "core\\execution\\fill_probability.py", "category": "execution"}
{"instruction": "Explain the purpose of Fill Probability and Market Impact Models", "input": "", "output": "Fill Probability and Market Impact Models\n==========================================\nAdvanced models for estimating order fill probability and execution quality.\n\nModels included:\n1. Queue-Based Fill Probability\n2. Poisson Arrival Model\n3. Market Impact Model (Almgren-Chriss style)\n4. Slippage Estimation\n\nSource: Aït-Sahalia (2017) \"High Frequency Market Making\"", "source": "core\\execution\\fill_probability.py", "category": "execution"}
{"instruction": "What is the FillEstimate class and how do I use it?", "input": "", "output": "The FillEstimate class:\n\nFill probability and execution estimate.", "source": "core\\execution\\fill_probability.py", "category": "execution"}
{"instruction": "What is the ExecutionResult class and how do I use it?", "input": "", "output": "The ExecutionResult class:\n\nActual execution result for calibration.", "source": "core\\execution\\fill_probability.py", "category": "execution"}
{"instruction": "What is the PoissonFillModel class and how do I use it?", "input": "", "output": "The PoissonFillModel class:\n\nPoisson Arrival Model for Fill Probability.\n\nModels trade arrivals as Poisson process, estimates probability\nof filling based on queue position and arrival rate.\n\nP(fill within T) = P(arrivals >= queue_position within T)", "source": "core\\execution\\fill_probability.py", "category": "general"}
{"instruction": "What is the MarketImpactModel class and how do I use it?", "input": "", "output": "The MarketImpactModel class:\n\nMarket Impact Model.\n\nEstimates temporary and permanent price impact of orders.\n\nTemporary impact: Price moves during execution, reverts after\nPermanent impact: Information content, price doesn't fully revert\n\nBased on: Almgren-Chriss optimal execution model", "source": "core\\execution\\fill_probability.py", "category": "execution"}
{"instruction": "What is the SlippageEstimator class and how do I use it?", "input": "", "output": "The SlippageEstimator class:\n\nSlippage Estimation Model.\n\nEstimates expected slippage based on:\n- Order size vs available liquidity\n- Spread\n- Market impact\n- Adverse selection", "source": "core\\execution\\fill_probability.py", "category": "execution"}
{"instruction": "What is the FillProbabilityEngine class and how do I use it?", "input": "", "output": "The FillProbabilityEngine class:\n\nUnified Fill Probability Engine.\n\nCombines all models to provide comprehensive fill estimates.", "source": "core\\execution\\fill_probability.py", "category": "general"}
{"instruction": "What is the MakerTakerDecision class and how do I use it?", "input": "", "output": "The MakerTakerDecision class:\n\nMaker vs Taker Decision Model.\n\nDecides optimal order type based on:\n- Urgency\n- Spread\n- Fill probability\n- Fees (maker rebate vs taker fee)", "source": "core\\execution\\fill_probability.py", "category": "microstructure"}
{"instruction": "Explain the Record Trade function", "input": "", "output": "Function: record_trade\n\nRecord a trade for rate estimation.", "source": "core\\execution\\fill_probability.py", "category": "general"}
{"instruction": "Explain the Fill Probability function", "input": "", "output": "Function: fill_probability\n\nCalculate probability of fill within time horizon.\n\nArgs:\n    queue_position: Quantity ahead in queue\n    time_horizon: Time window in seconds\n\nReturns:\n    Probability of fill [0, 1]", "source": "core\\execution\\fill_probability.py", "category": "general"}
{"instruction": "Explain the Expected Time To Fill function", "input": "", "output": "Function: expected_time_to_fill\n\nEstimate expected time to fill.\n\nArgs:\n    queue_position: Quantity ahead in queue\n\nReturns:\n    Expected time in seconds", "source": "core\\execution\\fill_probability.py", "category": "general"}
{"instruction": "Explain the Temporary Impact function", "input": "", "output": "Function: temporary_impact\n\nCalculate temporary market impact in basis points.\n\nArgs:\n    order_size: Order size\n    execution_time: Execution time in seconds\n\nReturns:\n    Temporary impact in basis points", "source": "core\\execution\\fill_probability.py", "category": "execution"}
{"instruction": "Explain the Permanent Impact function", "input": "", "output": "Function: permanent_impact\n\nCalculate permanent market impact in basis points.\n\nArgs:\n    order_size: Order size\n\nReturns:\n    Permanent impact in basis points", "source": "core\\execution\\fill_probability.py", "category": "execution"}
{"instruction": "Explain the Total Impact function", "input": "", "output": "Function: total_impact\n\nCalculate total market impact.\n\nArgs:\n    order_size: Order size\n    execution_time: Expected execution time in seconds\n\nReturns:\n    Total impact in basis points", "source": "core\\execution\\fill_probability.py", "category": "execution"}
{"instruction": "What is the formula for Optimal Execution Time?", "input": "", "output": "Calculate optimal execution time.\n\nArgs:\n    order_size: Order size\n    urgency: Urgency parameter (0 = patient, 1 = aggressive)\n\nReturns:\n    Optimal execution time in seconds", "source": "core\\execution\\fill_probability.py", "category": "execution"}
{"instruction": "Explain the Optimal Execution Time function", "input": "", "output": "Function: optimal_execution_time\n\nCalculate optimal execution time.\n\nArgs:\n    order_size: Order size\n    urgency: Urgency parameter (0 = patient, 1 = aggressive)\n\nReturns:\n    Optimal execution time in seconds", "source": "core\\execution\\fill_probability.py", "category": "execution"}
{"instruction": "Explain the Record Execution function", "input": "", "output": "Function: record_execution\n\nRecord execution for calibration.", "source": "core\\execution\\fill_probability.py", "category": "execution"}
{"instruction": "Explain the Estimate Slippage function", "input": "", "output": "Function: estimate_slippage\n\nEstimate expected slippage.\n\nArgs:\n    order_size: Order quantity\n    spread_bps: Current spread in basis points\n    book_depth: Available liquidity at best level\n    side: Order side\n\nReturns:\n    Expected slippage in basis points", "source": "core\\execution\\fill_probability.py", "category": "microstructure"}
{"instruction": "Explain the Estimate Execution Cost function", "input": "", "output": "Function: estimate_execution_cost\n\nEstimate total execution cost breakdown.\n\nReturns:\n    Dict with cost components in basis points", "source": "core\\execution\\fill_probability.py", "category": "execution"}
{"instruction": "Explain the Estimate Fill function", "input": "", "output": "Function: estimate_fill\n\nGenerate comprehensive fill estimate.\n\nArgs:\n    side: Order side\n    limit_price: Limit order price\n    quantity: Order quantity\n    queue_position: Current queue position\n    mid_price: Current mid price\n    spread_bps: Current spread in bps\n    book_depth: Depth at limit price level\n    time_horizon: Time window in seconds\n\nReturns:\n    FillEstimate with all components", "source": "core\\execution\\fill_probability.py", "category": "microstructure"}
{"instruction": "What is the formula for Should Use Market Order?", "input": "", "output": "Decide whether to use market order instead of limit.\n\nArgs:\n    limit_fill_estimate: Fill estimate for limit order\n    urgency: How urgent is the fill (0-1)\n\nReturns:\n    (use_market, reason)", "source": "core\\execution\\fill_probability.py", "category": "general"}
{"instruction": "Explain the Should Use Market Order function", "input": "", "output": "Function: should_use_market_order\n\nDecide whether to use market order instead of limit.\n\nArgs:\n    limit_fill_estimate: Fill estimate for limit order\n    urgency: How urgent is the fill (0-1)\n\nReturns:\n    (use_market, reason)", "source": "core\\execution\\fill_probability.py", "category": "general"}
{"instruction": "Explain the Record Trade function", "input": "", "output": "Function: record_trade\n\nRecord trade for model calibration.", "source": "core\\execution\\fill_probability.py", "category": "general"}
{"instruction": "Explain the Record Execution function", "input": "", "output": "Function: record_execution\n\nRecord execution for model calibration.", "source": "core\\execution\\fill_probability.py", "category": "execution"}
{"instruction": "Explain the Optimal Aggressiveness function", "input": "", "output": "Function: optimal_aggressiveness\n\nCalculate optimal order aggressiveness.\n\nReturns:\n    Dict with recommendation and analysis", "source": "core\\execution\\fill_probability.py", "category": "general"}
{"instruction": "What is the source paper for Network jitter?", "input": "", "output": "The source is: NautilusTrader latency documentation. ", "source": "core\\execution\\latency.py", "category": "execution"}
{"instruction": "Explain the purpose of Latency Simulation for HFT Backtesting", "input": "", "output": "Latency Simulation for HFT Backtesting\n=======================================\nModels realistic latency in order execution.\n\nComponents:\n- Feed latency (market data delay)\n- Order latency (submission to exchange)\n- Fill latency (order acceptance to fill)\n- Network jitter\n\nSource: NautilusTrader latency documentation", "source": "core\\execution\\latency.py", "category": "execution"}
{"instruction": "What is the LatencyType class and how do I use it?", "input": "", "output": "The LatencyType class:\n\nTypes of latency.", "source": "core\\execution\\latency.py", "category": "general"}
{"instruction": "What is the LatencyConfig class and how do I use it?", "input": "", "output": "The LatencyConfig class:\n\nLatency configuration for a venue.", "source": "core\\execution\\latency.py", "category": "general"}
{"instruction": "What is the LatencySimulator class and how do I use it?", "input": "", "output": "The LatencySimulator class:\n\nLatency Simulation Engine.\n\nSimulates realistic network and execution latencies.\n\nUsage:\n    sim = LatencySimulator(venue='retail_forex')\n    delayed_time = sim.apply_feed_latency(tick_time)\n    order_accepted_time = sim.apply_order_latency(submit_time)", "source": "core\\execution\\latency.py", "category": "execution"}
{"instruction": "Show me a code example for LatencySimulator", "input": "", "output": "sim = LatencySimulator(venue='retail_forex')\n    delayed_time = sim.apply_feed_latency(tick_time)\n    order_accepted_time = sim.apply_order_latency(submit_time)", "source": "core\\execution\\latency.py", "category": "execution"}
{"instruction": "What is the LatencyAwareBacktest class and how do I use it?", "input": "", "output": "The LatencyAwareBacktest class:\n\nLatency-aware backtest wrapper.\n\nApplies latency to all market data and orders.", "source": "core\\execution\\latency.py", "category": "general"}
{"instruction": "What is the LatencyImpactAnalyzer class and how do I use it?", "input": "", "output": "The LatencyImpactAnalyzer class:\n\nAnalyze impact of latency on trading performance.", "source": "core\\execution\\latency.py", "category": "execution"}
{"instruction": "Explain the Apply Feed Latency function", "input": "", "output": "Function: apply_feed_latency\n\nApply feed latency to market data timestamp.\n\nArgs:\n    timestamp: Original tick timestamp\n\nReturns:\n    Delayed timestamp (when we receive the tick)", "source": "core\\execution\\latency.py", "category": "microstructure"}
{"instruction": "Explain the Apply Order Latency function", "input": "", "output": "Function: apply_order_latency\n\nApply order submission latency.\n\nArgs:\n    submit_time: Time order was submitted\n\nReturns:\n    Time order is received by exchange", "source": "core\\execution\\latency.py", "category": "general"}
{"instruction": "Explain the Apply Fill Latency function", "input": "", "output": "Function: apply_fill_latency\n\nApply fill confirmation latency.\n\nArgs:\n    match_time: Time order was matched\n\nReturns:\n    Time we receive fill confirmation", "source": "core\\execution\\latency.py", "category": "general"}
{"instruction": "Explain the Apply Cancel Latency function", "input": "", "output": "Function: apply_cancel_latency\n\nApply cancel request latency.\n\nArgs:\n    cancel_time: Time cancel was requested\n\nReturns:\n    Time cancel is processed", "source": "core\\execution\\latency.py", "category": "general"}
{"instruction": "What is the formula for Get Total Roundtrip?", "input": "", "output": "Get total expected roundtrip latency (ms).\n\nOrder submit -> fill confirmation received", "source": "core\\execution\\latency.py", "category": "general"}
{"instruction": "Explain the Get Total Roundtrip function", "input": "", "output": "Function: get_total_roundtrip\n\nGet total expected roundtrip latency (ms).\n\nOrder submit -> fill confirmation received", "source": "core\\execution\\latency.py", "category": "general"}
{"instruction": "Explain the Get Statistics function", "input": "", "output": "Function: get_statistics\n\nGet latency statistics.\n\nReturns:\n    Dict with statistics per latency type", "source": "core\\execution\\latency.py", "category": "general"}
{"instruction": "Explain the Reset Statistics function", "input": "", "output": "Function: reset_statistics\n\nReset latency statistics.", "source": "core\\execution\\latency.py", "category": "general"}
{"instruction": "Explain the Delay Tick function", "input": "", "output": "Function: delay_tick\n\nDelay tick data by feed latency.\n\nArgs:\n    tick_time: Original tick timestamp\n    tick_data: Tick data dict\n\nReturns:\n    (delayed_time, tick_data)", "source": "core\\execution\\latency.py", "category": "microstructure"}
{"instruction": "Explain the Delay Order function", "input": "", "output": "Function: delay_order\n\nDelay order submission.\n\nArgs:\n    submit_time: Order submission time\n    order: Order data dict\n\nReturns:\n    (exchange_received_time, order)", "source": "core\\execution\\latency.py", "category": "general"}
{"instruction": "Explain the Process Events function", "input": "", "output": "Function: process_events\n\nProcess events that have arrived by current time.\n\nArgs:\n    current_time: Current simulation time\n\nReturns:\n    List of (event_type, event_data) that have arrived", "source": "core\\execution\\latency.py", "category": "general"}
{"instruction": "Explain the Add Pending Event function", "input": "", "output": "Function: add_pending_event\n\nAdd event to pending queue.", "source": "core\\execution\\latency.py", "category": "general"}
{"instruction": "Explain the Record Trade With Latency function", "input": "", "output": "Function: record_trade_with_latency\n\nRecord trade with latency impact.", "source": "core\\execution\\latency.py", "category": "execution"}
{"instruction": "Explain the Record Trade Without Latency function", "input": "", "output": "Function: record_trade_without_latency\n\nRecord trade without latency (ideal case).", "source": "core\\execution\\latency.py", "category": "general"}
{"instruction": "Explain the Get Latency Impact function", "input": "", "output": "Function: get_latency_impact\n\nCalculate latency impact on trading.\n\nReturns:\n    Dict with impact metrics", "source": "core\\execution\\latency.py", "category": "execution"}
{"instruction": "What is the source paper for OEI research?", "input": "", "output": "The source is: https://hftbacktest.readthedocs.io/en/latest/tutorials/Probability%20Queue%20Models.html. ", "source": "core\\execution\\order_book.py", "category": "alpha"}
{"instruction": "Explain the purpose of Order Book Level 2/Level 3 Processing for HFT", "input": "", "output": "Order Book Level 2/Level 3 Processing for HFT\n==============================================\nImplements order book reconstruction, imbalance signals, and queue position estimation.\n\nBased on:\n- NautilusTrader order book architecture\n- HftBacktest Level-3 FIFO model\n- Chinese quant OFI/OEI research\n\nSource: https://hftbacktest.readthedocs.io/en/latest/tutorials/Probability%20Queue%20Models.html", "source": "core\\execution\\order_book.py", "category": "alpha"}
{"instruction": "What is the Side class and how do I use it?", "input": "", "output": "The Side class:\n\nOrder side.", "source": "core\\execution\\order_book.py", "category": "general"}
{"instruction": "What is the OrderType class and how do I use it?", "input": "", "output": "The OrderType class:\n\nOrder book update types.", "source": "core\\execution\\order_book.py", "category": "general"}
{"instruction": "What is the Order class and how do I use it?", "input": "", "output": "The Order class:\n\nSingle order in the book.", "source": "core\\execution\\order_book.py", "category": "general"}
{"instruction": "What is the PriceLevel class and how do I use it?", "input": "", "output": "The PriceLevel class:\n\nOrders at a single price level.", "source": "core\\execution\\order_book.py", "category": "general"}
{"instruction": "What is the BookUpdate class and how do I use it?", "input": "", "output": "The BookUpdate class:\n\nOrder book update event.", "source": "core\\execution\\order_book.py", "category": "general"}
{"instruction": "What is the OrderBookL3 class and how do I use it?", "input": "", "output": "The OrderBookL3 class:\n\nLevel 3 Order Book with queue position tracking.\n\nFeatures:\n- Full order-by-order book reconstruction\n- Queue position estimation\n- Order book imbalance signals\n- Depth ratio signals\n- Fill probability estimation\n\nUsage:\n    book = OrderBookL3(tick_size=0.0001)\n    book.process_update(update)\n    imbalance = book.get_imbalance()\n    queue_pos = book.estimate_queue_position(1.1000, Side.BUY)", "source": "core\\execution\\order_book.py", "category": "alpha"}
{"instruction": "Show me a code example for OrderBookL3", "input": "", "output": "book = OrderBookL3(tick_size=0.0001)\n    book.process_update(update)\n    imbalance = book.get_imbalance()\n    queue_pos = book.estimate_queue_position(1.1000, Side.BUY)", "source": "core\\execution\\order_book.py", "category": "alpha"}
{"instruction": "What is the OrderBookSignals class and how do I use it?", "input": "", "output": "The OrderBookSignals class:\n\nGenerate trading signals from order book data.\n\nSignals include:\n- Order book imbalance (OBI)\n- Depth ratio\n- Microprice momentum\n- Spread regime\n- Trade flow imbalance", "source": "core\\execution\\order_book.py", "category": "alpha"}
{"instruction": "Explain the Add Order function", "input": "", "output": "Function: add_order\n\nAdd order, return queue position.", "source": "core\\execution\\order_book.py", "category": "general"}
{"instruction": "Explain the Remove Order function", "input": "", "output": "Function: remove_order\n\nRemove order by ID.", "source": "core\\execution\\order_book.py", "category": "general"}
{"instruction": "What is the formula for Get Queue Position?", "input": "", "output": "Get queue position (0 = front).", "source": "core\\execution\\order_book.py", "category": "general"}
{"instruction": "Explain the Get Queue Position function", "input": "", "output": "Function: get_queue_position\n\nGet queue position (0 = front).", "source": "core\\execution\\order_book.py", "category": "general"}
{"instruction": "Explain the Process Update function", "input": "", "output": "Function: process_update\n\nProcess a single order book update.", "source": "core\\execution\\order_book.py", "category": "general"}
{"instruction": "Explain the Get Best Bid function", "input": "", "output": "Function: get_best_bid\n\nGet best (highest) bid price.", "source": "core\\execution\\order_book.py", "category": "microstructure"}
{"instruction": "Explain the Get Best Ask function", "input": "", "output": "Function: get_best_ask\n\nGet best (lowest) ask price.", "source": "core\\execution\\order_book.py", "category": "microstructure"}
{"instruction": "Explain the Get Mid Price function", "input": "", "output": "Function: get_mid_price\n\nGet mid price.", "source": "core\\execution\\order_book.py", "category": "general"}
{"instruction": "What is the formula for Get Spread?", "input": "", "output": "Get bid-ask spread.", "source": "core\\execution\\order_book.py", "category": "microstructure"}
{"instruction": "Explain the Get Spread function", "input": "", "output": "Function: get_spread\n\nGet bid-ask spread.", "source": "core\\execution\\order_book.py", "category": "microstructure"}
{"instruction": "Explain the Get Spread Bps function", "input": "", "output": "Function: get_spread_bps\n\nGet spread in basis points.", "source": "core\\execution\\order_book.py", "category": "microstructure"}
{"instruction": "What is the formula for Get Imbalance?", "input": "", "output": "Calculate order book imbalance.\n\nReturns:\n    Imbalance ratio: (bid_qty - ask_qty) / (bid_qty + ask_qty)\n    Range: -1 (all asks) to +1 (all bids)\n    Positive = buying pressure, Negative = selling pressure", "source": "core\\execution\\order_book.py", "category": "microstructure"}
{"instruction": "Explain the Get Imbalance function", "input": "", "output": "Function: get_imbalance\n\nCalculate order book imbalance.\n\nReturns:\n    Imbalance ratio: (bid_qty - ask_qty) / (bid_qty + ask_qty)\n    Range: -1 (all asks) to +1 (all bids)\n    Positive = buying pressure, Negative = selling pressure", "source": "core\\execution\\order_book.py", "category": "microstructure"}
{"instruction": "What is the formula for Get Depth Ratio?", "input": "", "output": "Calculate depth ratio.\n\nReturns:\n    Ratio: bid_depth / ask_depth\n    >1 = more buy interest, <1 = more sell interest", "source": "core\\execution\\order_book.py", "category": "microstructure"}
{"instruction": "Explain the Get Depth Ratio function", "input": "", "output": "Function: get_depth_ratio\n\nCalculate depth ratio.\n\nReturns:\n    Ratio: bid_depth / ask_depth\n    >1 = more buy interest, <1 = more sell interest", "source": "core\\execution\\order_book.py", "category": "microstructure"}
{"instruction": "What is the formula for Get Weighted Mid Price?", "input": "", "output": "Calculate volume-weighted mid price.\n\nMore accurate than simple mid when book is imbalanced.", "source": "core\\execution\\order_book.py", "category": "volatility"}
{"instruction": "Explain the Get Weighted Mid Price function", "input": "", "output": "Function: get_weighted_mid_price\n\nCalculate volume-weighted mid price.\n\nMore accurate than simple mid when book is imbalanced.", "source": "core\\execution\\order_book.py", "category": "volatility"}
{"instruction": "What is the formula for Get Microprice?", "input": "", "output": "Calculate microprice (imbalance-adjusted mid).\n\nBetter predictor of next trade direction than mid price.\nSource: Gatheral & Oomen (2010)", "source": "core\\execution\\order_book.py", "category": "general"}
{"instruction": "Explain the Get Microprice function", "input": "", "output": "Function: get_microprice\n\nCalculate microprice (imbalance-adjusted mid).\n\nBetter predictor of next trade direction than mid price.\nSource: Gatheral & Oomen (2010)", "source": "core\\execution\\order_book.py", "category": "general"}
{"instruction": "What is the formula for Estimate Queue Position?", "input": "", "output": "Estimate queue position if order placed at price.\n\nArgs:\n    price: Limit order price\n    side: BUY or SELL\n\nReturns:\n    Estimated queue position (0 = front of queue)", "source": "core\\execution\\order_book.py", "category": "general"}
{"instruction": "Explain the Estimate Queue Position function", "input": "", "output": "Function: estimate_queue_position\n\nEstimate queue position if order placed at price.\n\nArgs:\n    price: Limit order price\n    side: BUY or SELL\n\nReturns:\n    Estimated queue position (0 = front of queue)", "source": "core\\execution\\order_book.py", "category": "general"}
{"instruction": "Explain the Estimate Queue Ahead function", "input": "", "output": "Function: estimate_queue_ahead\n\nEstimate total quantity ahead in queue.\n\nReturns:\n    Total quantity that must trade before our order fills", "source": "core\\execution\\order_book.py", "category": "general"}
{"instruction": "Explain the Get Own Queue Position function", "input": "", "output": "Function: get_own_queue_position\n\nGet queue position of our own order.", "source": "core\\execution\\order_book.py", "category": "general"}
{"instruction": "Explain the Get Snapshot function", "input": "", "output": "Function: get_snapshot\n\nGet order book snapshot.\n\nReturns:\n    Dict with bids, asks, and summary statistics", "source": "core\\execution\\order_book.py", "category": "microstructure"}
{"instruction": "Explain the To Dataframe function", "input": "", "output": "Function: to_dataframe\n\nConvert order book to DataFrame.", "source": "core\\execution\\order_book.py", "category": "general"}
{"instruction": "What is the formula for From Ticks?", "input": "", "output": "Reconstruct order book from tick data.\n\nExpects DataFrame with columns:\n- timestamp: datetime\n- type: 'trade' or 'quote'\n- side: 'buy' or 'sell' (for trades)\n- price: float\n- bid: float (for quotes)\n- ask: float (for quotes)\n- bid_size: float (for quotes)\n- ask_size: float (for quotes)\n- size: float (for trades)", "source": "core\\execution\\order_book.py", "category": "microstructure"}
{"instruction": "Explain the From Ticks function", "input": "", "output": "Function: from_ticks\n\nReconstruct order book from tick data.\n\nExpects DataFrame with columns:\n- timestamp: datetime\n- type: 'trade' or 'quote'\n- side: 'buy' or 'sell' (for trades)\n- price: float\n- bid: float (for quotes)\n- ask: float (for quotes)\n- bid_size: float (for quotes)\n- ask_size: float (for quotes)\n- size: float (for trades)", "source": "core\\execution\\order_book.py", "category": "microstructure"}
{"instruction": "Explain the Update function", "input": "", "output": "Function: update\n\nUpdate with new book state and generate signals.\n\nReturns:\n    Dict of signal values", "source": "core\\execution\\order_book.py", "category": "alpha"}
{"instruction": "Explain the Generate Signals function", "input": "", "output": "Function: generate_signals\n\nGenerate all order book signals.", "source": "core\\execution\\order_book.py", "category": "alpha"}
{"instruction": "What is the source paper for time priority?", "input": "", "output": "The source is: https://hftbacktest.readthedocs.io/en/latest/tutorials/Probability%20Queue%20Models.html. ", "source": "core\\execution\\queue_position.py", "category": "risk"}
{"instruction": "Explain the purpose of Queue Position Tracking and Fill Probability Models", "input": "", "output": "Queue Position Tracking and Fill Probability Models\n=====================================================\nImplements HftBacktest-style queue position estimation.\n\nThree models implemented:\n1. Risk-Averse Model - Conservative, order advances only on trades\n2. Probabilistic Model - Statistical queue position estimation\n3. Level-3 FIFO Model - Exact simulation with price-time priority\n\nSource: https://hftbacktest.readthedocs.io/en/latest/tutorials/Probability%20Queue%20Models.html", "source": "core\\execution\\queue_position.py", "category": "risk"}
{"instruction": "What is the QueueOrder class and how do I use it?", "input": "", "output": "The QueueOrder class:\n\nOrder in queue with position tracking.", "source": "core\\execution\\queue_position.py", "category": "general"}
{"instruction": "What is the QueueAdvancement class and how do I use it?", "input": "", "output": "The QueueAdvancement class:\n\nResult of queue advancement calculation.", "source": "core\\execution\\queue_position.py", "category": "general"}
{"instruction": "What is the QueueModel class and how do I use it?", "input": "", "output": "The QueueModel class:\n\nAbstract base class for queue models.", "source": "core\\execution\\queue_position.py", "category": "general"}
{"instruction": "What is the RiskAverseQueueModel class and how do I use it?", "input": "", "output": "The RiskAverseQueueModel class:\n\nRisk-Averse Queue Model.\n\nConservative model where queue only advances when trades occur\nat the order's price level. No credit for cancellations.\n\nBest for: Conservative fill probability estimation", "source": "core\\execution\\queue_position.py", "category": "risk"}
{"instruction": "What is the ProbabilisticQueueModel class and how do I use it?", "input": "", "output": "The ProbabilisticQueueModel class:\n\nProbabilistic Queue Model.\n\nUses statistical model to estimate queue position based on:\n- Historical fill rates at price level\n- Order arrival/cancellation rates\n- Trade frequency\n\nBest for: Realistic average-case estimation", "source": "core\\execution\\queue_position.py", "category": "general"}
{"instruction": "What is the L3FIFOQueueModel class and how do I use it?", "input": "", "output": "The L3FIFOQueueModel class:\n\nLevel-3 FIFO Queue Model.\n\nExact simulation using full order book with price-time priority.\nTracks every order ahead in queue.\n\nBest for: High-precision HFT simulation", "source": "core\\execution\\queue_position.py", "category": "general"}
{"instruction": "What is the QueuePositionTracker class and how do I use it?", "input": "", "output": "The QueuePositionTracker class:\n\nHigh-level queue position tracker.\n\nManages multiple orders and models, provides unified interface.\n\nUsage:\n    tracker = QueuePositionTracker(model='probabilistic')\n    tracker.add_order(order)\n    tracker.on_trade(trade)\n    fill_prob = tracker.get_fill_probability(order_id)", "source": "core\\execution\\queue_position.py", "category": "general"}
{"instruction": "Show me a code example for QueuePositionTracker", "input": "", "output": "tracker = QueuePositionTracker(model='probabilistic')\n    tracker.add_order(order)\n    tracker.on_trade(trade)\n    fill_prob = tracker.get_fill_probability(order_id)", "source": "core\\execution\\queue_position.py", "category": "general"}
{"instruction": "What is the AdverseSelectionModel class and how do I use it?", "input": "", "output": "The AdverseSelectionModel class:\n\nAdverse Selection Risk Model.\n\nEstimates the probability that a fill will be followed by\nan adverse price move (informed trading).\n\nBased on: Kyle (1985), Glosten-Milgrom (1985)", "source": "core\\execution\\queue_position.py", "category": "risk"}
{"instruction": "Explain the Estimate Position function", "input": "", "output": "Function: estimate_position\n\nEstimate current queue position.", "source": "core\\execution\\queue_position.py", "category": "general"}
{"instruction": "Explain the Advance Queue function", "input": "", "output": "Function: advance_queue\n\nAdvance queue position based on trade.", "source": "core\\execution\\queue_position.py", "category": "general"}
{"instruction": "Explain the Fill Probability function", "input": "", "output": "Function: fill_probability\n\nEstimate probability of fill.", "source": "core\\execution\\queue_position.py", "category": "general"}
{"instruction": "What is the formula for Estimate Position?", "input": "", "output": "Estimate queue position.\n\nPosition = initial_position - trades_at_level", "source": "core\\execution\\queue_position.py", "category": "general"}
{"instruction": "Explain the Estimate Position function", "input": "", "output": "Function: estimate_position\n\nEstimate queue position.\n\nPosition = initial_position - trades_at_level", "source": "core\\execution\\queue_position.py", "category": "general"}
{"instruction": "Explain the Advance Queue function", "input": "", "output": "Function: advance_queue\n\nAdvance queue only if trade at same price level.\n\nArgs:\n    order: Order to advance\n    trade_volume: Volume of trade\n    trade_price: Price of trade\n\nReturns:\n    QueueAdvancement with new position", "source": "core\\execution\\queue_position.py", "category": "volatility"}
{"instruction": "Explain the Fill Probability function", "input": "", "output": "Function: fill_probability\n\nEstimate fill probability based on queue position.", "source": "core\\execution\\queue_position.py", "category": "general"}
{"instruction": "Explain the Estimate Position function", "input": "", "output": "Function: estimate_position\n\nProbabilistic position estimate.\n\nAccounts for expected cancellations ahead.", "source": "core\\execution\\queue_position.py", "category": "general"}
{"instruction": "Explain the Advance Queue function", "input": "", "output": "Function: advance_queue\n\nAdvance with probabilistic cancellation credit.", "source": "core\\execution\\queue_position.py", "category": "general"}
{"instruction": "Explain the Fill Probability function", "input": "", "output": "Function: fill_probability\n\nCalculate fill probability using Poisson model.", "source": "core\\execution\\queue_position.py", "category": "general"}
{"instruction": "Explain the Calibrate function", "input": "", "output": "Function: calibrate\n\nCalibrate model from historical trades.\n\nExpects DataFrame with: timestamp, price, volume", "source": "core\\execution\\queue_position.py", "category": "volatility"}
{"instruction": "Explain the Update Book function", "input": "", "output": "Function: update_book\n\nUpdate internal queue state from L3 feed.\n\nArgs:\n    price: Price level\n    order_id: Order identifier\n    quantity: Order quantity\n    action: 'add', 'modify', 'delete', 'fill'", "source": "core\\execution\\queue_position.py", "category": "regime"}
{"instruction": "Explain the Estimate Position function", "input": "", "output": "Function: estimate_position\n\nGet exact queue position from L3 state.", "source": "core\\execution\\queue_position.py", "category": "regime"}
{"instruction": "Explain the Advance Queue function", "input": "", "output": "Function: advance_queue\n\nAdvance queue using FIFO matching.", "source": "core\\execution\\queue_position.py", "category": "general"}
{"instruction": "Explain the Fill Probability function", "input": "", "output": "Function: fill_probability\n\nBinary fill probability based on position.", "source": "core\\execution\\queue_position.py", "category": "general"}
{"instruction": "Explain the Add Order function", "input": "", "output": "Function: add_order\n\nAdd new order to track.\n\nArgs:\n    order_id: Unique order identifier\n    price: Limit order price\n    quantity: Order quantity\n    side: BUY or SELL\n    queue_ahead: Quantity ahead in queue when placed\n\nReturns:\n    QueueOrder object", "source": "core\\execution\\queue_position.py", "category": "general"}
{"instruction": "Explain the Remove Order function", "input": "", "output": "Function: remove_order\n\nRemove order from tracking.", "source": "core\\execution\\queue_position.py", "category": "general"}
{"instruction": "What is the formula for On Trade?", "input": "", "output": "Process trade event, advance queues.\n\nArgs:\n    price: Trade price\n    volume: Trade volume\n    side: Aggressor side (BUY = took from asks, SELL = took from bids)\n\nReturns:\n    List of queue advancements for affected orders", "source": "core\\execution\\queue_position.py", "category": "volatility"}
{"instruction": "Explain the On Trade function", "input": "", "output": "Function: on_trade\n\nProcess trade event, advance queues.\n\nArgs:\n    price: Trade price\n    volume: Trade volume\n    side: Aggressor side (BUY = took from asks, SELL = took from bids)\n\nReturns:\n    List of queue advancements for affected orders", "source": "core\\execution\\queue_position.py", "category": "volatility"}
{"instruction": "Explain the Get Position function", "input": "", "output": "Function: get_position\n\nGet current queue position for order.", "source": "core\\execution\\queue_position.py", "category": "general"}
{"instruction": "Explain the Get Fill Probability function", "input": "", "output": "Function: get_fill_probability\n\nGet fill probability for order.", "source": "core\\execution\\queue_position.py", "category": "general"}
{"instruction": "Explain the Get All Probabilities function", "input": "", "output": "Function: get_all_probabilities\n\nGet fill probabilities for all tracked orders.", "source": "core\\execution\\queue_position.py", "category": "general"}
{"instruction": "Explain the Update Book State function", "input": "", "output": "Function: update_book_state\n\nUpdate book state for probability calculations.", "source": "core\\execution\\queue_position.py", "category": "regime"}
{"instruction": "Explain the Get Summary function", "input": "", "output": "Function: get_summary\n\nGet summary DataFrame of all tracked orders.", "source": "core\\execution\\queue_position.py", "category": "general"}
{"instruction": "Explain the Record Fill function", "input": "", "output": "Function: record_fill\n\nRecord a fill with subsequent price moves.\n\nUsed to calibrate adverse selection model.", "source": "core\\execution\\queue_position.py", "category": "general"}
{"instruction": "Explain the Adverse Selection Probability function", "input": "", "output": "Function: adverse_selection_probability\n\nCalculate probability of adverse selection.\n\nReturns probability that a fill will be followed by adverse move.", "source": "core\\execution\\queue_position.py", "category": "general"}
{"instruction": "Explain the Expected Adverse Move Bps function", "input": "", "output": "Function: expected_adverse_move_bps\n\nCalculate expected adverse move in basis points.", "source": "core\\execution\\queue_position.py", "category": "general"}
{"instruction": "What is the formula for Toxicity Score?", "input": "", "output": "Calculate VPIN-style toxicity score.\n\nHigher = more informed trading, worse fills expected.\nRange: 0 (no toxicity) to 1 (all informed)", "source": "core\\execution\\queue_position.py", "category": "general"}
{"instruction": "Explain the Toxicity Score function", "input": "", "output": "Function: toxicity_score\n\nCalculate VPIN-style toxicity score.\n\nHigher = more informed trading, worse fills expected.\nRange: 0 (no toxicity) to 1 (all informed)", "source": "core\\execution\\queue_position.py", "category": "general"}
{"instruction": "What is VPIN in quantitative trading?", "input": "", "output": "VPIN (Volume-Synchronized Probability of Informed Trading).\n\nImplementation details:\nCalculate VPIN-style toxicity score.\n\nHigher = more informed trading, worse fills expected.\nRange: 0 (no toxicity) to 1 (all informed)", "source": "core\\execution\\queue_position.py", "category": "general"}
{"instruction": "Explain the purpose of Adaptive Ensemble with Chinese Quant Online Learning", "input": "", "output": "Adaptive Ensemble with Chinese Quant Online Learning\n=====================================================\n\nIntegrates Chinese quant-style online learning with the trading bot.\n\nFeatures:\n1. Load pre-trained models as base\n2. Enable incremental online updates\n3. Regime-adaptive ensemble weighting\n4. Drift detection with auto-retrain\n5. Hot-swap models without stopping trading\n\nUsage:\n    from core.ml.adaptive_ensemble import AdaptiveMLEnsemble\n\n    ensemble = AdaptiveMLEnsemble(model_dir=Path(\"models/production\"))\n    ensemble.load_models([\"EURUSD\", \"GBPUSD\"])\n    ensemble.enable_online_learning()\n\n    # In trading loop\n    signal = ensemble.predict(symbol, features)\n    ensemble.add_observation(symbol, features, actual_direction, price)", "source": "core\\ml\\adaptive_ensemble.py", "category": "alpha"}
{"instruction": "What is the Signal class and how do I use it?", "input": "", "output": "The Signal class:\n\nTrading signal from ML models.", "source": "core\\ml\\adaptive_ensemble.py", "category": "alpha"}
{"instruction": "What is the AdaptiveMLEnsemble class and how do I use it?", "input": "", "output": "The AdaptiveMLEnsemble class:\n\nML Ensemble with Chinese Quant-style Online Learning.\n\nExtends the basic MLEnsemble with:\n1. Incremental learning (增量学习)\n2. Regime detection (市场状态识别)\n3. Drift detection (概念漂移检测)\n4. Adaptive ensemble weights\n5. Hot model updates", "source": "core\\ml\\adaptive_ensemble.py", "category": "regime"}
{"instruction": "Explain the Create Adaptive Ensemble function", "input": "", "output": "Function: create_adaptive_ensemble\n\nCreate an adaptive ensemble with online learning.", "source": "core\\ml\\adaptive_ensemble.py", "category": "ensemble"}
{"instruction": "What is the formula for Load Models?", "input": "", "output": "Load pre-trained static models.", "source": "core\\ml\\adaptive_ensemble.py", "category": "general"}
{"instruction": "Explain the Load Models function", "input": "", "output": "Function: load_models\n\nLoad pre-trained static models.", "source": "core\\ml\\adaptive_ensemble.py", "category": "general"}
{"instruction": "What is the formula for Init Online Learning?", "input": "", "output": "Initialize online learners from static models.\n\nThis transfers the pre-trained models to incremental learners.", "source": "core\\ml\\adaptive_ensemble.py", "category": "general"}
{"instruction": "Explain the Init Online Learning function", "input": "", "output": "Function: init_online_learning\n\nInitialize online learners from static models.\n\nThis transfers the pre-trained models to incremental learners.", "source": "core\\ml\\adaptive_ensemble.py", "category": "general"}
{"instruction": "Explain the Start Background Updates function", "input": "", "output": "Function: start_background_updates\n\nStart background thread for periodic model updates.", "source": "core\\ml\\adaptive_ensemble.py", "category": "general"}
{"instruction": "Explain the Stop Background Updates function", "input": "", "output": "Function: stop_background_updates\n\nStop background update thread.", "source": "core\\ml\\adaptive_ensemble.py", "category": "general"}
{"instruction": "Explain the Add Observation function", "input": "", "output": "Function: add_observation\n\nAdd observation for online learning.\n\nCalled after each tick with the actual outcome.", "source": "core\\ml\\adaptive_ensemble.py", "category": "microstructure"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nGenerate trading signal with adaptive ensemble.\n\nUses online learners if enabled, falls back to static models.", "source": "core\\ml\\adaptive_ensemble.py", "category": "alpha"}
{"instruction": "Explain the Force Update function", "input": "", "output": "Function: force_update\n\nForce an immediate model update for a symbol.", "source": "core\\ml\\adaptive_ensemble.py", "category": "general"}
{"instruction": "Explain the Get Status function", "input": "", "output": "Function: get_status\n\nGet ensemble status.", "source": "core\\ml\\adaptive_ensemble.py", "category": "ensemble"}
{"instruction": "Explain the Save All function", "input": "", "output": "Function: save_all\n\nSave all online learners.", "source": "core\\ml\\adaptive_ensemble.py", "category": "general"}
{"instruction": "What is the source paper for this technique?", "input": "", "output": "The source is: https://zh.wikipedia.org/zh-hans/幻方量化. ", "source": "core\\ml\\chinese_online_learning.py", "category": "alpha"}
{"instruction": "What is the source paper for this technique?", "input": "", "output": "The source is: https://bigquant.com/wiki/doc/R1Y0qSCGV0. ", "source": "core\\ml\\chinese_online_learning.py", "category": "alpha"}
{"instruction": "What is the source paper for this technique?", "input": "", "output": "The source is: https://www.mhfunds.com/. ", "source": "core\\ml\\chinese_online_learning.py", "category": "alpha"}
{"instruction": "What is the source paper for this technique?", "input": "", "output": "The source is: https://www.jianshu.com/p/b177c67ca5c6. ", "source": "core\\ml\\chinese_online_learning.py", "category": "alpha"}
{"instruction": "What is the source paper for this technique?", "input": "", "output": "The source is: https://bigquant.com/wiki/doc/xVqIPu6RoI. ", "source": "core\\ml\\chinese_online_learning.py", "category": "alpha"}
{"instruction": "What is the source paper for this technique?", "input": "", "output": "The source is: https://blog.csdn.net/shebao3333/article/details/139669597. ", "source": "core\\ml\\chinese_online_learning.py", "category": "alpha"}
{"instruction": "What is the source paper for this technique?", "input": "", "output": "The source is: https://zhuanlan.zhihu.com/p/667029819. ", "source": "core\\ml\\chinese_online_learning.py", "category": "alpha"}
{"instruction": "What is the source paper for this technique?", "input": "", "output": "The source is: https://zhuanlan.zhihu.com/p/1958396800630253463. ", "source": "core\\ml\\chinese_online_learning.py", "category": "alpha"}
{"instruction": "Explain the purpose of Chinese Quant-Style Online Learning System", "input": "", "output": "Chinese Quant-Style Online Learning System\n==========================================\n\nBased on techniques from top Chinese quantitative hedge funds:\n\nFIRM REFERENCES:\n================\n1. 幻方量化 (High-Flyer Quant) - https://www.high-flyer.cn/\n   - Full AI automation since 2017, deep learning for trading\n   - \"萤火\" AI training platform with 10PB+ data\n   - Source: https://zh.wikipedia.org/zh-hans/幻方量化\n\n2. 九坤投资 (Ubiquant) - Founded 2012, 600B+ RMB AUM\n   - AI Lab, Data Lab, Water Drop Lab for research\n   - Full pipeline AI: data → factor mining → prediction → execution\n   - Source: https://bigquant.com/wiki/doc/R1Y0qSCGV0\n\n3. 明汯投资 (Minghui) - 400P Flops AI computing power\n   - Multi-factor with mid-frequency price-volume focus\n   - Continuous model iteration, TOP500 supercomputer cluster\n   - Source: https://www.mhfunds.com/\n\nTECHNIQUE REFERENCES:\n=====================\n1. 增量学习 (Incremental Learning):\n   - XGBoost xgb_model parameter: https://blog.csdn.net/xieyan0811/article/details/82949236\n   - LightGBM init_model: https://lightgbm.readthedocs.io/en/latest/pythonapi/lightgbm.train.html\n   - Online Gradient Boosting 254.4x faster: Academic research on incremental GBDT\n\n2. 热更新 (Hot Update):\n   - XGBoost process_type='update' with refresh_leaf=True\n   - Keeps tree structure, only updates leaf weights\n   - Source: https://www.jianshu.com/p/b177c67ca5c6\n\n3. 滚动训练 (Rolling Training):\n   - 36-month sliding window, update every 250 trading days\n   - Walk-forward validation for time series\n   - Source: https://bigquant.com/wiki/doc/xVqIPu6RoI\n\n4. 概念漂移检测 (Concept Drift Detection):\n   - KL divergence, KS test, DDM algorithm\n   - 85% of AI models degrade 30%+ in 6 months (Gartner)\n   - Source: https://blog.csdn.net/shebao3333/article/details/139669597\n\n5. 市场状态识别 (Regime Detection):\n   - HMM 3-state: 牛市(bull), 熊市(bear), 震荡(sideways)\n   - Regime-switching factor models outperform single-factor\n   - Source: https://zhuanlan.zhihu.com/p/667029819\n\n6. 因子衰减监控 (Alpha Decay):\n   - Track factor IC decay over time\n   - Auto-disable factors when effectiveness drops\n   - Source: https://zhuanlan.zhihu.com/p/1958396800630253463\n\nOFFICIAL DOCUMENTATION:\n=======================\n- XGBoost: https://xgboost.readthedocs.io/en/stable/python/python_api.html\n- LightGBM: https://lightgbm.readthedocs.io/en/latest/pythonapi/lightgbm.train.html\n- CatBoost: https://catboost.ai/en/docs/concepts/python-reference_catboostclassifier\n- hmmlearn: https://hmmlearn.readthedocs.io/en/latest/\n- scipy.stats: https://docs.scipy.org/doc/scipy/reference/stats.html", "source": "core\\ml\\chinese_online_learning.py", "category": "alpha"}
{"instruction": "What is the ReplayBuffer class and how do I use it?", "input": "", "output": "The ReplayBuffer class:\n\nExperience Replay Buffer for Catastrophic Forgetting Mitigation.\n\nGold Standard Technique:\n    Stores important historical samples (regime changes, drift periods, high-impact events)\n    and replays them during incremental training to prevent forgetting.\n\nAcademic Reference:\n    \"Incremental Learning of Stock Trends via Meta-Learning with Dynamic Adaptation\"\n    https://arxiv.org/html/2401.03865\n    \"Stock trend forecasting suffers from catastrophic forgetting due to recurring patterns\"\n\nChinese Quant Usage:\n    九坤投资 preserves important patterns across market cycles\n    幻方量化 maintains \"memory\" of past regime behaviors\n\nUsage:\n    buffer = ReplayBuffer(capacity=5000)\n    buffer.add(features, label, importance=0.8)  # High importance sample\n    replay_X, replay_y = buffer.sample(batch_size=500)\n    combined_X = np.vstack([live_X, replay_X])  # Mix with live data", "source": "core\\ml\\chinese_online_learning.py", "category": "execution"}
{"instruction": "Show me a code example for ReplayBuffer", "input": "", "output": "九坤投资 preserves important patterns across market cycles\n    幻方量化 maintains \"memory\" of past regime behaviors", "source": "core\\ml\\chinese_online_learning.py", "category": "execution"}
{"instruction": "What is the PeriodicFullRetrainer class and how do I use it?", "input": "", "output": "The PeriodicFullRetrainer class:\n\nPeriodic Full Retrain Mechanism.\n\nGold Standard Principle:\n    \"定期全量重训练优于简单增量训练\"\n    (Periodic full retrain beats simple incremental training)\n\nReference:\n    BigQuant: 36-month rolling window, retrain every 250 trading days\n    https://bigquant.com/wiki/doc/xKO5e4qSRT\n\nWhy needed:\n    1. Incremental learning accumulates errors over time\n    2. Model structure bloats (too many trees)\n    3. Historical patterns get \"forgotten\"\n    4. Feature distributions shift significantly\n\nArchitecture:\n    - Track samples since last full retrain\n    - When threshold reached, train fresh model on combined data\n    - Use replay buffer samples + recent live data\n    - Validate before swapping", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "What is the StackingMetaLearner class and how do I use it?", "input": "", "output": "The StackingMetaLearner class:\n\nStacking Meta-Learner for Ensemble Fusion.\n\nGold Standard (ICLR 2025, FinGPT):\n    \"Two-stage dynamic stacking ensemble model\"\n    Train meta-model on base model predictions, not raw features.\n\nReference:\n    https://zhuanlan.zhihu.com/p/1903528598360560074\n    \"设计多个元分类器，并为每个时间窗口动态选择最优的一个\"\n\nArchitecture:\n    Level 1: Base learners (XGBoost, LightGBM, CatBoost)\n    Level 2: Meta-learner (trains on L1 predictions + top features)\n\nWhy better than weighted average:\n    - Learns non-linear combinations\n    - Adapts to when each base model is most accurate\n    - Can incorporate confidence/agreement features", "source": "core\\ml\\chinese_online_learning.py", "category": "ensemble"}
{"instruction": "What is the RegimeState class and how do I use it?", "input": "", "output": "The RegimeState class:\n\nMarket regime state from HMM (市场状态).", "source": "core\\ml\\chinese_online_learning.py", "category": "regime"}
{"instruction": "What is the HMMRegimeDetector class and how do I use it?", "input": "", "output": "The HMMRegimeDetector class:\n\nHidden Markov Model Regime Detection.\n\nGold Standard (幻方量化, 中邮证券):\n    Use GaussianHMM for 3-state regime detection.\n    Superior to rule-based thresholds.\n\nReference:\n    https://zhuanlan.zhihu.com/p/667029819\n    \"Python量化交易-隐马尔可夫模型 (HMM)\"\n\nStates:\n    0: 牛市 (Bull) - High returns, low volatility\n    1: 熊市 (Bear) - Negative returns, high volatility\n    2: 震荡 (Sideways) - Low returns, medium volatility", "source": "core\\ml\\chinese_online_learning.py", "category": "volatility"}
{"instruction": "What is the DriftMetrics class and how do I use it?", "input": "", "output": "The DriftMetrics class:\n\nMetrics for detecting concept drift (概念漂移).", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "What is the ModelVersion class and how do I use it?", "input": "", "output": "The ModelVersion class:\n\nTrack model versions for hot-swapping.", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "What is the IncrementalXGBoost class and how do I use it?", "input": "", "output": "The IncrementalXGBoost class:\n\nXGBoost with incremental learning (增量学习).\n\nTwo modes:\n1. Add trees: Continue training, add new trees (default)\n   - Uses xgb_model parameter in xgb.train()\n   - New trees are appended to existing model\n2. Hot update: Keep tree structure, update leaf weights only\n   - Uses process_type='update', updater='refresh', refresh_leaf=True\n   - Faster but less adaptive\n\nOfficial XGBoost Documentation:\n    https://xgboost.readthedocs.io/en/stable/python/python_api.html#xgboost.train\n    Parameter: xgb_model - Booster instance or path, for continued training\n\nChinese Quant Reference:\n    https://blog.csdn.net/xieyan0811/article/details/82949236\n    \"XGBoost增量学习\" - Shows 增量训练后原树不变，只在后面追加更多的树\n\nUsage by Chinese Firms:\n    幻方量化 uses similar incremental GBDT for real-time model updates\n    九坤投资 AI Lab implements continuous model iteration", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "What is the IncrementalLightGBM class and how do I use it?", "input": "", "output": "The IncrementalLightGBM class:\n\nLightGBM with incremental learning (增量学习).\n\nUses init_model + keep_training_booster for warm start continuation.\n\nOfficial LightGBM Documentation:\n    https://lightgbm.readthedocs.io/en/latest/pythonapi/lightgbm.train.html\n    - init_model: str, Path, Booster or None - Filename/Booster to continue training\n    - keep_training_booster: bool - Whether returned booster will be used for training\n\nChinese Quant Reference:\n    https://blog.csdn.net/weixin_39559071/article/details/111735822\n    \"LightGBM如何进行在线学习\" - 工作中每天都会有数据更新以及增量数据\n\nKey Parameters:\n    init_model: Pass previous model for continued training\n    keep_training_booster=True: Critical for subsequent incremental updates\n\nExample from docs:\n    gbm = lgb.train(params, train_data, init_model=gbm, keep_training_booster=True)", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "What is the IncrementalCatBoost class and how do I use it?", "input": "", "output": "The IncrementalCatBoost class:\n\nCatBoost with incremental learning (增量学习).\n\nUses init_model parameter for warm start continuation.\nNote: Model size grows with each update (trees are appended).\n\nOfficial CatBoost Documentation:\n    https://catboost.ai/en/docs/concepts/python-reference_catboostclassifier_fit\n    - init_model: CatBoost model - Continue training starting from this model\n\nGitHub Issues (Implementation Details):\n    https://github.com/catboost/catboost/issues/1176 - Question about init_model\n    https://github.com/catboost/catboost/issues/1319 - Model size growth warning\n\nChinese Quant Usage:\n    明汯投资 uses CatBoost in their multi-model ensemble\n    Continuous iteration with incremental updates\n\nWarning:\n    Model size grows with each incremental update. Monitor and prune periodically.\n    Consider full retrain when model exceeds size threshold.", "source": "core\\ml\\chinese_online_learning.py", "category": "ensemble"}
{"instruction": "Show me a code example for IncrementalCatBoost", "input": "", "output": "明汯投资 uses CatBoost in their multi-model ensemble\n    Continuous iteration with incremental updates", "source": "core\\ml\\chinese_online_learning.py", "category": "ensemble"}
{"instruction": "What is the DriftDetector class and how do I use it?", "input": "", "output": "The DriftDetector class:\n\nConcept drift detection (概念漂移检测).\n\nDetects when model performance degrades due to changing data distributions.\nGartner reports 85% of AI models degrade 30%+ within 6 months.\n\nDetection Methods:\n1. KL Divergence: Compare feature distributions (scipy.special.rel_entr)\n2. KS Test: Kolmogorov-Smirnov statistical test (scipy.stats.ks_2samp)\n3. Accuracy Drop: Direct performance monitoring\n4. DDM (Drift Detection Method): Error rate monitoring\n\nAcademic References:\n    - \"Learning under Concept Drift\" - Gama et al. (2014)\n    - DDM Method: https://blog.csdn.net/m0_74427613/article/details/138391570\n\nChinese Quant Reference:\n    https://blog.csdn.net/shebao3333/article/details/139669597\n    \"机器学习：数据分布的漂移问题及应对方案\"\n\nOfficial scipy.stats Documentation:\n    https://docs.scipy.org/doc/scipy/reference/stats.html\n    - ks_2samp: Kolmogorov-Smirnov test for two samples\n    - rel_entr: Relative entropy (KL divergence)\n\nChinese Quant Usage:\n    九坤投资 monitors \"数据质量挑战\" and \"模型有效性挑战\"\n    Adaptive retraining when drift detected", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "Show me a code example for DriftDetector", "input": "", "output": "九坤投资 monitors \"数据质量挑战\" and \"模型有效性挑战\"\n    Adaptive retraining when drift detected", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "What is the RegimeDetector class and how do I use it?", "input": "", "output": "The RegimeDetector class:\n\nMarket regime detection (市场状态识别).\n\nIdentifies market states to adapt trading strategy and model weights.\nRegime-switching models outperform single-regime models.\n\n3 States (Based on HMM research):\n- State 0: 牛市 (Bull market) - High returns, low volatility\n- State 1: 熊市 (Bear market) - Negative returns, high volatility\n- State 2: 震荡 (Sideways) - Low returns, medium volatility\n\nAcademic References:\n    - \"Regime-Switching Factor Investing with Hidden Markov Models\"\n      https://www.mdpi.com/1911-8074/13/12/311\n    - \"Market Regime Detection using Hidden Markov Models\"\n      https://www.quantstart.com/articles/market-regime-detection-using-hidden-markov-models-in-qstrader/\n\nChinese Quant Reference:\n    https://zhuanlan.zhihu.com/p/667029819\n    \"Python量化交易-隐马尔可夫模型 (HMM)\"\n\n中邮证券 Research:\n    https://finance.sina.com.cn/stock/stockzmt/2025-08-21/doc-infmsyzm6141450.shtml\n    \"基于隐马尔科夫链与动态调制的量化择时方案\"\n\nOfficial hmmlearn Documentation:\n    https://hmmlearn.readthedocs.io/en/latest/\n    GaussianHMM for continuous observations\n\nChinese Quant Usage:\n    幻方量化 uses regime detection for strategy adaptation\n    明汯投资 applies \"自适应切换策略组合方式\"", "source": "core\\ml\\chinese_online_learning.py", "category": "alpha"}
{"instruction": "Show me a code example for RegimeDetector", "input": "", "output": "幻方量化 uses regime detection for strategy adaptation\n    明汯投资 applies \"自适应切换策略组合方式\"", "source": "core\\ml\\chinese_online_learning.py", "category": "alpha"}
{"instruction": "What is the ChineseQuantOnlineLearner class and how do I use it?", "input": "", "output": "The ChineseQuantOnlineLearner class:\n\nComplete Chinese Quant-Style Online Learning System.\n\nGOLD STANDARD IMPLEMENTATION (Audit 2026-01-18):\nCombines all techniques from 幻方量化, 九坤投资, 明汯投资:\n\n1. Incremental XGBoost/LightGBM/CatBoost (增量学习)\n2. Drift detection (概念漂移检测) - KL, KS, DDM\n3. Regime detection (市场状态识别) - HMM 3-state\n4. Adaptive retraining (自适应更新)\n5. Exponential forgetting (指数遗忘)\n6. **NEW** Replay Buffer (经验回放) - Catastrophic forgetting mitigation\n7. **NEW** Periodic Full Retrain (定期全量重训练)\n8. **NEW** Stacking Meta-Learner (堆叠元学习器)\n\nReference:\n    - BigQuant: https://bigquant.com/wiki/doc/xKO5e4qSRT\n    - MetaDA: https://arxiv.org/html/2401.03865\n    - ICLR 2025 Quant Papers: https://zhuanlan.zhihu.com/p/1903528598360560074", "source": "core\\ml\\chinese_online_learning.py", "category": "regime"}
{"instruction": "Explain the Create Online Learner function", "input": "", "output": "Function: create_online_learner\n\nFactory function to create an online learner.", "source": "core\\ml\\chinese_online_learning.py", "category": "alpha"}
{"instruction": "What is the formula for Add?", "input": "", "output": "Add sample to replay buffer.\n\nArgs:\n    features: Feature vector\n    label: Target label\n    importance: Importance score (0-1). Higher = more likely to be replayed\n               Score based on: drift detection, regime change, prediction error\n    metadata: Optional metadata (timestamp, regime, etc.)", "source": "core\\ml\\chinese_online_learning.py", "category": "regime"}
{"instruction": "Explain the Add function", "input": "", "output": "Function: add\n\nAdd sample to replay buffer.\n\nArgs:\n    features: Feature vector\n    label: Target label\n    importance: Importance score (0-1). Higher = more likely to be replayed\n               Score based on: drift detection, regime change, prediction error\n    metadata: Optional metadata (timestamp, regime, etc.)", "source": "core\\ml\\chinese_online_learning.py", "category": "regime"}
{"instruction": "Explain the Add Batch function", "input": "", "output": "Function: add_batch\n\nAdd batch of samples.", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "Explain the Sample function", "input": "", "output": "Function: sample\n\nSample from replay buffer.\n\nArgs:\n    batch_size: Number of samples to return\n    prioritized: If True, sample weighted by importance (Prioritized Experience Replay)\n\nReturns:\n    (features_array, labels_array)", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "What is the formula for Get High Importance Samples?", "input": "", "output": "Get the top-k most important samples.", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "Explain the Get High Importance Samples function", "input": "", "output": "Function: get_high_importance_samples\n\nGet the top-k most important samples.", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "Explain the Update Importance function", "input": "", "output": "Function: update_importance\n\nUpdate importance scores based on prediction errors.\n\nSamples where model was wrong get higher importance (hard examples).", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "Explain the Should Full Retrain function", "input": "", "output": "Function: should_full_retrain\n\nCheck if full retrain is needed.\n\nReturns:\n    (should_retrain, reason)", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "Explain the Record Samples function", "input": "", "output": "Function: record_samples\n\nRecord that N new samples were processed.", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "Explain the Record Full Retrain function", "input": "", "output": "Function: record_full_retrain\n\nRecord that full retrain was completed.", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "Explain the Get Status function", "input": "", "output": "Function: get_status\n\nGet retrainer status.", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "What is the formula for Fit?", "input": "", "output": "Fit meta-learner on base model predictions.\n\nArgs:\n    base_predictions: Dict of {model_name: predictions_array}\n    y_true: True labels\n    X_original: Original features (optional, for top features)\n    feature_names: Feature names (optional)", "source": "core\\ml\\chinese_online_learning.py", "category": "ensemble"}
{"instruction": "Explain the Fit function", "input": "", "output": "Function: fit\n\nFit meta-learner on base model predictions.\n\nArgs:\n    base_predictions: Dict of {model_name: predictions_array}\n    y_true: True labels\n    X_original: Original features (optional, for top features)\n    feature_names: Feature names (optional)", "source": "core\\ml\\chinese_online_learning.py", "category": "ensemble"}
{"instruction": "What is the formula for Predict?", "input": "", "output": "Predict using meta-learner.\n\nArgs:\n    base_predictions: Dict of {model_name: prediction_value}\n    X_original: Original features (optional)\n\nReturns:\n    Meta-learner prediction probability", "source": "core\\ml\\chinese_online_learning.py", "category": "ensemble"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nPredict using meta-learner.\n\nArgs:\n    base_predictions: Dict of {model_name: prediction_value}\n    X_original: Original features (optional)\n\nReturns:\n    Meta-learner prediction probability", "source": "core\\ml\\chinese_online_learning.py", "category": "ensemble"}
{"instruction": "What is the formula for Update Incremental?", "input": "", "output": "Incremental update of meta-learner.\n\nFor XGBoost/LightGBM, uses warm-start continuation.", "source": "core\\ml\\chinese_online_learning.py", "category": "ensemble"}
{"instruction": "Explain the Update Incremental function", "input": "", "output": "Function: update_incremental\n\nIncremental update of meta-learner.\n\nFor XGBoost/LightGBM, uses warm-start continuation.", "source": "core\\ml\\chinese_online_learning.py", "category": "ensemble"}
{"instruction": "Explain the Update function", "input": "", "output": "Function: update\n\nUpdate with new price.", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "Explain the Fit function", "input": "", "output": "Function: fit\n\nFit HMM on buffered data.", "source": "core\\ml\\chinese_online_learning.py", "category": "regime"}
{"instruction": "What is HMM in quantitative trading?", "input": "", "output": "HMM (Hidden Markov Model for regime detection).\n\nImplementation details:\nFit HMM on buffered data.", "source": "core\\ml\\chinese_online_learning.py", "category": "regime"}
{"instruction": "Explain the Detect Regime function", "input": "", "output": "Function: detect_regime\n\nDetect current market regime.", "source": "core\\ml\\chinese_online_learning.py", "category": "regime"}
{"instruction": "Explain the Initial Train function", "input": "", "output": "Function: initial_train\n\nInitial training from scratch.", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "Explain the Incremental Update function", "input": "", "output": "Function: incremental_update\n\nIncremental update with new data.\n\nUses xgb_model parameter for warm start.\nReference: XGBoost train() xgb_model parameter", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nPredict probabilities with feature alignment.", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "Explain the Save function", "input": "", "output": "Function: save\n\nSave model and version info.", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "Explain the Load function", "input": "", "output": "Function: load\n\nLoad model and version info.", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "Explain the Initial Train function", "input": "", "output": "Function: initial_train\n\nInitial training from scratch.", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "What is the formula for Incremental Update?", "input": "", "output": "Incremental update with new data.\n\nKey: init_model parameter + keep_training_booster=True", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "Explain the Incremental Update function", "input": "", "output": "Function: incremental_update\n\nIncremental update with new data.\n\nKey: init_model parameter + keep_training_booster=True", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nPredict probabilities with feature alignment.", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "Explain the Save function", "input": "", "output": "Function: save\n\nSave model.", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "Explain the Load function", "input": "", "output": "Function: load\n\nLoad model.", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "Explain the Initial Train function", "input": "", "output": "Function: initial_train\n\nInitial training from scratch.", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "Explain the Incremental Update function", "input": "", "output": "Function: incremental_update\n\nIncremental update with new data.\n\nUses init_model for warm start.\nWARNING: Model size grows with each update.", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "Explain the Predict Proba function", "input": "", "output": "Function: predict_proba\n\nPredict probabilities with feature alignment.", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "Explain the Save function", "input": "", "output": "Function: save\n\nSave model.", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "Explain the Load function", "input": "", "output": "Function: load\n\nLoad model.", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "Explain the Set Reference function", "input": "", "output": "Function: set_reference\n\nSet reference distribution for drift detection.", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "What is the formula for Add Observation?", "input": "", "output": "Add prediction/actual pair for accuracy monitoring.", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "Explain the Add Observation function", "input": "", "output": "Function: add_observation\n\nAdd prediction/actual pair for accuracy monitoring.", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "Explain the Check Drift function", "input": "", "output": "Function: check_drift\n\nCheck for concept drift.\n\nReturns DriftMetrics with drift indicators.", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "Explain the Update function", "input": "", "output": "Function: update\n\nUpdate with new price.", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "Explain the Detect Regime function", "input": "", "output": "Function: detect_regime\n\nDetect current market regime.", "source": "core\\ml\\chinese_online_learning.py", "category": "regime"}
{"instruction": "Explain the Initial Train function", "input": "", "output": "Function: initial_train\n\nInitial training of all models.", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "Explain the Add Tick function", "input": "", "output": "Function: add_tick\n\nAdd new tick data to buffers.\n\nCalled for each incoming tick during live trading.\nGold standard: Also populates replay buffer with important samples.", "source": "core\\ml\\chinese_online_learning.py", "category": "microstructure"}
{"instruction": "What is the formula for Predict?", "input": "", "output": "Ensemble prediction with regime-adaptive weights.\n\nGOLD STANDARD: Uses stacking meta-learner when available.\n\nReturns: (probability, confidence)", "source": "core\\ml\\chinese_online_learning.py", "category": "regime"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nEnsemble prediction with regime-adaptive weights.\n\nGOLD STANDARD: Uses stacking meta-learner when available.\n\nReturns: (probability, confidence)", "source": "core\\ml\\chinese_online_learning.py", "category": "regime"}
{"instruction": "Explain the Should Update function", "input": "", "output": "Function: should_update\n\nCheck if incremental update should run.", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "What is the formula for Incremental Update?", "input": "", "output": "Perform incremental update with buffered data.\n\nGOLD STANDARD IMPLEMENTATION (Audit 2026-01-18):\n1. Exponential weighting for recent data\n2. Drift-triggered retraining\n3. Regime-adaptive model selection\n4. **NEW** Replay buffer mixing (catastrophic forgetting mitigation)\n5. **NEW** Periodic full retrain check\n6. **NEW** Meta-learner update", "source": "core\\ml\\chinese_online_learning.py", "category": "regime"}
{"instruction": "Explain the Incremental Update function", "input": "", "output": "Function: incremental_update\n\nPerform incremental update with buffered data.\n\nGOLD STANDARD IMPLEMENTATION (Audit 2026-01-18):\n1. Exponential weighting for recent data\n2. Drift-triggered retraining\n3. Regime-adaptive model selection\n4. **NEW** Replay buffer mixing (catastrophic forgetting mitigation)\n5. **NEW** Periodic full retrain check\n6. **NEW** Meta-learner update", "source": "core\\ml\\chinese_online_learning.py", "category": "regime"}
{"instruction": "Explain the Save Models function", "input": "", "output": "Function: save_models\n\nSave all models to disk.", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "Explain the Load Models function", "input": "", "output": "Function: load_models\n\nLoad models from disk.", "source": "core\\ml\\chinese_online_learning.py", "category": "general"}
{"instruction": "Explain the purpose of Hot Swappable Ensemble Manager", "input": "", "output": "Hot Swappable Ensemble Manager\n==============================\nAtomic model replacement for live trading without interruption.", "source": "core\\ml\\ensemble.py", "category": "ensemble"}
{"instruction": "What is the ModelVersion class and how do I use it?", "input": "", "output": "The ModelVersion class:\n\nTracks a model version.", "source": "core\\ml\\ensemble.py", "category": "general"}
{"instruction": "What is the HotSwappableEnsemble class and how do I use it?", "input": "", "output": "The HotSwappableEnsemble class:\n\nThread-safe ensemble manager with atomic model swapping.\n\nAllows retraining in background while predictions continue\nusing current models. New models are swapped in atomically.", "source": "core\\ml\\ensemble.py", "category": "ensemble"}
{"instruction": "Explain the Get Ensemble function", "input": "", "output": "Function: get_ensemble\n\nGet or create ensemble manager for symbol.", "source": "core\\ml\\ensemble.py", "category": "ensemble"}
{"instruction": "What is the formula for Predict?", "input": "", "output": "Make ensemble prediction using current models.\n\nArgs:\n    features: Feature dict from HFTFeatureEngine\n\nReturns:\n    (probability, confidence) - probability of up move, confidence", "source": "core\\ml\\ensemble.py", "category": "ensemble"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nMake ensemble prediction using current models.\n\nArgs:\n    features: Feature dict from HFTFeatureEngine\n\nReturns:\n    (probability, confidence) - probability of up move, confidence", "source": "core\\ml\\ensemble.py", "category": "ensemble"}
{"instruction": "Explain the Hot Swap function", "input": "", "output": "Function: hot_swap\n\nAtomically swap in new models.\n\nArgs:\n    new_models: Dict with 'xgboost', 'lightgbm', 'catboost' models\n    feature_names: List of feature names\n    accuracy: Validation accuracy\n    auc: Validation AUC\n    n_samples: Number of training samples\n\nReturns:\n    True if swap successful", "source": "core\\ml\\ensemble.py", "category": "general"}
{"instruction": "Explain the Rollback function", "input": "", "output": "Function: rollback\n\nRollback to previous model version.", "source": "core\\ml\\ensemble.py", "category": "general"}
{"instruction": "Explain the Get Stats function", "input": "", "output": "Function: get_stats\n\nGet current model stats.", "source": "core\\ml\\ensemble.py", "category": "general"}
{"instruction": "Explain the purpose of Feature Selector - Intelligent Feature Selection for World-Class ML", "input": "", "output": "Feature Selector - Intelligent Feature Selection for World-Class ML\n====================================================================\nImplements multi-stage feature selection:\n1. Variance Filter - Remove low-variance features\n2. Correlation Filter - Remove highly correlated features\n3. Mutual Information - Rank by information gain\n4. Tree Importance - Use LightGBM for importance ranking\n\nTarget: 1,500+ features -> 400 gold features per pair", "source": "core\\ml\\feature_selector.py", "category": "risk"}
{"instruction": "What is the FeatureSelectionConfig class and how do I use it?", "input": "", "output": "The FeatureSelectionConfig class:\n\nConfiguration for feature selection pipeline.", "source": "core\\ml\\feature_selector.py", "category": "general"}
{"instruction": "What is the FeatureSelector class and how do I use it?", "input": "", "output": "The FeatureSelector class:\n\nMulti-stage feature selection pipeline.\n\nPipeline:\n    1. Variance Filter: Remove constant/near-constant features\n    2. Correlation Filter: Remove highly correlated redundant features\n    3. Mutual Information: Rank features by information gain with target\n    4. Tree Importance: Final ranking using LightGBM feature importance\n\nUsage:\n    selector = FeatureSelector()\n    gold_features = selector.fit_transform(X_train, y_train, feature_names)\n    X_train_selected = X_train[:, selector.selected_indices_]\n    X_test_selected = X_test[:, selector.selected_indices_]", "source": "core\\ml\\feature_selector.py", "category": "risk"}
{"instruction": "Show me a code example for FeatureSelector", "input": "", "output": "selector = FeatureSelector()\n    gold_features = selector.fit_transform(X_train, y_train, feature_names)\n    X_train_selected = X_train[:, selector.selected_indices_]\n    X_test_selected = X_test[:, selector.selected_indices_]", "source": "core\\ml\\feature_selector.py", "category": "risk"}
{"instruction": "What is the AdaptiveFeatureSelector class and how do I use it?", "input": "", "output": "The AdaptiveFeatureSelector class:\n\nAdaptive feature selector that maintains separate feature sets per symbol.\n\nEach symbol may have different optimal features due to:\n- Different liquidity patterns\n- Different correlation structures\n- Different information sources (e.g., EUR pairs vs JPY pairs)\n\nUsage:\n    adaptive = AdaptiveFeatureSelector()\n\n    # Fit for each symbol\n    for symbol in symbols:\n        adaptive.fit(symbol, X_train, y_train, feature_names)\n\n    # Transform\n    X_selected = adaptive.transform(symbol, X)", "source": "core\\ml\\feature_selector.py", "category": "general"}
{"instruction": "Show me a code example for AdaptiveFeatureSelector", "input": "", "output": "adaptive = AdaptiveFeatureSelector()", "source": "core\\ml\\feature_selector.py", "category": "general"}
{"instruction": "Explain the Select Features Fast function", "input": "", "output": "Function: select_features_fast\n\nFast feature selection for quick experimentation.\n\nArgs:\n    X: Feature matrix\n    y: Target vector\n    feature_names: Feature names\n    top_k: Number of features to select\n\nReturns:\n    (selected_indices, selected_names, scores)", "source": "core\\ml\\feature_selector.py", "category": "general"}
{"instruction": "Explain the Create Feature Selector function", "input": "", "output": "Function: create_feature_selector\n\nFactory function to create feature selectors.\n\nArgs:\n    config: Feature selection config (uses defaults if None)\n    adaptive: If True, creates AdaptiveFeatureSelector\n    shared_features: Min shared features for adaptive selector\n\nReturns:\n    FeatureSelector or AdaptiveFeatureSelector instance", "source": "core\\ml\\feature_selector.py", "category": "alpha"}
{"instruction": "Explain the Fit function", "input": "", "output": "Function: fit\n\nFit the feature selector.\n\nArgs:\n    X: Feature matrix (n_samples, n_features)\n    y: Target vector (n_samples,)\n    feature_names: List of feature names\n\nReturns:\n    self", "source": "core\\ml\\feature_selector.py", "category": "general"}
{"instruction": "Explain the Transform function", "input": "", "output": "Function: transform\n\nTransform features using fitted selector.\n\nArgs:\n    X: Feature matrix (n_samples, n_features)\n\nReturns:\n    Selected features (n_samples, n_selected)", "source": "core\\ml\\feature_selector.py", "category": "general"}
{"instruction": "Explain the Fit Transform function", "input": "", "output": "Function: fit_transform\n\nFit and transform in one call.", "source": "core\\ml\\feature_selector.py", "category": "general"}
{"instruction": "Explain the Save function", "input": "", "output": "Function: save\n\nSave fitted selector to disk.", "source": "core\\ml\\feature_selector.py", "category": "general"}
{"instruction": "Explain the Load function", "input": "", "output": "Function: load\n\nLoad fitted selector from disk.", "source": "core\\ml\\feature_selector.py", "category": "general"}
{"instruction": "Explain the Get Summary function", "input": "", "output": "Function: get_summary\n\nGet summary of feature selection.", "source": "core\\ml\\feature_selector.py", "category": "general"}
{"instruction": "Explain the Fit function", "input": "", "output": "Function: fit\n\nFit selector for a specific symbol.", "source": "core\\ml\\feature_selector.py", "category": "general"}
{"instruction": "Explain the Transform function", "input": "", "output": "Function: transform\n\nTransform features for a specific symbol.", "source": "core\\ml\\feature_selector.py", "category": "general"}
{"instruction": "Explain the Get Shared Features function", "input": "", "output": "Function: get_shared_features\n\nGet features that are important across all symbols.", "source": "core\\ml\\feature_selector.py", "category": "general"}
{"instruction": "Explain the Save function", "input": "", "output": "Function: save\n\nSave all selectors to disk.", "source": "core\\ml\\feature_selector.py", "category": "general"}
{"instruction": "Explain the Load function", "input": "", "output": "Function: load\n\nLoad all selectors from disk.", "source": "core\\ml\\feature_selector.py", "category": "general"}
{"instruction": "Explain the purpose of GPU Configuration for Maximum Performance on RTX 5080", "input": "", "output": "GPU Configuration for Maximum Performance on RTX 5080\n\nSystem: AMD Ryzen 9 9900X (12c/24t) + RTX 5080 16GB + 32GB DDR5-4800\nTarget: 80-95% GPU utilization, minimize training time", "source": "core\\ml\\gpu_config.py", "category": "general"}
{"instruction": "Explain the Configure Gpu function", "input": "", "output": "Function: configure_gpu\n\nConfigure GPU for maximum ML performance.", "source": "core\\ml\\gpu_config.py", "category": "general"}
{"instruction": "What is the formula for Get Xgb Gpu Params?", "input": "", "output": "XGBoost params optimized for RTX 5080 16GB.\n\nNote: XGBoost 2.0+ changed GPU usage:\n- tree_method: 'hist' (not 'gpu_hist')\n- device: 'cuda' enables GPU\n\nArgs:\n    aggressive: If True, use max settings for speed (default)\n               If False, use conservative settings for stability", "source": "core\\ml\\gpu_config.py", "category": "general"}
{"instruction": "Explain the Get Xgb Gpu Params function", "input": "", "output": "Function: get_xgb_gpu_params\n\nXGBoost params optimized for RTX 5080 16GB.\n\nNote: XGBoost 2.0+ changed GPU usage:\n- tree_method: 'hist' (not 'gpu_hist')\n- device: 'cuda' enables GPU\n\nArgs:\n    aggressive: If True, use max settings for speed (default)\n               If False, use conservative settings for stability", "source": "core\\ml\\gpu_config.py", "category": "general"}
{"instruction": "Explain the Get Lgb Gpu Params function", "input": "", "output": "Function: get_lgb_gpu_params\n\nLightGBM params optimized for RTX 5080 16GB.\n\nArgs:\n    aggressive: If True, use max settings for speed (default)", "source": "core\\ml\\gpu_config.py", "category": "general"}
{"instruction": "Explain the Get Catboost Gpu Params function", "input": "", "output": "Function: get_catboost_gpu_params\n\nCatBoost params optimized for RTX 5080 16GB.\n\nArgs:\n    aggressive: If True, use max settings for speed (default)", "source": "core\\ml\\gpu_config.py", "category": "general"}
{"instruction": "Explain the Get Xgb Concurrent Params function", "input": "", "output": "Function: get_xgb_concurrent_params\n\nXGBoost params for concurrent training (3 jobs on RTX 5080).\n\nReduced depth and bins to fit 3 models in 16GB VRAM.", "source": "core\\ml\\gpu_config.py", "category": "general"}
{"instruction": "Explain the Get Lgb Concurrent Params function", "input": "", "output": "Function: get_lgb_concurrent_params\n\nLightGBM params for concurrent training (3 jobs on RTX 5080).\n\nReduced depth and leaves to fit 3 models in 16GB VRAM.", "source": "core\\ml\\gpu_config.py", "category": "general"}
{"instruction": "Explain the Get Catboost Concurrent Params function", "input": "", "output": "Function: get_catboost_concurrent_params\n\nCatBoost params for concurrent training (3 jobs on RTX 5080).\n\nReduced depth and iterations to fit 3 models in 16GB VRAM.", "source": "core\\ml\\gpu_config.py", "category": "general"}
{"instruction": "Explain the Get Concurrent Training Config function", "input": "", "output": "Function: get_concurrent_training_config\n\nGet full config for parallel training.\n\nReturns dict with recommended settings for parallel training.", "source": "core\\ml\\gpu_config.py", "category": "general"}
{"instruction": "Explain the Set High Priority function", "input": "", "output": "Function: set_high_priority\n\nSet current process to high priority for ML training.", "source": "core\\ml\\gpu_config.py", "category": "general"}
{"instruction": "What is the formula for Set Cpu Affinity?", "input": "", "output": "Set CPU affinity to physical cores only (avoids hyperthreading overhead).\n\nArgs:\n    physical_cores_only: If True, use only cores 0-11 (physical)\n                        If False, use all 24 logical processors", "source": "core\\ml\\gpu_config.py", "category": "general"}
{"instruction": "Explain the Set Cpu Affinity function", "input": "", "output": "Function: set_cpu_affinity\n\nSet CPU affinity to physical cores only (avoids hyperthreading overhead).\n\nArgs:\n    physical_cores_only: If True, use only cores 0-11 (physical)\n                        If False, use all 24 logical processors", "source": "core\\ml\\gpu_config.py", "category": "general"}
{"instruction": "What is the formula for Optimize For Training?", "input": "", "output": "One-call function to optimize everything for ML training.", "source": "core\\ml\\gpu_config.py", "category": "general"}
{"instruction": "Explain the Optimize For Training function", "input": "", "output": "Function: optimize_for_training\n\nOne-call function to optimize everything for ML training.", "source": "core\\ml\\gpu_config.py", "category": "general"}
{"instruction": "What is the formula for Get Tabnet Gpu Params?", "input": "", "output": "TabNet params optimized for RTX 5080 16GB.\n\nTabNet uses attention mechanism for feature selection.\nGood for interpretability + competitive with GBMs.\n\nArgs:\n    aggressive: If True, use larger architecture", "source": "core\\ml\\gpu_config.py", "category": "general"}
{"instruction": "Explain the Get Tabnet Gpu Params function", "input": "", "output": "Function: get_tabnet_gpu_params\n\nTabNet params optimized for RTX 5080 16GB.\n\nTabNet uses attention mechanism for feature selection.\nGood for interpretability + competitive with GBMs.\n\nArgs:\n    aggressive: If True, use larger architecture", "source": "core\\ml\\gpu_config.py", "category": "general"}
{"instruction": "What is the formula for Get Cnn Gpu Params?", "input": "", "output": "1D-CNN params optimized for RTX 5080 16GB.\n\nTreats features as 1D signal, captures local patterns.\nGood for detecting feature interactions.\n\nArgs:\n    aggressive: If True, use deeper architecture", "source": "core\\ml\\gpu_config.py", "category": "alpha"}
{"instruction": "Explain the Get Cnn Gpu Params function", "input": "", "output": "Function: get_cnn_gpu_params\n\n1D-CNN params optimized for RTX 5080 16GB.\n\nTreats features as 1D signal, captures local patterns.\nGood for detecting feature interactions.\n\nArgs:\n    aggressive: If True, use deeper architecture", "source": "core\\ml\\gpu_config.py", "category": "alpha"}
{"instruction": "What is the formula for Get Mlp Gpu Params?", "input": "", "output": "MLP (Multi-Layer Perceptron) params for RTX 5080 16GB.\n\nDeep fully-connected network with batch normalization.\nGood baseline for tabular data.\n\nArgs:\n    aggressive: If True, use deeper/wider architecture", "source": "core\\ml\\gpu_config.py", "category": "general"}
{"instruction": "Explain the Get Mlp Gpu Params function", "input": "", "output": "Function: get_mlp_gpu_params\n\nMLP (Multi-Layer Perceptron) params for RTX 5080 16GB.\n\nDeep fully-connected network with batch normalization.\nGood baseline for tabular data.\n\nArgs:\n    aggressive: If True, use deeper/wider architecture", "source": "core\\ml\\gpu_config.py", "category": "general"}
{"instruction": "Explain the Get Transformer Gpu Params function", "input": "", "output": "Function: get_transformer_gpu_params\n\nTransformer params for time series (iTransformer style).\n\nFor sequence modeling of OHLCV data.\nBest for capturing temporal dependencies.\n\nArgs:\n    aggressive: If True, use larger model", "source": "core\\ml\\gpu_config.py", "category": "general"}
{"instruction": "What is the formula for Get Neural Concurrent Params?", "input": "", "output": "Neural network params for concurrent training with GBMs.\n\nReduced model sizes to fit alongside XGB/LGB/CB training.\nMemory budget: ~2GB for neural nets (vs 5GB each for GBMs).", "source": "core\\ml\\gpu_config.py", "category": "general"}
{"instruction": "Explain the Get Neural Concurrent Params function", "input": "", "output": "Function: get_neural_concurrent_params\n\nNeural network params for concurrent training with GBMs.\n\nReduced model sizes to fit alongside XGB/LGB/CB training.\nMemory budget: ~2GB for neural nets (vs 5GB each for GBMs).", "source": "core\\ml\\gpu_config.py", "category": "general"}
{"instruction": "What is the formula for Get Stacking Training Config?", "input": "", "output": "Get full config for 6-model stacking ensemble.\n\nMemory budget for RTX 5080 16GB:\n- XGBoost: ~3GB\n- LightGBM: ~2GB\n- CatBoost: ~3GB\n- TabNet: ~1.5GB\n- CNN: ~0.5GB\n- MLP: ~0.5GB\n- Total: ~10.5GB (leaves 5.5GB headroom)", "source": "core\\ml\\gpu_config.py", "category": "ensemble"}
{"instruction": "Explain the Get Stacking Training Config function", "input": "", "output": "Function: get_stacking_training_config\n\nGet full config for 6-model stacking ensemble.\n\nMemory budget for RTX 5080 16GB:\n- XGBoost: ~3GB\n- LightGBM: ~2GB\n- CatBoost: ~3GB\n- TabNet: ~1.5GB\n- CNN: ~0.5GB\n- MLP: ~0.5GB\n- Total: ~10.5GB (leaves 5.5GB headroom)", "source": "core\\ml\\gpu_config.py", "category": "ensemble"}
{"instruction": "What is the formula for Get Max Parallel Config?", "input": "", "output": "Config for MAXIMUM system utilization.\n\nTarget:\n- GPU: 85-95% utilization, 280-320W power draw\n- CPU: 75-85% utilization (all 12 cores)\n- RAM: 20-25 GB used (from 32GB available)\n\nArchitecture:\n- 3 GPU training jobs in parallel (5GB VRAM each)\n- 4 CPU feature workers (3 threads each = 12 cores)\n- Pipeline parallelism: Stage 1 (CPU) feeds Stage 2 (GPU)\n\nMemory Budget (16GB VRAM):\n- Job 1: XGBoost ~3GB + LightGBM ~2GB = 5GB\n- Job 2: CatBoost ~3GB + buffer = 4GB\n- Job 3: TabNet ~1.5GB + CNN ~0.5GB + MLP ~0.5GB + buffer = 4GB\n- Overhead: ~3GB\n- Total: ~16GB", "source": "core\\ml\\gpu_config.py", "category": "general"}
{"instruction": "Explain the Get Max Parallel Config function", "input": "", "output": "Function: get_max_parallel_config\n\nConfig for MAXIMUM system utilization.\n\nTarget:\n- GPU: 85-95% utilization, 280-320W power draw\n- CPU: 75-85% utilization (all 12 cores)\n- RAM: 20-25 GB used (from 32GB available)\n\nArchitecture:\n- 3 GPU training jobs in parallel (5GB VRAM each)\n- 4 CPU feature workers (3 threads each = 12 cores)\n- Pipeline parallelism: Stage 1 (CPU) feeds Stage 2 (GPU)\n\nMemory Budget (16GB VRAM):\n- Job 1: XGBoost ~3GB + LightGBM ~2GB = 5GB\n- Job 2: CatBoost ~3GB + buffer = 4GB\n- Job 3: TabNet ~1.5GB + CNN ~0.5GB + MLP ~0.5GB + buffer = 4GB\n- Overhead: ~3GB\n- Total: ~16GB", "source": "core\\ml\\gpu_config.py", "category": "general"}
{"instruction": "Explain the Verify Max Parallel Ready function", "input": "", "output": "Function: verify_max_parallel_ready\n\nVerify system is ready for max parallel training.\n\nReturns dict with status of each component.", "source": "core\\ml\\gpu_config.py", "category": "general"}
{"instruction": "Explain the Print System Info function", "input": "", "output": "Function: print_system_info\n\nPrint current system configuration.", "source": "core\\ml\\gpu_config.py", "category": "general"}
{"instruction": "Explain the purpose of Live Retrainer - Background GPU Training", "input": "", "output": "Live Retrainer - Background GPU Training\n========================================\nContinuously retrains models on RTX 5080 using live tick data.", "source": "core\\ml\\live_retrainer.py", "category": "microstructure"}
{"instruction": "What is the LiveRetrainer class and how do I use it?", "input": "", "output": "The LiveRetrainer class:\n\nBackground retraining engine that maxes out GPU utilization.\n\nRuns in a separate thread, periodically:\n1. Extracts data from tick buffer\n2. Trains XGBoost + LightGBM + CatBoost on GPU\n3. Hot-swaps models if accuracy improves", "source": "core\\ml\\live_retrainer.py", "category": "microstructure"}
{"instruction": "Explain the Get Retrainer function", "input": "", "output": "Function: get_retrainer\n\nGet or create the global retrainer.", "source": "core\\ml\\live_retrainer.py", "category": "general"}
{"instruction": "Explain the Start function", "input": "", "output": "Function: start\n\nStart background retraining thread.", "source": "core\\ml\\live_retrainer.py", "category": "general"}
{"instruction": "Explain the Stop function", "input": "", "output": "Function: stop\n\nStop background retraining.", "source": "core\\ml\\live_retrainer.py", "category": "general"}
{"instruction": "Explain the Get Stats function", "input": "", "output": "Function: get_stats\n\nGet retrainer statistics.", "source": "core\\ml\\live_retrainer.py", "category": "general"}
{"instruction": "Explain the purpose of Neural Models for Stacking Ensemble", "input": "", "output": "Neural Models for Stacking Ensemble\n====================================\nImplements:\n1. CNN1DClassifier - 1D Convolutional network for feature patterns\n2. MLPClassifier - Multi-layer perceptron with batch normalization\n\nBoth models are designed to complement gradient boosting methods in stacking.", "source": "core\\ml\\neural_models.py", "category": "volatility"}
{"instruction": "What is the CNN1D class and how do I use it?", "input": "", "output": "The CNN1D class:\n\n1D Convolutional Neural Network for tabular data.", "source": "core\\ml\\neural_models.py", "category": "volatility"}
{"instruction": "What is the CNN1DClassifier class and how do I use it?", "input": "", "output": "The CNN1DClassifier class:\n\n1D-CNN Classifier wrapper with sklearn-like interface.\n\nUsage:\n    model = CNN1DClassifier(input_dim=400)\n    model.fit(X_train, y_train, X_val, y_val)\n    proba = model.predict_proba(X_test)", "source": "core\\ml\\neural_models.py", "category": "general"}
{"instruction": "Show me a code example for CNN1DClassifier", "input": "", "output": "model = CNN1DClassifier(input_dim=400)\n    model.fit(X_train, y_train, X_val, y_val)\n    proba = model.predict_proba(X_test)", "source": "core\\ml\\neural_models.py", "category": "general"}
{"instruction": "What is the MLP class and how do I use it?", "input": "", "output": "The MLP class:\n\nMulti-Layer Perceptron for tabular data.", "source": "core\\ml\\neural_models.py", "category": "general"}
{"instruction": "What is the MLPClassifier class and how do I use it?", "input": "", "output": "The MLPClassifier class:\n\nMLP Classifier wrapper with sklearn-like interface.\n\nUsage:\n    model = MLPClassifier(input_dim=400)\n    model.fit(X_train, y_train, X_val, y_val)\n    proba = model.predict_proba(X_test)", "source": "core\\ml\\neural_models.py", "category": "general"}
{"instruction": "Show me a code example for MLPClassifier", "input": "", "output": "model = MLPClassifier(input_dim=400)\n    model.fit(X_train, y_train, X_val, y_val)\n    proba = model.predict_proba(X_test)", "source": "core\\ml\\neural_models.py", "category": "general"}
{"instruction": "What is the EnsembleNeuralNet class and how do I use it?", "input": "", "output": "The EnsembleNeuralNet class:\n\nCombined CNN + MLP for richer feature extraction.\n\nCombines:\n- CNN path: Captures local patterns across features\n- MLP path: Captures global feature interactions\n- Fusion: Combines both paths", "source": "core\\ml\\neural_models.py", "category": "ensemble"}
{"instruction": "What is the EnsembleNeuralClassifier class and how do I use it?", "input": "", "output": "The EnsembleNeuralClassifier class:\n\nCombined CNN + MLP classifier.\n\nUsage:\n    model = EnsembleNeuralClassifier(input_dim=400)\n    model.fit(X_train, y_train, X_val, y_val)\n    proba = model.predict_proba(X_test)", "source": "core\\ml\\neural_models.py", "category": "ensemble"}
{"instruction": "Show me a code example for EnsembleNeuralClassifier", "input": "", "output": "model = EnsembleNeuralClassifier(input_dim=400)\n    model.fit(X_train, y_train, X_val, y_val)\n    proba = model.predict_proba(X_test)", "source": "core\\ml\\neural_models.py", "category": "ensemble"}
{"instruction": "What is the formula for Create Neural Classifier?", "input": "", "output": "Factory function to create neural classifiers.\n\nArgs:\n    model_type: 'cnn', 'mlp', or 'ensemble'\n    n_features: Number of input features\n    seq_len: Sequence length for CNN\n    use_gpu: Whether to use GPU\n    **kwargs: Additional model-specific arguments\n\nReturns:\n    Neural classifier instance", "source": "core\\ml\\neural_models.py", "category": "alpha"}
{"instruction": "Explain the Create Neural Classifier function", "input": "", "output": "Function: create_neural_classifier\n\nFactory function to create neural classifiers.\n\nArgs:\n    model_type: 'cnn', 'mlp', or 'ensemble'\n    n_features: Number of input features\n    seq_len: Sequence length for CNN\n    use_gpu: Whether to use GPU\n    **kwargs: Additional model-specific arguments\n\nReturns:\n    Neural classifier instance", "source": "core\\ml\\neural_models.py", "category": "alpha"}
{"instruction": "Explain the Fit function", "input": "", "output": "Function: fit\n\nFit the CNN model.", "source": "core\\ml\\neural_models.py", "category": "general"}
{"instruction": "Explain the Predict Proba function", "input": "", "output": "Function: predict_proba\n\nPredict probabilities.", "source": "core\\ml\\neural_models.py", "category": "general"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nPredict class labels.", "source": "core\\ml\\neural_models.py", "category": "general"}
{"instruction": "Explain the Save function", "input": "", "output": "Function: save\n\nSave model to disk.", "source": "core\\ml\\neural_models.py", "category": "general"}
{"instruction": "Explain the Load function", "input": "", "output": "Function: load\n\nLoad model from disk.", "source": "core\\ml\\neural_models.py", "category": "general"}
{"instruction": "Explain the Fit function", "input": "", "output": "Function: fit\n\nFit the MLP model.", "source": "core\\ml\\neural_models.py", "category": "general"}
{"instruction": "Explain the Predict Proba function", "input": "", "output": "Function: predict_proba\n\nPredict probabilities.", "source": "core\\ml\\neural_models.py", "category": "general"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nPredict class labels.", "source": "core\\ml\\neural_models.py", "category": "general"}
{"instruction": "Explain the Save function", "input": "", "output": "Function: save\n\nSave model to disk.", "source": "core\\ml\\neural_models.py", "category": "general"}
{"instruction": "Explain the Load function", "input": "", "output": "Function: load\n\nLoad model from disk.", "source": "core\\ml\\neural_models.py", "category": "general"}
{"instruction": "Explain the Fit function", "input": "", "output": "Function: fit\n\nFit the ensemble neural model.", "source": "core\\ml\\neural_models.py", "category": "ensemble"}
{"instruction": "Explain the Predict Proba function", "input": "", "output": "Function: predict_proba\n\nPredict probabilities.", "source": "core\\ml\\neural_models.py", "category": "general"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nPredict class labels.", "source": "core\\ml\\neural_models.py", "category": "general"}
{"instruction": "Explain the Save function", "input": "", "output": "Function: save\n\nSave model to disk.", "source": "core\\ml\\neural_models.py", "category": "general"}
{"instruction": "Explain the Load function", "input": "", "output": "Function: load\n\nLoad model from disk.", "source": "core\\ml\\neural_models.py", "category": "general"}
{"instruction": "Explain the purpose of ParallelTrainer - Pipeline Parallel Training for RTX 5080 + Ryzen 9 9900X", "input": "", "output": "ParallelTrainer - Pipeline Parallel Training for RTX 5080 + Ryzen 9 9900X\n=========================================================================\nMaximizes GPU utilization by running feature generation (CPU) in parallel\nwith model training (GPU).\n\nArchitecture:\n    Stage 1: Feature Generation (CPU - 4 workers)\n    ProcessPoolExecutor generates mega features for 4 pairs simultaneously\n\n    Stage 2: GPU Training (3 concurrent jobs)\n    ThreadPoolExecutor trains XGB+LGB+CB for 3 pairs on GPU\n\nExpected speedup: ~3x (10 hours -> 3.5 hours for 52 pairs)\n\nUsage:\n    from core.ml.parallel_trainer import ParallelTrainer\n\n    trainer = ParallelTrainer()\n    results = trainer.train_all(pairs=['EURUSD', 'GBPUSD', ...])", "source": "core\\ml\\parallel_trainer.py", "category": "general"}
{"instruction": "What is the formula for Generate Features For Pair?", "input": "", "output": "CPU worker: Generate mega features for one pair.\n\nThis function runs in a separate process to parallelize CPU-bound feature generation.\n\nArgs:\n    args: Tuple of (pair, training_dir, output_dir, max_samples)\n\nReturns:\n    Tuple of (pair, features_path, error) - error is None on success", "source": "core\\ml\\parallel_trainer.py", "category": "general"}
{"instruction": "Explain the Generate Features For Pair function", "input": "", "output": "Function: generate_features_for_pair\n\nCPU worker: Generate mega features for one pair.\n\nThis function runs in a separate process to parallelize CPU-bound feature generation.\n\nArgs:\n    args: Tuple of (pair, training_dir, output_dir, max_samples)\n\nReturns:\n    Tuple of (pair, features_path, error) - error is None on success", "source": "core\\ml\\parallel_trainer.py", "category": "general"}
{"instruction": "What is the ParallelTrainer class and how do I use it?", "input": "", "output": "The ParallelTrainer class:\n\nPipeline parallel trainer for maximum GPU + CPU utilization.\n\nArchitecture:\n    CPU: 4 workers generate features in parallel\n    GPU: 3 workers train models concurrently\n\nMemory budget:\n    - Per pair GPU: ~5GB (XGB + LGB + CB)\n    - Total GPU: 15GB / 16GB VRAM", "source": "core\\ml\\parallel_trainer.py", "category": "general"}
{"instruction": "What is the formula for Train All?", "input": "", "output": "Train all pairs with pipeline parallelism.\n\nArgs:\n    pairs: List of pairs to train (None = all with data)\n    skip_trained: Skip pairs that already have results\n    monitor: Print progress updates\n    dry_run: Only print what would be done, don't train\n\nReturns:\n    Dict mapping pair -> results", "source": "core\\ml\\parallel_trainer.py", "category": "general"}
{"instruction": "Explain the Train All function", "input": "", "output": "Function: train_all\n\nTrain all pairs with pipeline parallelism.\n\nArgs:\n    pairs: List of pairs to train (None = all with data)\n    skip_trained: Skip pairs that already have results\n    monitor: Print progress updates\n    dry_run: Only print what would be done, don't train\n\nReturns:\n    Dict mapping pair -> results", "source": "core\\ml\\parallel_trainer.py", "category": "general"}
{"instruction": "Explain the Clear Feature Cache function", "input": "", "output": "Function: clear_feature_cache\n\nClear the feature cache to free disk space.", "source": "core\\ml\\parallel_trainer.py", "category": "general"}
{"instruction": "Explain the purpose of Hybrid Retrainer - Historical + Live Data Combined", "input": "", "output": "Hybrid Retrainer - Historical + Live Data Combined\n===================================================\nUses massive historical data as foundation, adds live data for adaptation.\nTarget: 65-70%+ accuracy (up from 53-62%)", "source": "core\\ml\\retrainer.py", "category": "general"}
{"instruction": "What is the HybridRetrainer class and how do I use it?", "input": "", "output": "The HybridRetrainer class:\n\nCombines historical data (200k+ samples) with live data for maximum accuracy.\n\nStrategy:\n1. Load historical data as foundation (high volume, diverse conditions)\n2. Append live data with higher weight (recent market behavior)\n3. Train on GPU with full RTX 5080 power\n4. Hot-swap if accuracy improves", "source": "core\\ml\\retrainer.py", "category": "volatility"}
{"instruction": "Explain the Get Hybrid Retrainer function", "input": "", "output": "Function: get_hybrid_retrainer\n\nGet or create hybrid retrainer.\n\nArgs:\n    symbols: Specific symbols to train (optional)\n    tier: Symbol tier from registry (majors, crosses, exotics, all)\n\nReturns:\n    HybridRetrainer instance", "source": "core\\ml\\retrainer.py", "category": "general"}
{"instruction": "Explain the Start function", "input": "", "output": "Function: start\n\nStart background hybrid retraining.", "source": "core\\ml\\retrainer.py", "category": "general"}
{"instruction": "Explain the Stop function", "input": "", "output": "Function: stop\n\nStop hybrid retraining.", "source": "core\\ml\\retrainer.py", "category": "general"}
{"instruction": "Explain the purpose of Stacking Ensemble - 6-Model Stacking with Meta-Learner", "input": "", "output": "Stacking Ensemble - 6-Model Stacking with Meta-Learner\n=======================================================\nWorld-class ensemble using:\n- Level 1 Base Learners:\n  - XGBoost (GPU)\n  - LightGBM (GPU)\n  - CatBoost (GPU)\n  - TabNet (Attention-based)\n  - 1D-CNN (Convolutional)\n  - MLP (Dense)\n\n- Level 2 Meta-Learner:\n  - XGBoost on stacked predictions + top features\n\nTarget: 72%+ accuracy, 0.80+ AUC", "source": "core\\ml\\stacking_ensemble.py", "category": "volatility"}
{"instruction": "What is the StackingConfig class and how do I use it?", "input": "", "output": "The StackingConfig class:\n\nConfiguration for stacking ensemble.", "source": "core\\ml\\stacking_ensemble.py", "category": "ensemble"}
{"instruction": "What is the StackingEnsemble class and how do I use it?", "input": "", "output": "The StackingEnsemble class:\n\n6-Model Stacking Ensemble with Meta-Learner.\n\nArchitecture:\n    Level 1 - Base Learners (trained on original features):\n        1. XGBoost (GPU) - Gradient boosting\n        2. LightGBM (GPU) - Gradient boosting (faster)\n        3. CatBoost (GPU) - Gradient boosting (categorical)\n        4. TabNet - Attention-based neural network\n        5. 1D-CNN - Temporal patterns\n        6. MLP - Dense neural network\n\n    Level 2 - Meta-Learner:\n        XGBoost trained on:\n        - 6 stacked base learner predictions\n        - Top 50 original features\n\nUsage:\n    ensemble = StackingEnsemble()\n    ensemble.fit(X_train, y_train, X_val, y_val, feature_names)\n    predictions = ensemble.predict(X_test)\n    proba = ensemble.predict_proba(X_test)", "source": "core\\ml\\stacking_ensemble.py", "category": "ensemble"}
{"instruction": "Show me a code example for StackingEnsemble", "input": "", "output": "ensemble = StackingEnsemble()\n    ensemble.fit(X_train, y_train, X_val, y_val, feature_names)\n    predictions = ensemble.predict(X_test)\n    proba = ensemble.predict_proba(X_test)", "source": "core\\ml\\stacking_ensemble.py", "category": "ensemble"}
{"instruction": "What is the formula for Create Stacking Ensemble?", "input": "", "output": "Factory function to create stacking ensemble.\n\nArgs:\n    config: Stacking config (uses defaults if None)\n    use_gpu: Whether to use GPU acceleration\n    enable_tabnet: Whether to include TabNet\n    enable_neural: Whether to include CNN/MLP\n\nReturns:\n    StackingEnsemble instance", "source": "core\\ml\\stacking_ensemble.py", "category": "alpha"}
{"instruction": "Explain the Create Stacking Ensemble function", "input": "", "output": "Function: create_stacking_ensemble\n\nFactory function to create stacking ensemble.\n\nArgs:\n    config: Stacking config (uses defaults if None)\n    use_gpu: Whether to use GPU acceleration\n    enable_tabnet: Whether to include TabNet\n    enable_neural: Whether to include CNN/MLP\n\nReturns:\n    StackingEnsemble instance", "source": "core\\ml\\stacking_ensemble.py", "category": "alpha"}
{"instruction": "Explain the Fit function", "input": "", "output": "Function: fit\n\nFit the stacking ensemble.\n\nArgs:\n    X_train: Training features\n    y_train: Training labels\n    X_val: Validation features\n    y_val: Validation labels\n    feature_names: Optional feature names\n\nReturns:\n    self", "source": "core\\ml\\stacking_ensemble.py", "category": "ensemble"}
{"instruction": "Explain the Predict Proba function", "input": "", "output": "Function: predict_proba\n\nPredict class probabilities.\n\nArgs:\n    X: Features\n\nReturns:\n    Probability of positive class", "source": "core\\ml\\stacking_ensemble.py", "category": "general"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nPredict class labels.\n\nArgs:\n    X: Features\n    threshold: Classification threshold\n\nReturns:\n    Predicted class labels (0 or 1)", "source": "core\\ml\\stacking_ensemble.py", "category": "general"}
{"instruction": "Explain the Get Base Learner Predictions function", "input": "", "output": "Function: get_base_learner_predictions\n\nGet predictions from each base learner.", "source": "core\\ml\\stacking_ensemble.py", "category": "general"}
{"instruction": "Explain the Save function", "input": "", "output": "Function: save\n\nSave ensemble to disk.", "source": "core\\ml\\stacking_ensemble.py", "category": "ensemble"}
{"instruction": "Explain the Load function", "input": "", "output": "Function: load\n\nLoad ensemble from disk.", "source": "core\\ml\\stacking_ensemble.py", "category": "ensemble"}
{"instruction": "Explain the purpose of Trading Bot", "input": "", "output": "Trading Bot\n===========\nSlim orchestrator for multi-symbol forex trading.\nDelegates to specialized modules for signal, risk, execution.", "source": "core\\trading\\bot.py", "category": "alpha"}
{"instruction": "What is the TradingBot class and how do I use it?", "input": "", "output": "The TradingBot class:\n\nMulti-symbol trading bot orchestrator.\n\nSlim design (~120 lines) - delegates to specialized modules:\n- SymbolRegistry: Symbol configuration\n- SignalGenerator: ML predictions\n- PortfolioRiskManager: Risk checks\n- OrderExecutor: Order submission\n- PositionManager: Position tracking", "source": "core\\trading\\bot.py", "category": "alpha"}
{"instruction": "Explain the Process Tick function", "input": "", "output": "Function: process_tick\n\nProcess a market tick.\n\nArgs:\n    symbol: Trading symbol\n    bid: Bid price\n    ask: Ask price\n    volume: Tick volume\n    timestamp: Tick timestamp", "source": "core\\trading\\bot.py", "category": "volatility"}
{"instruction": "Explain the Stop function", "input": "", "output": "Function: stop\n\nStop the trading bot.", "source": "core\\trading\\bot.py", "category": "general"}
{"instruction": "Explain the Status function", "input": "", "output": "Function: status\n\nGet bot status.", "source": "core\\trading\\bot.py", "category": "general"}
{"instruction": "Explain the purpose of Multi-Broker Abstraction Layer", "input": "", "output": "Multi-Broker Abstraction Layer\n==============================\nProfessional-grade broker interface for institutional forex trading.\n\nSupports:\n- Interactive Brokers (IB Gateway)\n- OANDA v20 API\n- Forex.com (GAIN Capital REST API)\n- tastyfx (IG Group REST API)\n- IG Markets (REST API)\n\nArchitecture:\n    BrokerBase (ABC)\n    ├── IBBroker\n    ├── OANDABroker\n    ├── ForexComBroker\n    ├── TastyFXBroker\n    └── IGBroker\n\n    BrokerRouter → Routes orders to optimal broker", "source": "core\\trading\\broker_base.py", "category": "rl"}
{"instruction": "What is the BrokerType class and how do I use it?", "input": "", "output": "The BrokerType class:\n\nSupported broker types.", "source": "core\\trading\\broker_base.py", "category": "rl"}
{"instruction": "What is the OrderSide class and how do I use it?", "input": "", "output": "The OrderSide class:\n\nOrder side.", "source": "core\\trading\\broker_base.py", "category": "general"}
{"instruction": "What is the OrderType class and how do I use it?", "input": "", "output": "The OrderType class:\n\nOrder type.", "source": "core\\trading\\broker_base.py", "category": "general"}
{"instruction": "What is the OrderStatus class and how do I use it?", "input": "", "output": "The OrderStatus class:\n\nOrder status.", "source": "core\\trading\\broker_base.py", "category": "general"}
{"instruction": "What is the PositionSide class and how do I use it?", "input": "", "output": "The PositionSide class:\n\nPosition side.", "source": "core\\trading\\broker_base.py", "category": "general"}
{"instruction": "What is the BrokerConfig class and how do I use it?", "input": "", "output": "The BrokerConfig class:\n\nBroker configuration.", "source": "core\\trading\\broker_base.py", "category": "general"}
{"instruction": "What is the BrokerOrder class and how do I use it?", "input": "", "output": "The BrokerOrder class:\n\nUnified order representation across all brokers.", "source": "core\\trading\\broker_base.py", "category": "general"}
{"instruction": "What is the BrokerPosition class and how do I use it?", "input": "", "output": "The BrokerPosition class:\n\nUnified position representation.", "source": "core\\trading\\broker_base.py", "category": "general"}
{"instruction": "What is the BrokerAccount class and how do I use it?", "input": "", "output": "The BrokerAccount class:\n\nUnified account information.", "source": "core\\trading\\broker_base.py", "category": "general"}
{"instruction": "What is the BrokerQuote class and how do I use it?", "input": "", "output": "The BrokerQuote class:\n\nUnified quote/tick representation.", "source": "core\\trading\\broker_base.py", "category": "microstructure"}
{"instruction": "What is the BrokerBase class and how do I use it?", "input": "", "output": "The BrokerBase class:\n\nAbstract base class for all broker implementations.\n\nAll broker adapters must implement this interface.", "source": "core\\trading\\broker_base.py", "category": "general"}
{"instruction": "Explain the Is Complete function", "input": "", "output": "Function: is_complete\n\nCheck if order is in terminal state.", "source": "core\\trading\\broker_base.py", "category": "regime"}
{"instruction": "Explain the Is Active function", "input": "", "output": "Function: is_active\n\nCheck if order is active.", "source": "core\\trading\\broker_base.py", "category": "general"}
{"instruction": "Explain the Is Valid function", "input": "", "output": "Function: is_valid\n\nCheck if quote is valid.", "source": "core\\trading\\broker_base.py", "category": "general"}
{"instruction": "Explain the Connect function", "input": "", "output": "Function: connect\n\nConnect to broker.\n\nReturns:\n    True if connected successfully", "source": "core\\trading\\broker_base.py", "category": "general"}
{"instruction": "Explain the Disconnect function", "input": "", "output": "Function: disconnect\n\nDisconnect from broker.", "source": "core\\trading\\broker_base.py", "category": "general"}
{"instruction": "Explain the Is Connected function", "input": "", "output": "Function: is_connected\n\nCheck if connected to broker.", "source": "core\\trading\\broker_base.py", "category": "general"}
{"instruction": "Explain the Ping function", "input": "", "output": "Function: ping\n\nPing broker to check connection health.\n\nReturns:\n    True if connection is healthy", "source": "core\\trading\\broker_base.py", "category": "general"}
{"instruction": "Explain the Get Account function", "input": "", "output": "Function: get_account\n\nGet account information.\n\nReturns:\n    Account information", "source": "core\\trading\\broker_base.py", "category": "general"}
{"instruction": "Explain the Get Balance function", "input": "", "output": "Function: get_balance\n\nGet account balance.\n\nReturns:\n    Account balance", "source": "core\\trading\\broker_base.py", "category": "general"}
{"instruction": "What is the formula for Submit Order?", "input": "", "output": "Submit an order.\n\nArgs:\n    symbol: Trading symbol\n    side: Buy or sell\n    quantity: Order quantity\n    order_type: Order type\n    limit_price: Limit price for limit orders\n    stop_price: Stop price for stop orders\n    **kwargs: Additional broker-specific parameters\n\nReturns:\n    Order object", "source": "core\\trading\\broker_base.py", "category": "general"}
{"instruction": "Explain the Submit Order function", "input": "", "output": "Function: submit_order\n\nSubmit an order.\n\nArgs:\n    symbol: Trading symbol\n    side: Buy or sell\n    quantity: Order quantity\n    order_type: Order type\n    limit_price: Limit price for limit orders\n    stop_price: Stop price for stop orders\n    **kwargs: Additional broker-specific parameters\n\nReturns:\n    Order object", "source": "core\\trading\\broker_base.py", "category": "general"}
{"instruction": "Explain the Cancel Order function", "input": "", "output": "Function: cancel_order\n\nCancel an order.\n\nArgs:\n    order_id: Order ID to cancel\n\nReturns:\n    True if cancellation was successful", "source": "core\\trading\\broker_base.py", "category": "general"}
{"instruction": "Explain the Get Order function", "input": "", "output": "Function: get_order\n\nGet order by ID.\n\nArgs:\n    order_id: Order ID\n\nReturns:\n    Order object or None", "source": "core\\trading\\broker_base.py", "category": "general"}
{"instruction": "Explain the Get Open Orders function", "input": "", "output": "Function: get_open_orders\n\nGet all open orders.\n\nArgs:\n    symbol: Optional symbol filter\n\nReturns:\n    List of open orders", "source": "core\\trading\\broker_base.py", "category": "general"}
{"instruction": "Explain the Get Positions function", "input": "", "output": "Function: get_positions\n\nGet all positions.\n\nArgs:\n    symbol: Optional symbol filter\n\nReturns:\n    List of positions", "source": "core\\trading\\broker_base.py", "category": "general"}
{"instruction": "What is the formula for Close Position?", "input": "", "output": "Close a position.\n\nArgs:\n    symbol: Symbol to close\n    quantity: Quantity to close (None = close all)\n\nReturns:\n    Order object for the closing trade", "source": "core\\trading\\broker_base.py", "category": "general"}
{"instruction": "Explain the Close Position function", "input": "", "output": "Function: close_position\n\nClose a position.\n\nArgs:\n    symbol: Symbol to close\n    quantity: Quantity to close (None = close all)\n\nReturns:\n    Order object for the closing trade", "source": "core\\trading\\broker_base.py", "category": "general"}
{"instruction": "Explain the Get Quote function", "input": "", "output": "Function: get_quote\n\nGet current quote for symbol.\n\nArgs:\n    symbol: Trading symbol\n\nReturns:\n    Quote object", "source": "core\\trading\\broker_base.py", "category": "general"}
{"instruction": "Explain the Get Spread function", "input": "", "output": "Function: get_spread\n\nGet current spread in pips.\n\nArgs:\n    symbol: Trading symbol\n\nReturns:\n    Spread in pips", "source": "core\\trading\\broker_base.py", "category": "microstructure"}
{"instruction": "Explain the Get Symbols function", "input": "", "output": "Function: get_symbols\n\nGet list of tradeable symbols.\n\nReturns:\n    List of symbol names", "source": "core\\trading\\broker_base.py", "category": "general"}
{"instruction": "Explain the Get Pip Value function", "input": "", "output": "Function: get_pip_value\n\nGet pip value for symbol.\n\nArgs:\n    symbol: Trading symbol\n\nReturns:\n    Pip value", "source": "core\\trading\\broker_base.py", "category": "general"}
{"instruction": "Explain the Get Min Quantity function", "input": "", "output": "Function: get_min_quantity\n\nGet minimum order quantity for symbol.\n\nArgs:\n    symbol: Trading symbol\n\nReturns:\n    Minimum quantity", "source": "core\\trading\\broker_base.py", "category": "general"}
{"instruction": "What is the formula for Register Callback?", "input": "", "output": "Register callback for events.\n\nEvents:\n    - order_update\n    - position_update\n    - quote_update\n    - connection_status", "source": "core\\trading\\broker_base.py", "category": "general"}
{"instruction": "Explain the Register Callback function", "input": "", "output": "Function: register_callback\n\nRegister callback for events.\n\nEvents:\n    - order_update\n    - position_update\n    - quote_update\n    - connection_status", "source": "core\\trading\\broker_base.py", "category": "general"}
{"instruction": "Explain the Get Stats function", "input": "", "output": "Function: get_stats\n\nGet broker statistics.", "source": "core\\trading\\broker_base.py", "category": "general"}
{"instruction": "Explain the purpose of Forex.com (GAIN Capital) Adapter", "input": "", "output": "Forex.com (GAIN Capital) Adapter\n================================\nProfessional Forex.com integration via REST API.\n\nForex.com uses GAIN Capital's FOREX.com REST Trading API.\nAPI Docs: https://developer.forex.com/\n\nFeatures:\n- Market and limit orders\n- Position management\n- Real-time quotes\n- Account monitoring", "source": "core\\trading\\broker_forex_com.py", "category": "general"}
{"instruction": "What is the ForexComBroker class and how do I use it?", "input": "", "output": "The ForexComBroker class:\n\nForex.com (GAIN Capital) API adapter.\n\nUses REST API with OAuth2 authentication.", "source": "core\\trading\\broker_forex_com.py", "category": "general"}
{"instruction": "Explain the Create Forex Com Broker function", "input": "", "output": "Function: create_forex_com_broker\n\nFactory function to create Forex.com broker.\n\nArgs:\n    username: Forex.com username\n    password: Forex.com password\n    app_key: API app key\n    paper: Whether demo account\n\nReturns:\n    Configured ForexComBroker instance", "source": "core\\trading\\broker_forex_com.py", "category": "alpha"}
{"instruction": "Explain the Connect function", "input": "", "output": "Function: connect\n\nConnect to Forex.com API.", "source": "core\\trading\\broker_forex_com.py", "category": "general"}
{"instruction": "Explain the Disconnect function", "input": "", "output": "Function: disconnect\n\nDisconnect from Forex.com.", "source": "core\\trading\\broker_forex_com.py", "category": "general"}
{"instruction": "Explain the Is Connected function", "input": "", "output": "Function: is_connected\n\nCheck connection status.", "source": "core\\trading\\broker_forex_com.py", "category": "general"}
{"instruction": "Explain the Ping function", "input": "", "output": "Function: ping\n\nPing Forex.com API.", "source": "core\\trading\\broker_forex_com.py", "category": "general"}
{"instruction": "Explain the Get Account function", "input": "", "output": "Function: get_account\n\nGet account info.", "source": "core\\trading\\broker_forex_com.py", "category": "general"}
{"instruction": "Explain the Get Balance function", "input": "", "output": "Function: get_balance\n\nGet account balance.", "source": "core\\trading\\broker_forex_com.py", "category": "general"}
{"instruction": "Explain the Submit Order function", "input": "", "output": "Function: submit_order\n\nSubmit order to Forex.com.", "source": "core\\trading\\broker_forex_com.py", "category": "general"}
{"instruction": "Explain the Cancel Order function", "input": "", "output": "Function: cancel_order\n\nCancel a Forex.com order.", "source": "core\\trading\\broker_forex_com.py", "category": "general"}
{"instruction": "Explain the Get Order function", "input": "", "output": "Function: get_order\n\nGet order by ID.", "source": "core\\trading\\broker_forex_com.py", "category": "general"}
{"instruction": "Explain the Get Open Orders function", "input": "", "output": "Function: get_open_orders\n\nGet open orders.", "source": "core\\trading\\broker_forex_com.py", "category": "general"}
{"instruction": "Explain the Get Positions function", "input": "", "output": "Function: get_positions\n\nGet all positions.", "source": "core\\trading\\broker_forex_com.py", "category": "general"}
{"instruction": "Explain the Close Position function", "input": "", "output": "Function: close_position\n\nClose a position.", "source": "core\\trading\\broker_forex_com.py", "category": "general"}
{"instruction": "Explain the Get Quote function", "input": "", "output": "Function: get_quote\n\nGet current quote.", "source": "core\\trading\\broker_forex_com.py", "category": "general"}
{"instruction": "Explain the Get Spread function", "input": "", "output": "Function: get_spread\n\nGet current spread in pips.", "source": "core\\trading\\broker_forex_com.py", "category": "microstructure"}
{"instruction": "Explain the Get Symbols function", "input": "", "output": "Function: get_symbols\n\nGet tradeable symbols.", "source": "core\\trading\\broker_forex_com.py", "category": "general"}
{"instruction": "Explain the Get Pip Value function", "input": "", "output": "Function: get_pip_value\n\nGet pip value for symbol.", "source": "core\\trading\\broker_forex_com.py", "category": "general"}
{"instruction": "Explain the Get Min Quantity function", "input": "", "output": "Function: get_min_quantity\n\nGet minimum order quantity.", "source": "core\\trading\\broker_forex_com.py", "category": "general"}
{"instruction": "Explain the purpose of Interactive Brokers Adapter", "input": "", "output": "Interactive Brokers Adapter\n===========================\nProfessional IB Gateway integration via ib_insync.\n\nConnection:\n- IB Gateway Docker: localhost:4004 (paper)\n- Account: DUO423364\n\nFeatures:\n- Market and limit orders\n- Position tracking\n- Real-time quotes\n- Account monitoring", "source": "core\\trading\\broker_ib.py", "category": "general"}
{"instruction": "What is the IBBroker class and how do I use it?", "input": "", "output": "The IBBroker class:\n\nInteractive Brokers adapter using ib_insync.\n\nConnects to IB Gateway (Docker) for forex trading.", "source": "core\\trading\\broker_ib.py", "category": "general"}
{"instruction": "Explain the Create Ib Broker function", "input": "", "output": "Function: create_ib_broker\n\nFactory function to create IB broker.\n\nArgs:\n    host: IB Gateway host\n    port: IB Gateway port (4004 for paper)\n    account_id: IB account ID\n    client_id: Client ID for connection\n    paper: Whether paper trading\n\nReturns:\n    Configured IBBroker instance", "source": "core\\trading\\broker_ib.py", "category": "alpha"}
{"instruction": "Explain the Connect function", "input": "", "output": "Function: connect\n\nConnect to IB Gateway.", "source": "core\\trading\\broker_ib.py", "category": "general"}
{"instruction": "Explain the Disconnect function", "input": "", "output": "Function: disconnect\n\nDisconnect from IB Gateway.", "source": "core\\trading\\broker_ib.py", "category": "general"}
{"instruction": "Explain the Is Connected function", "input": "", "output": "Function: is_connected\n\nCheck if connected.", "source": "core\\trading\\broker_ib.py", "category": "general"}
{"instruction": "Explain the Ping function", "input": "", "output": "Function: ping\n\nPing IB Gateway.", "source": "core\\trading\\broker_ib.py", "category": "general"}
{"instruction": "Explain the Get Account function", "input": "", "output": "Function: get_account\n\nGet IB account information.", "source": "core\\trading\\broker_ib.py", "category": "general"}
{"instruction": "Explain the Get Balance function", "input": "", "output": "Function: get_balance\n\nGet account balance.", "source": "core\\trading\\broker_ib.py", "category": "general"}
{"instruction": "Explain the Submit Order function", "input": "", "output": "Function: submit_order\n\nSubmit order to IB Gateway.", "source": "core\\trading\\broker_ib.py", "category": "general"}
{"instruction": "Explain the Cancel Order function", "input": "", "output": "Function: cancel_order\n\nCancel an IB order.", "source": "core\\trading\\broker_ib.py", "category": "general"}
{"instruction": "Explain the Get Order function", "input": "", "output": "Function: get_order\n\nGet order by ID.", "source": "core\\trading\\broker_ib.py", "category": "general"}
{"instruction": "Explain the Get Open Orders function", "input": "", "output": "Function: get_open_orders\n\nGet open orders.", "source": "core\\trading\\broker_ib.py", "category": "general"}
{"instruction": "Explain the Get Positions function", "input": "", "output": "Function: get_positions\n\nGet all positions.", "source": "core\\trading\\broker_ib.py", "category": "general"}
{"instruction": "Explain the Close Position function", "input": "", "output": "Function: close_position\n\nClose a position.", "source": "core\\trading\\broker_ib.py", "category": "general"}
{"instruction": "Explain the Get Quote function", "input": "", "output": "Function: get_quote\n\nGet current quote.", "source": "core\\trading\\broker_ib.py", "category": "general"}
{"instruction": "Explain the Get Spread function", "input": "", "output": "Function: get_spread\n\nGet current spread in pips.", "source": "core\\trading\\broker_ib.py", "category": "microstructure"}
{"instruction": "Explain the Get Symbols function", "input": "", "output": "Function: get_symbols\n\nGet tradeable forex symbols.", "source": "core\\trading\\broker_ib.py", "category": "general"}
{"instruction": "Explain the Get Pip Value function", "input": "", "output": "Function: get_pip_value\n\nGet pip value for symbol.", "source": "core\\trading\\broker_ib.py", "category": "general"}
{"instruction": "Explain the Get Min Quantity function", "input": "", "output": "Function: get_min_quantity\n\nGet minimum order quantity (lot size).", "source": "core\\trading\\broker_ib.py", "category": "general"}
{"instruction": "Explain the purpose of OANDA v20 API Adapter", "input": "", "output": "OANDA v20 API Adapter\n=====================\nProfessional OANDA integration via v20 REST API.\n\nFeatures:\n- Market and limit orders\n- Position management\n- Real-time streaming quotes\n- Account monitoring\n- Supports practice and live accounts\n\nAPI Docs: https://developer.oanda.com/rest-live-v20/introduction/", "source": "core\\trading\\broker_oanda.py", "category": "rl"}
{"instruction": "What is the OANDABroker class and how do I use it?", "input": "", "output": "The OANDABroker class:\n\nOANDA v20 API adapter.\n\nUses REST API for trading operations.", "source": "core\\trading\\broker_oanda.py", "category": "general"}
{"instruction": "Explain the Create Oanda Broker function", "input": "", "output": "Function: create_oanda_broker\n\nFactory function to create OANDA broker.\n\nArgs:\n    api_key: OANDA API key\n    account_id: OANDA account ID\n    paper: Whether practice account\n\nReturns:\n    Configured OANDABroker instance", "source": "core\\trading\\broker_oanda.py", "category": "alpha"}
{"instruction": "Explain the Connect function", "input": "", "output": "Function: connect\n\nConnect to OANDA API.", "source": "core\\trading\\broker_oanda.py", "category": "general"}
{"instruction": "Explain the Disconnect function", "input": "", "output": "Function: disconnect\n\nDisconnect from OANDA.", "source": "core\\trading\\broker_oanda.py", "category": "general"}
{"instruction": "Explain the Is Connected function", "input": "", "output": "Function: is_connected\n\nCheck connection status.", "source": "core\\trading\\broker_oanda.py", "category": "general"}
{"instruction": "Explain the Ping function", "input": "", "output": "Function: ping\n\nPing OANDA API.", "source": "core\\trading\\broker_oanda.py", "category": "general"}
{"instruction": "Explain the Get Account function", "input": "", "output": "Function: get_account\n\nGet OANDA account info.", "source": "core\\trading\\broker_oanda.py", "category": "general"}
{"instruction": "Explain the Get Balance function", "input": "", "output": "Function: get_balance\n\nGet account balance.", "source": "core\\trading\\broker_oanda.py", "category": "general"}
{"instruction": "Explain the Submit Order function", "input": "", "output": "Function: submit_order\n\nSubmit order to OANDA.", "source": "core\\trading\\broker_oanda.py", "category": "general"}
{"instruction": "Explain the Cancel Order function", "input": "", "output": "Function: cancel_order\n\nCancel an OANDA order.", "source": "core\\trading\\broker_oanda.py", "category": "general"}
{"instruction": "Explain the Get Order function", "input": "", "output": "Function: get_order\n\nGet order by ID.", "source": "core\\trading\\broker_oanda.py", "category": "general"}
{"instruction": "Explain the Get Open Orders function", "input": "", "output": "Function: get_open_orders\n\nGet open orders.", "source": "core\\trading\\broker_oanda.py", "category": "general"}
{"instruction": "Explain the Get Positions function", "input": "", "output": "Function: get_positions\n\nGet all positions.", "source": "core\\trading\\broker_oanda.py", "category": "general"}
{"instruction": "Explain the Close Position function", "input": "", "output": "Function: close_position\n\nClose a position.", "source": "core\\trading\\broker_oanda.py", "category": "general"}
{"instruction": "Explain the Get Quote function", "input": "", "output": "Function: get_quote\n\nGet current quote.", "source": "core\\trading\\broker_oanda.py", "category": "general"}
{"instruction": "Explain the Get Spread function", "input": "", "output": "Function: get_spread\n\nGet current spread in pips.", "source": "core\\trading\\broker_oanda.py", "category": "microstructure"}
{"instruction": "Explain the Get Symbols function", "input": "", "output": "Function: get_symbols\n\nGet tradeable symbols.", "source": "core\\trading\\broker_oanda.py", "category": "general"}
{"instruction": "Explain the Get Pip Value function", "input": "", "output": "Function: get_pip_value\n\nGet pip value for symbol.", "source": "core\\trading\\broker_oanda.py", "category": "general"}
{"instruction": "Explain the Get Min Quantity function", "input": "", "output": "Function: get_min_quantity\n\nGet minimum order quantity (OANDA allows 1 unit).", "source": "core\\trading\\broker_oanda.py", "category": "general"}
{"instruction": "Explain the purpose of Multi-Broker Router", "input": "", "output": "Multi-Broker Router\n===================\nIntelligent order routing across multiple forex brokers.\n\nFeatures:\n- Best execution routing (lowest spread)\n- Load balancing across brokers\n- Failover handling\n- Position aggregation\n- Real-time spread comparison\n\nSupported Brokers:\n1. Interactive Brokers (IB Gateway)\n2. OANDA v20 API\n3. Forex.com (GAIN Capital)\n4. tastyfx (IG Group)\n5. IG Markets\n\nRouting Strategies:\n- BEST_SPREAD: Route to broker with lowest spread\n- PRIORITY: Route based on broker priority\n- ROUND_ROBIN: Distribute orders evenly\n- FAILOVER: Primary broker with fallback\n- SPLIT: Split large orders across brokers", "source": "core\\trading\\broker_router.py", "category": "execution"}
{"instruction": "What is the RoutingStrategy class and how do I use it?", "input": "", "output": "The RoutingStrategy class:\n\nOrder routing strategy.", "source": "core\\trading\\broker_router.py", "category": "general"}
{"instruction": "What is the BrokerStatus class and how do I use it?", "input": "", "output": "The BrokerStatus class:\n\nBroker connection status.", "source": "core\\trading\\broker_router.py", "category": "general"}
{"instruction": "What is the RoutingDecision class and how do I use it?", "input": "", "output": "The RoutingDecision class:\n\nRouting decision for an order.", "source": "core\\trading\\broker_router.py", "category": "general"}
{"instruction": "What is the BrokerRouter class and how do I use it?", "input": "", "output": "The BrokerRouter class:\n\nMulti-broker order router.\n\nRoutes orders to optimal broker based on strategy.", "source": "core\\trading\\broker_router.py", "category": "general"}
{"instruction": "What is the formula for Create Multi Broker Router?", "input": "", "output": "Factory function to create configured multi-broker router.\n\nArgs:\n    brokers_config: Dict of broker configs keyed by broker name\n    strategy: Default routing strategy\n\nReturns:\n    Configured BrokerRouter\n\nExample:\n    config = {\n        'ib': {\n            'host': 'localhost',\n            'port': 4004,\n            'account_id': 'DUO423364',\n            'client_id': 1,\n        },\n        'oanda': {\n            'api_key': 'xxx',\n            'account_id': '101-001-xxx',\n        },\n        'forex_com': {\n            'username': 'xxx',\n            'password': 'xxx',\n            'app_key': 'xxx',\n        },\n        'tastyfx': {\n            'api_key': 'xxx',\n            'username': 'xxx',\n            'password': 'xxx',\n        }\n    }\n    router = create_multi_broker_router(config)", "source": "core\\trading\\broker_router.py", "category": "alpha"}
{"instruction": "Explain the Create Multi Broker Router function", "input": "", "output": "Function: create_multi_broker_router\n\nFactory function to create configured multi-broker router.\n\nArgs:\n    brokers_config: Dict of broker configs keyed by broker name\n    strategy: Default routing strategy\n\nReturns:\n    Configured BrokerRouter\n\nExample:\n    config = {\n        'ib': {\n            'host': 'localhost',\n            'port': 4004,\n            'account_id': 'DUO423364',\n            'client_id': 1,\n        },\n        'oanda': {\n            'api_key': 'xxx',\n            'account_id': '101-001-xxx',\n        },\n        'forex_com': {\n            'username': 'xxx',\n            'password': 'xxx',\n            'app_key': 'xxx',\n        },\n        'tastyfx': {\n            'api_key': 'xxx',\n            'username': 'xxx',\n            'password': 'xxx',\n        }\n    }\n    router = create_multi_broker_router(config)", "source": "core\\trading\\broker_router.py", "category": "alpha"}
{"instruction": "Explain the Add Broker function", "input": "", "output": "Function: add_broker\n\nAdd a broker to the router.", "source": "core\\trading\\broker_router.py", "category": "general"}
{"instruction": "Explain the Remove Broker function", "input": "", "output": "Function: remove_broker\n\nRemove a broker from the router.", "source": "core\\trading\\broker_router.py", "category": "general"}
{"instruction": "Explain the Get Broker function", "input": "", "output": "Function: get_broker\n\nGet broker by type.", "source": "core\\trading\\broker_router.py", "category": "general"}
{"instruction": "Explain the Get Brokers function", "input": "", "output": "Function: get_brokers\n\nGet all brokers.", "source": "core\\trading\\broker_router.py", "category": "general"}
{"instruction": "Explain the Get Active Brokers function", "input": "", "output": "Function: get_active_brokers\n\nGet connected brokers sorted by priority.", "source": "core\\trading\\broker_router.py", "category": "general"}
{"instruction": "Explain the Connect All function", "input": "", "output": "Function: connect_all\n\nConnect to all brokers.", "source": "core\\trading\\broker_router.py", "category": "general"}
{"instruction": "Explain the Disconnect All function", "input": "", "output": "Function: disconnect_all\n\nDisconnect from all brokers.", "source": "core\\trading\\broker_router.py", "category": "general"}
{"instruction": "Explain the Health Check function", "input": "", "output": "Function: health_check\n\nCheck health of all brokers.", "source": "core\\trading\\broker_router.py", "category": "general"}
{"instruction": "What is the formula for Route Order?", "input": "", "output": "Route order to optimal broker.\n\nArgs:\n    symbol: Trading symbol\n    side: Order side\n    quantity: Order quantity\n    order_type: Order type\n    limit_price: Limit price\n    stop_price: Stop price\n    strategy: Override routing strategy\n    preferred_broker: Force specific broker\n    **kwargs: Additional order parameters\n\nReturns:\n    Executed order", "source": "core\\trading\\broker_router.py", "category": "general"}
{"instruction": "Explain the Route Order function", "input": "", "output": "Function: route_order\n\nRoute order to optimal broker.\n\nArgs:\n    symbol: Trading symbol\n    side: Order side\n    quantity: Order quantity\n    order_type: Order type\n    limit_price: Limit price\n    stop_price: Stop price\n    strategy: Override routing strategy\n    preferred_broker: Force specific broker\n    **kwargs: Additional order parameters\n\nReturns:\n    Executed order", "source": "core\\trading\\broker_router.py", "category": "general"}
{"instruction": "Explain the Get All Positions function", "input": "", "output": "Function: get_all_positions\n\nGet positions from all brokers.", "source": "core\\trading\\broker_router.py", "category": "general"}
{"instruction": "Explain the Get All Quotes function", "input": "", "output": "Function: get_all_quotes\n\nGet quotes from all brokers for comparison.", "source": "core\\trading\\broker_router.py", "category": "general"}
{"instruction": "Explain the Get Best Quote function", "input": "", "output": "Function: get_best_quote\n\nGet best quote (lowest spread) across all brokers.", "source": "core\\trading\\broker_router.py", "category": "microstructure"}
{"instruction": "Explain the Get Aggregate Balance function", "input": "", "output": "Function: get_aggregate_balance\n\nGet aggregate balance across all brokers.", "source": "core\\trading\\broker_router.py", "category": "general"}
{"instruction": "Explain the Get Stats function", "input": "", "output": "Function: get_stats\n\nGet router statistics.", "source": "core\\trading\\broker_router.py", "category": "general"}
{"instruction": "Explain the purpose of tastyfx / IG Markets Adapter", "input": "", "output": "tastyfx / IG Markets Adapter\n============================\nProfessional integration via IG Group REST API.\n\ntastyfx is the US forex brand of IG Group.\nUses same API as IG Markets with US-specific endpoints.\n\nAPI Docs: https://labs.ig.com/rest-trading-api-reference\n\nFeatures:\n- Market and limit orders\n- Position management\n- Real-time streaming\n- Account monitoring", "source": "core\\trading\\broker_tastyfx.py", "category": "general"}
{"instruction": "What is the TastyFXBroker class and how do I use it?", "input": "", "output": "The TastyFXBroker class:\n\ntastyfx (IG Group) API adapter.\n\nUses IG REST API for trading operations.", "source": "core\\trading\\broker_tastyfx.py", "category": "general"}
{"instruction": "What is the IGBroker class and how do I use it?", "input": "", "output": "The IGBroker class:\n\nIG Markets broker (same API as tastyfx).\n\nJust changes the broker type for identification.", "source": "core\\trading\\broker_tastyfx.py", "category": "general"}
{"instruction": "Explain the Create Tastyfx Broker function", "input": "", "output": "Function: create_tastyfx_broker\n\nFactory function to create tastyfx broker.\n\nArgs:\n    api_key: IG API key\n    username: tastyfx username\n    password: tastyfx password\n    paper: Whether demo account\n\nReturns:\n    Configured TastyFXBroker instance", "source": "core\\trading\\broker_tastyfx.py", "category": "alpha"}
{"instruction": "Explain the Create Ig Broker function", "input": "", "output": "Function: create_ig_broker\n\nFactory function to create IG Markets broker.\n\nArgs:\n    api_key: IG API key\n    username: IG username\n    password: IG password\n    paper: Whether demo account\n\nReturns:\n    Configured IGBroker instance", "source": "core\\trading\\broker_tastyfx.py", "category": "alpha"}
{"instruction": "Explain the Connect function", "input": "", "output": "Function: connect\n\nConnect to IG API.", "source": "core\\trading\\broker_tastyfx.py", "category": "general"}
{"instruction": "Explain the Disconnect function", "input": "", "output": "Function: disconnect\n\nDisconnect from IG API.", "source": "core\\trading\\broker_tastyfx.py", "category": "general"}
{"instruction": "Explain the Is Connected function", "input": "", "output": "Function: is_connected\n\nCheck connection status.", "source": "core\\trading\\broker_tastyfx.py", "category": "general"}
{"instruction": "Explain the Ping function", "input": "", "output": "Function: ping\n\nPing IG API.", "source": "core\\trading\\broker_tastyfx.py", "category": "general"}
{"instruction": "Explain the Get Account function", "input": "", "output": "Function: get_account\n\nGet account info.", "source": "core\\trading\\broker_tastyfx.py", "category": "general"}
{"instruction": "Explain the Get Balance function", "input": "", "output": "Function: get_balance\n\nGet account balance.", "source": "core\\trading\\broker_tastyfx.py", "category": "general"}
{"instruction": "Explain the Submit Order function", "input": "", "output": "Function: submit_order\n\nSubmit order to IG.", "source": "core\\trading\\broker_tastyfx.py", "category": "general"}
{"instruction": "Explain the Cancel Order function", "input": "", "output": "Function: cancel_order\n\nCancel an IG order.", "source": "core\\trading\\broker_tastyfx.py", "category": "general"}
{"instruction": "Explain the Get Order function", "input": "", "output": "Function: get_order\n\nGet order by ID.", "source": "core\\trading\\broker_tastyfx.py", "category": "general"}
{"instruction": "Explain the Get Open Orders function", "input": "", "output": "Function: get_open_orders\n\nGet open orders.", "source": "core\\trading\\broker_tastyfx.py", "category": "general"}
{"instruction": "Explain the Get Positions function", "input": "", "output": "Function: get_positions\n\nGet all positions.", "source": "core\\trading\\broker_tastyfx.py", "category": "general"}
{"instruction": "Explain the Close Position function", "input": "", "output": "Function: close_position\n\nClose a position.", "source": "core\\trading\\broker_tastyfx.py", "category": "general"}
{"instruction": "Explain the Get Quote function", "input": "", "output": "Function: get_quote\n\nGet current quote.", "source": "core\\trading\\broker_tastyfx.py", "category": "general"}
{"instruction": "Explain the Get Spread function", "input": "", "output": "Function: get_spread\n\nGet current spread in pips.", "source": "core\\trading\\broker_tastyfx.py", "category": "microstructure"}
{"instruction": "Explain the Get Symbols function", "input": "", "output": "Function: get_symbols\n\nGet tradeable symbols.", "source": "core\\trading\\broker_tastyfx.py", "category": "general"}
{"instruction": "Explain the Get Pip Value function", "input": "", "output": "Function: get_pip_value\n\nGet pip value for symbol.", "source": "core\\trading\\broker_tastyfx.py", "category": "general"}
{"instruction": "Explain the Get Min Quantity function", "input": "", "output": "Function: get_min_quantity\n\nGet minimum order quantity.", "source": "core\\trading\\broker_tastyfx.py", "category": "general"}
{"instruction": "Explain the purpose of Order Executor", "input": "", "output": "Order Executor\n==============\nExecute orders via IB Gateway with queue management.", "source": "core\\trading\\executor.py", "category": "general"}
{"instruction": "What is the OrderStatus class and how do I use it?", "input": "", "output": "The OrderStatus class:\n\nOrder status enum.", "source": "core\\trading\\executor.py", "category": "general"}
{"instruction": "What is the Order class and how do I use it?", "input": "", "output": "The Order class:\n\nRepresents a trading order.", "source": "core\\trading\\executor.py", "category": "general"}
{"instruction": "What is the OrderExecutor class and how do I use it?", "input": "", "output": "The OrderExecutor class:\n\nExecute orders via IB Gateway.\n\nFeatures:\n- Order queue with rate limiting\n- Async submission with callbacks\n- Position tracking integration\n- Error handling and retry logic", "source": "core\\trading\\executor.py", "category": "general"}
{"instruction": "Explain the Connect function", "input": "", "output": "Function: connect\n\nConnect to IB Gateway.", "source": "core\\trading\\executor.py", "category": "general"}
{"instruction": "Explain the Disconnect function", "input": "", "output": "Function: disconnect\n\nDisconnect from IB Gateway.", "source": "core\\trading\\executor.py", "category": "general"}
{"instruction": "What is the formula for Submit?", "input": "", "output": "Submit an order.\n\nArgs:\n    symbol: Trading symbol\n    direction: 1 for buy, -1 for sell\n    quantity: Order quantity\n    order_type: MKT, LMT, or STP\n    limit_price: Limit price (for LMT orders)\n    callback: Function called on order update\n\nReturns:\n    Order object", "source": "core\\trading\\executor.py", "category": "general"}
{"instruction": "Explain the Submit function", "input": "", "output": "Function: submit\n\nSubmit an order.\n\nArgs:\n    symbol: Trading symbol\n    direction: 1 for buy, -1 for sell\n    quantity: Order quantity\n    order_type: MKT, LMT, or STP\n    limit_price: Limit price (for LMT orders)\n    callback: Function called on order update\n\nReturns:\n    Order object", "source": "core\\trading\\executor.py", "category": "general"}
{"instruction": "Explain the Cancel function", "input": "", "output": "Function: cancel\n\nCancel a pending order.", "source": "core\\trading\\executor.py", "category": "general"}
{"instruction": "Explain the Get Order function", "input": "", "output": "Function: get_order\n\nGet order by ID.", "source": "core\\trading\\executor.py", "category": "general"}
{"instruction": "Explain the Get Pending Orders function", "input": "", "output": "Function: get_pending_orders\n\nGet all pending orders.", "source": "core\\trading\\executor.py", "category": "general"}
{"instruction": "Explain the Get Orders By Symbol function", "input": "", "output": "Function: get_orders_by_symbol\n\nGet all orders for a symbol.", "source": "core\\trading\\executor.py", "category": "general"}
{"instruction": "Explain the Is Connected function", "input": "", "output": "Function: is_connected\n\nCheck if connected to IB Gateway.", "source": "core\\trading\\executor.py", "category": "general"}
{"instruction": "Explain the Stats function", "input": "", "output": "Function: stats\n\nGet executor statistics.", "source": "core\\trading\\executor.py", "category": "general"}
{"instruction": "What is the source paper for Hurst index?", "input": "", "output": "The source is: https://www.sciencedirect.com/science/article/pii/S2444569X23001257. ", "source": "core\\trading\\pairs_trading_kalman.py", "category": "alpha"}
{"instruction": "What is the source paper for research paper?", "input": "", "output": "The source is: arXiv:2210.15448. ", "source": "core\\trading\\pairs_trading_kalman.py", "category": "alpha"}
{"instruction": "Explain the purpose of Pairs Trading with Kalman Filter for Forex", "input": "", "output": "Pairs Trading with Kalman Filter for Forex\n===========================================\n\nACADEMIC CITATIONS:\n===================\n\nPrimary Papers:\n    Rad et al. (2023)\n    \"Neural Augmented Kalman Filtering with Bollinger Bands for Pairs Trading\"\n    arXiv:2210.15448\n    https://arxiv.org/abs/2210.15448\n\n    Key Innovation: Kalman Filter for cointegration coefficient estimation\n    with low complexity and latency. Achieves superior\n\n performance over\n    static cointegration methods.\n\n    Gonçalves & Stengos (2021)\n    \"Systematic risk in pairs trading and dynamic parameterization\"\n    Economics Letters, Vol. 202\n    https://www.sciencedirect.com/science/article/abs/pii/S0165176521001191\n\n    Key Innovation: Kalman Filter for intertemporal estimation of\n    cointegration coefficients and ASR thresholds.\n\nRelated Work:\n    - \"A computing platform for pairs-trading via Kalman-HMM\" (2017)\n      Journal of Big Data, Springer\n      https://link.springer.com/article/10.1186/s40537-017-0106-3\n\n    - \"Pairs trading strategy optimization using reinforcement learning\" (2016)\n      Soft Computing, Springer\n      https://link.springer.com/article/10.1007/s00500-016-2298-4\n\nMETHODOLOGY:\n============\n\nCointegration Model:\n    Y_t = β * X_t + ε_t\n\n    where:\n    - Y_t: Price of asset 1 (e.g., EURUSD)\n    - X_t: Price of asset 2 (e.g., GBPUSD)\n    - β: Hedge ratio (cointegration coefficient)\n    - ε_t: Spread (mean-reverting residual)\n\nKalman Filter State Space:\n    State equation:  β_t = β_{t-1} + w_t\n    Observation:     Y_t = β_t * X_t + v_t\n\n    where:\n    - w_t ~ N(0, Q): Process noise\n    - v_t ~ N(0, R): Measurement noise\n\nTrading Signals:\n    Spread: s_t = Y_t - β_t * X_t\n    Z-score: z_t = (s_t - μ) / σ\n\n    Entry long: z_t < -threshold (spread below mean)\n    Entry short: z_t > +threshold (spread above mean)\n    Exit: z_t crosses zero\n\nCOINTEGRATED FOREX PAIRS:\n==========================\n\nHigh Correlation (Good for Pairs Trading):\n    1. EURUSD / GBPUSD  (Euro zone correlation)\n    2. AUDUSD / NZDUSD  (Oceania correlation)\n    3. EURJPY / GBPJPY  (Yen cross correlation)\n    4. USDCAD / USDCHF  (USD majors)\n    5. EURAUD / EURGBP  (EUR crosses)\n\nTesting Process:\n    1. Johansen cointegration test\n    2. Augmented Dickey-Fuller test on spread\n    3. Half-life < 10 days (mean reversion speed)\n\nCHINESE QUANT PERFORMANCE:\n==========================\n\nFrom \"An innovative high-frequency statistical arbitrage in Chinese futures\"\n(Journal of Innovation & Knowledge, 2023):\n    - 81% cumulative returns (in-sample)\n    - 21% returns (out-of-sample) after transaction costs\n    - Max drawdown: <1%\n    - Framework: Cointegration + Kalman + Hurst index\n\nSource: https://www.sciencedirect.com/science/article/pii/S2444569X23001257\n\nUSAGE:\n======\n\n    from core.trading.pairs_trading_kalman import KalmanPairsTrader\n\n    trader = KalmanPairsTrader(\n        symbol1='EURUSD',\n        symbol2='GBPUSD',\n        entry_threshold=2.0,  # Z-score threshold\n        exit_threshold=0.5\n    )\n\n    # Feed price data\n    signal = trader.update(price1=1.0850, price2=1.2650)\n\n    if signal == 1:  # Long spread\n        # Buy EURUSD, Sell GBPUSD\n    elif signal == -1:  # Short spread\n        # Sell EURUSD, Buy GBPUSD\n    elif signal == 0:  # Exit\n        # Close positions", "source": "core\\trading\\pairs_trading_kalman.py", "category": "alpha"}
{"instruction": "What is the KalmanPairsConfig class and how do I use it?", "input": "", "output": "The KalmanPairsConfig class:\n\nConfiguration for Kalman Filter Pairs Trading.\n\nBased on Rad et al. (2023) arXiv:2210.15448.", "source": "core\\trading\\pairs_trading_kalman.py", "category": "time_series"}
{"instruction": "What is the KalmanFilter1D class and how do I use it?", "input": "", "output": "The KalmanFilter1D class:\n\n1D Kalman Filter for hedge ratio estimation.\n\nState: β (hedge ratio)\nObservation: Y = β*X + noise", "source": "core\\trading\\pairs_trading_kalman.py", "category": "regime"}
{"instruction": "What is the KalmanPairsTrader class and how do I use it?", "input": "", "output": "The KalmanPairsTrader class:\n\nPairs trading strategy using Kalman Filter for dynamic hedge ratio.\n\nImplementation based on:\n    Rad et al. (2023) arXiv:2210.15448\n    Gonçalves & Stengos (2021) Economics Letters", "source": "core\\trading\\pairs_trading_kalman.py", "category": "time_series"}
{"instruction": "What is the formula for Create Pairs Trader?", "input": "", "output": "Create Kalman pairs trader for common forex pairs.\n\nArgs:\n    pair_name: One of FOREX_PAIRS keys\n    entry_threshold: Z-score to enter\n    exit_threshold: Z-score to exit\n\nReturns:\n    KalmanPairsTrader instance", "source": "core\\trading\\pairs_trading_kalman.py", "category": "time_series"}
{"instruction": "Explain the Create Pairs Trader function", "input": "", "output": "Function: create_pairs_trader\n\nCreate Kalman pairs trader for common forex pairs.\n\nArgs:\n    pair_name: One of FOREX_PAIRS keys\n    entry_threshold: Z-score to enter\n    exit_threshold: Z-score to exit\n\nReturns:\n    KalmanPairsTrader instance", "source": "core\\trading\\pairs_trading_kalman.py", "category": "time_series"}
{"instruction": "What is Kalman Filter in quantitative trading?", "input": "", "output": "Kalman Filter (state estimation and signal filtering).\n\nImplementation details:\nCreate Kalman pairs trader for common forex pairs.\n\nArgs:\n    pair_name: One of FOREX_PAIRS keys\n    entry_threshold: Z-score to enter\n    exit_threshold: Z-score to exit\n\nReturns:\n    KalmanPairsTrader instance", "source": "core\\trading\\pairs_trading_kalman.py", "category": "time_series"}
{"instruction": "What is the formula for Update?", "input": "", "output": "Kalman filter update step.\n\nObservation model: y = β * x + v\n\nArgs:\n    y: Observed value of asset 1\n    x: Observed value of asset 2\n\nReturns:\n    Updated β estimate", "source": "core\\trading\\pairs_trading_kalman.py", "category": "time_series"}
{"instruction": "Explain the Update function", "input": "", "output": "Function: update\n\nKalman filter update step.\n\nObservation model: y = β * x + v\n\nArgs:\n    y: Observed value of asset 1\n    x: Observed value of asset 2\n\nReturns:\n    Updated β estimate", "source": "core\\trading\\pairs_trading_kalman.py", "category": "time_series"}
{"instruction": "What is Kalman Filter in quantitative trading?", "input": "", "output": "Kalman Filter (state estimation and signal filtering).\n\nImplementation details:\nKalman filter update step.\n\nObservation model: y = β * x + v\n\nArgs:\n    y: Observed value of asset 1\n    x: Observed value of asset 2\n\nReturns:\n    Updated β estimate", "source": "core\\trading\\pairs_trading_kalman.py", "category": "time_series"}
{"instruction": "What is the formula for Update?", "input": "", "output": "Update filter and generate trading signal.\n\nArgs:\n    price1: Current price of asset 1\n    price2: Current price of asset 2\n\nReturns:\n    signal: 1 (long spread), -1 (short spread), 0 (exit/hold)\n    info: Dict with β, spread, z-score, etc.", "source": "core\\trading\\pairs_trading_kalman.py", "category": "alpha"}
{"instruction": "Explain the Update function", "input": "", "output": "Function: update\n\nUpdate filter and generate trading signal.\n\nArgs:\n    price1: Current price of asset 1\n    price2: Current price of asset 2\n\nReturns:\n    signal: 1 (long spread), -1 (short spread), 0 (exit/hold)\n    info: Dict with β, spread, z-score, etc.", "source": "core\\trading\\pairs_trading_kalman.py", "category": "alpha"}
{"instruction": "Explain the Get Position Sizes function", "input": "", "output": "Function: get_position_sizes\n\nCalculate position sizes for current signal.\n\nArgs:\n    capital: Total capital to allocate\n\nReturns:\n    qty1: Quantity of asset 1\n    qty2: Quantity of asset 2", "source": "core\\trading\\pairs_trading_kalman.py", "category": "alpha"}
{"instruction": "Explain the Get Stats function", "input": "", "output": "Function: get_stats\n\nGet trading statistics.", "source": "core\\trading\\pairs_trading_kalman.py", "category": "general"}
{"instruction": "Explain the purpose of Position Manager", "input": "", "output": "Position Manager\n================\nTrack and manage trading positions across symbols.", "source": "core\\trading\\position.py", "category": "general"}
{"instruction": "What is the Position class and how do I use it?", "input": "", "output": "The Position class:\n\nRepresents a trading position.", "source": "core\\trading\\position.py", "category": "general"}
{"instruction": "What is the PositionManager class and how do I use it?", "input": "", "output": "The PositionManager class:\n\nManage positions across all trading symbols.\n\nThread-safe position tracking with P&L calculation.", "source": "core\\trading\\position.py", "category": "general"}
{"instruction": "Explain the Update Pnl function", "input": "", "output": "Function: update_pnl\n\nUpdate unrealized P&L based on current price.", "source": "core\\trading\\position.py", "category": "general"}
{"instruction": "Explain the Get Position function", "input": "", "output": "Function: get_position\n\nGet or create position for a symbol.", "source": "core\\trading\\position.py", "category": "general"}
{"instruction": "What is the formula for Update Position?", "input": "", "output": "Update position after a trade.\n\nArgs:\n    symbol: Trading symbol\n    quantity: Signed quantity (positive = buy, negative = sell)\n    price: Execution price\n    is_fill: Whether this is a fill (vs theoretical update)", "source": "core\\trading\\position.py", "category": "execution"}
{"instruction": "Explain the Update Position function", "input": "", "output": "Function: update_position\n\nUpdate position after a trade.\n\nArgs:\n    symbol: Trading symbol\n    quantity: Signed quantity (positive = buy, negative = sell)\n    price: Execution price\n    is_fill: Whether this is a fill (vs theoretical update)", "source": "core\\trading\\position.py", "category": "execution"}
{"instruction": "Explain the Update Prices function", "input": "", "output": "Function: update_prices\n\nUpdate unrealized P&L for all positions.", "source": "core\\trading\\position.py", "category": "general"}
{"instruction": "Explain the Get Open Positions function", "input": "", "output": "Function: get_open_positions\n\nGet all open positions.", "source": "core\\trading\\position.py", "category": "general"}
{"instruction": "Explain the Get Total Pnl function", "input": "", "output": "Function: get_total_pnl\n\nGet total P&L across all positions.", "source": "core\\trading\\position.py", "category": "general"}
{"instruction": "Explain the Close All function", "input": "", "output": "Function: close_all\n\nClose all positions at given prices.", "source": "core\\trading\\position.py", "category": "general"}
{"instruction": "Explain the Summary function", "input": "", "output": "Function: summary\n\nGet position summary.", "source": "core\\trading\\position.py", "category": "general"}
{"instruction": "Explain the purpose of Signal Generator", "input": "", "output": "Signal Generator\n================\nML-based signal generation for trading decisions.", "source": "core\\trading\\signal.py", "category": "alpha"}
{"instruction": "What is the Signal class and how do I use it?", "input": "", "output": "The Signal class:\n\nTrading signal with direction and confidence.", "source": "core\\trading\\signal.py", "category": "alpha"}
{"instruction": "What is the SignalGenerator class and how do I use it?", "input": "", "output": "The SignalGenerator class:\n\nGenerate trading signals using ML ensemble.\n\nUses lazy-loaded models via ModelLoader.\nEnsemble voting: XGBoost + LightGBM + CatBoost majority.", "source": "core\\trading\\signal.py", "category": "alpha"}
{"instruction": "Explain the Predict function", "input": "", "output": "Function: predict\n\nGenerate trading signal for a symbol.\n\nArgs:\n    symbol: Trading symbol\n    features: Feature dictionary from feature engine\n\nReturns:\n    Signal or None if prediction fails", "source": "core\\trading\\signal.py", "category": "alpha"}
{"instruction": "Explain the Get Available Symbols function", "input": "", "output": "Function: get_available_symbols\n\nGet symbols with available models.", "source": "core\\trading\\signal.py", "category": "general"}
{"instruction": "Explain the Preload Models function", "input": "", "output": "Function: preload_models\n\nPreload models for faster prediction.", "source": "core\\trading\\signal.py", "category": "general"}
{"instruction": "Explain the purpose of Risk Limits", "input": "", "output": "Risk Limits\n===========\nDataclass for risk parameters.", "source": "core\\risk\\limits.py", "category": "risk"}
{"instruction": "What is the RiskLimits class and how do I use it?", "input": "", "output": "The RiskLimits class:\n\nRisk limits for a trading symbol or portfolio.", "source": "core\\risk\\limits.py", "category": "risk"}
{"instruction": "Explain the From Dict function", "input": "", "output": "Function: from_dict\n\nCreate RiskLimits from a configuration dict.", "source": "core\\risk\\limits.py", "category": "risk"}
{"instruction": "Explain the To Dict function", "input": "", "output": "Function: to_dict\n\nConvert to dictionary.", "source": "core\\risk\\limits.py", "category": "general"}
{"instruction": "Explain the purpose of Per-Symbol Risk Manager", "input": "", "output": "Per-Symbol Risk Manager\n=======================\nIndependent risk tracking for each trading symbol.", "source": "core\\risk\\per_symbol.py", "category": "risk"}
{"instruction": "What is the SymbolMetrics class and how do I use it?", "input": "", "output": "The SymbolMetrics class:\n\nTracking metrics for a symbol.", "source": "core\\risk\\per_symbol.py", "category": "general"}
{"instruction": "What is the PerSymbolRiskManager class and how do I use it?", "input": "", "output": "The PerSymbolRiskManager class:\n\nRisk manager for a single trading symbol.\n\nTracks:\n- Daily trade count\n- Per-symbol drawdown\n- Win/loss statistics\n- Position sizing via Kelly\n\nIndependent from other symbols - EURUSD hitting its limit\ndoesn't affect GBPUSD trading.", "source": "core\\risk\\per_symbol.py", "category": "risk"}
{"instruction": "Explain the Can Trade function", "input": "", "output": "Function: can_trade\n\nCheck if trading is allowed for this symbol.\n\nReturns:\n    (can_trade, reason)", "source": "core\\risk\\per_symbol.py", "category": "general"}
{"instruction": "What is the formula for Calculate Position Size?", "input": "", "output": "Calculate position size using fractional Kelly.\n\nArgs:\n    signal_strength: Signal confidence (-1 to 1)\n    account_balance: Total account balance\n    win_rate: Historical win rate for this symbol\n\nReturns:\n    Position size in base currency units", "source": "core\\risk\\per_symbol.py", "category": "alpha"}
{"instruction": "Explain the Calculate Position Size function", "input": "", "output": "Function: calculate_position_size\n\nCalculate position size using fractional Kelly.\n\nArgs:\n    signal_strength: Signal confidence (-1 to 1)\n    account_balance: Total account balance\n    win_rate: Historical win rate for this symbol\n\nReturns:\n    Position size in base currency units", "source": "core\\risk\\per_symbol.py", "category": "alpha"}
{"instruction": "What is Kelly Criterion in quantitative trading?", "input": "", "output": "Kelly Criterion (position sizing formula that maximizes long-term growth).\n\nImplementation details:\nCalculate position size using fractional Kelly.\n\nArgs:\n    signal_strength: Signal confidence (-1 to 1)\n    account_balance: Total account balance\n    win_rate: Historical win rate for this symbol\n\nReturns:\n    Position size in base currency units", "source": "core\\risk\\per_symbol.py", "category": "alpha"}
{"instruction": "Explain the Record Trade function", "input": "", "output": "Function: record_trade\n\nRecord a trade execution.", "source": "core\\risk\\per_symbol.py", "category": "execution"}
{"instruction": "Explain the Record Pnl function", "input": "", "output": "Function: record_pnl\n\nRecord realized PnL.", "source": "core\\risk\\per_symbol.py", "category": "general"}
{"instruction": "Explain the Win Rate function", "input": "", "output": "Function: win_rate\n\nCalculate win rate.", "source": "core\\risk\\per_symbol.py", "category": "general"}
{"instruction": "Explain the Trades Remaining function", "input": "", "output": "Function: trades_remaining\n\nGet remaining trades for today.", "source": "core\\risk\\per_symbol.py", "category": "general"}
{"instruction": "Explain the Summary function", "input": "", "output": "Function: summary\n\nGet summary statistics.", "source": "core\\risk\\per_symbol.py", "category": "general"}
{"instruction": "Explain the purpose of Portfolio Risk Manager", "input": "", "output": "Portfolio Risk Manager\n======================\nManages risk across all trading symbols.", "source": "core\\risk\\portfolio.py", "category": "risk"}
{"instruction": "What is the PortfolioRiskManager class and how do I use it?", "input": "", "output": "The PortfolioRiskManager class:\n\nPortfolio-level risk management across all symbols.\n\nFeatures:\n- Per-symbol risk managers (independent limits)\n- Correlation-based position limits\n- Total portfolio exposure limits\n- Daily P&L tracking", "source": "core\\risk\\portfolio.py", "category": "risk"}
{"instruction": "Explain the Get Manager function", "input": "", "output": "Function: get_manager\n\nGet or create a risk manager for a symbol.\n\nArgs:\n    symbol: Trading symbol\n\nReturns:\n    PerSymbolRiskManager for the symbol", "source": "core\\risk\\portfolio.py", "category": "risk"}
{"instruction": "What is the formula for Can Trade?", "input": "", "output": "Check if trading is allowed for a symbol.\n\nChecks both symbol-level and portfolio-level limits.\n\nReturns:\n    (can_trade, reason)", "source": "core\\risk\\portfolio.py", "category": "general"}
{"instruction": "Explain the Can Trade function", "input": "", "output": "Function: can_trade\n\nCheck if trading is allowed for a symbol.\n\nChecks both symbol-level and portfolio-level limits.\n\nReturns:\n    (can_trade, reason)", "source": "core\\risk\\portfolio.py", "category": "general"}
{"instruction": "What is the formula for Calculate Position Size?", "input": "", "output": "Calculate position size for a symbol.\n\nArgs:\n    symbol: Trading symbol\n    signal_strength: Signal confidence (-1 to 1)\n    win_rate: Historical win rate\n\nReturns:\n    Position size", "source": "core\\risk\\portfolio.py", "category": "alpha"}
{"instruction": "Explain the Calculate Position Size function", "input": "", "output": "Function: calculate_position_size\n\nCalculate position size for a symbol.\n\nArgs:\n    symbol: Trading symbol\n    signal_strength: Signal confidence (-1 to 1)\n    win_rate: Historical win rate\n\nReturns:\n    Position size", "source": "core\\risk\\portfolio.py", "category": "alpha"}
{"instruction": "Explain the Record Trade function", "input": "", "output": "Function: record_trade\n\nRecord a trade for a symbol.", "source": "core\\risk\\portfolio.py", "category": "general"}
{"instruction": "Explain the Reset Daily function", "input": "", "output": "Function: reset_daily\n\nReset daily metrics.", "source": "core\\risk\\portfolio.py", "category": "general"}
{"instruction": "Explain the Set Correlations function", "input": "", "output": "Function: set_correlations\n\nSet correlation matrix for risk checks.", "source": "core\\risk\\portfolio.py", "category": "risk"}
{"instruction": "Explain the Summary function", "input": "", "output": "Function: summary\n\nGet portfolio summary.", "source": "core\\risk\\portfolio.py", "category": "general"}
{"instruction": "Explain the Get Tradeable Symbols function", "input": "", "output": "Function: get_tradeable_symbols\n\nGet list of symbols that can currently trade.", "source": "core\\risk\\portfolio.py", "category": "general"}
{"instruction": "Explain the purpose of Mutual Information Calculator", "input": "", "output": "Mutual Information Calculator\n=============================\nI(X;Y) = H(Y) - H(Y|X) = H(X) + H(Y) - H(X,Y)\n\nMeasures how much information feature X provides about target Y.\n\nResearch basis:\n- Shannon (1948): Foundational information theory\n- Cover & Thomas (2006): Elements of Information Theory\n- Peng (2005): mRMR feature selection\n- Vergara & Estévez (2014): A review of feature selection methods\n\nChinese Quant applications:\n- 幻方量化: Feature importance ranking\n- 九坤投资: Multi-factor alpha mining\n- Feature selection reduces 575 → 100 most informative\n\nExpected gain: +4-6% accuracy improvement", "source": "core\\information\\mutual_info.py", "category": "alpha"}
{"instruction": "What is the MutualInformationCalculator class and how do I use it?", "input": "", "output": "The MutualInformationCalculator class:\n\nCalculate mutual information between features and target.\n\nI(X;Y) measures reduction in uncertainty about Y when X is observed.\n\nUses:\n- Feature selection (keep features with high I(X;Y))\n- Redundancy detection (remove if I(X1;X2) > threshold)\n- Information extraction measurement", "source": "core\\information\\mutual_info.py", "category": "general"}
{"instruction": "What is the formula for Calculate Mutual Information?", "input": "", "output": "Convenience function to calculate MI.\n\nArgs:\n    X: Feature array\n    Y: Target array\n    bins: Number of bins for discretization\n    method: 'binning' or 'knn'\n\nReturns:\n    Mutual information in bits\n\nExample:\n    >>> feature = np.array([1, 2, 3, 4, 5])\n    >>> target = np.array([2, 4, 6, 8, 10])\n    >>> mi = calculate_mutual_information(feature, target)\n    >>> print(f\"I(X;Y) = {mi:.3f} bits\")", "source": "core\\information\\mutual_info.py", "category": "general"}
{"instruction": "Explain the Calculate Mutual Information function", "input": "", "output": "Function: calculate_mutual_information\n\nConvenience function to calculate MI.\n\nArgs:\n    X: Feature array\n    Y: Target array\n    bins: Number of bins for discretization\n    method: 'binning' or 'knn'\n\nReturns:\n    Mutual information in bits\n\nExample:\n    >>> feature = np.array([1, 2, 3, 4, 5])\n    >>> target = np.array([2, 4, 6, 8, 10])\n    >>> mi = calculate_mutual_information(feature, target)\n    >>> print(f\"I(X;Y) = {mi:.3f} bits\")", "source": "core\\information\\mutual_info.py", "category": "general"}
{"instruction": "What is the formula for Calculate?", "input": "", "output": "Calculate I(X;Y) in bits.\n\nArgs:\n    X: Feature array (1D)\n    Y: Target array (1D)\n    normalize: If True, return normalized MI: I(X;Y) / H(Y)\n\nReturns:\n    Mutual information in bits", "source": "core\\information\\mutual_info.py", "category": "general"}
{"instruction": "Explain the Calculate function", "input": "", "output": "Function: calculate\n\nCalculate I(X;Y) in bits.\n\nArgs:\n    X: Feature array (1D)\n    Y: Target array (1D)\n    normalize: If True, return normalized MI: I(X;Y) / H(Y)\n\nReturns:\n    Mutual information in bits", "source": "core\\information\\mutual_info.py", "category": "general"}
{"instruction": "Explain the Select Features function", "input": "", "output": "Function: select_features\n\nSelect features based on MI with target.\n\nArgs:\n    features: Feature matrix (n_samples, n_features)\n    target: Target array (n_samples,)\n    top_k: Select top K features by MI (if None, use threshold)\n    threshold: Minimum MI threshold in bits\n\nReturns:\n    (selected_indices, mi_scores)", "source": "core\\information\\mutual_info.py", "category": "general"}
{"instruction": "Explain the purpose of Transfer Entropy Calculator", "input": "", "output": "Transfer Entropy Calculator\n===========================\nTE(X→Y) = I(Y_t; X_{t-lag} | Y_{t-lag})\n\nMeasures directional information flow from X to Y.\nSuperior to Granger causality for detecting nonlinear relationships.\n\nResearch basis:\n- Schreiber (2000): Measuring Information Transfer\n- Dimpfl & Peter (2013): Using Transfer Entropy to Measure Information Flows Between Financial Markets\n- Behrendt (2019): RTransferEntropy: Quantifying information flow between different time series\n\nChinese Quant applications:\n- 幻方量化: Inter-market causality detection\n- 九坤投资: Lead-lag relationship mining\n- Directional causality: Does EUR lead USD? Does VIX cause forex volatility?\n\nKey advantage over Granger:\n- Detects nonlinear causality (Granger only finds linear)\n- Variable-lag detection (optimal lag for each pair)\n- Information-theoretic (measures bits of predictability)\n\nExpected gain: +3-5% accuracy improvement", "source": "core\\information\\transfer_entropy.py", "category": "volatility"}
{"instruction": "What is the TransferEntropyCalculator class and how do I use it?", "input": "", "output": "The TransferEntropyCalculator class:\n\nCalculate transfer entropy TE(X→Y) to detect causality.\n\nTE(X→Y) > 0: X provides information about future of Y\nTE(X→Y) ≈ 0: X does not help predict Y\n\nCompare TE(X→Y) vs TE(Y→X) to determine causal direction.", "source": "core\\information\\transfer_entropy.py", "category": "general"}
{"instruction": "What is the formula for Calculate Transfer Entropy?", "input": "", "output": "Convenience function to calculate TE.\n\nArgs:\n    X: Source time series\n    Y: Target time series\n    lag: Time lag\n    bins: Number of bins for discretization\n    k: History length\n\nReturns:\n    Transfer entropy in bits\n\nExample:\n    >>> # Does EUR/USD lead GBP/USD?\n    >>> eurusd_returns = np.diff(eurusd_prices) / eurusd_prices[:-1]\n    >>> gbpusd_returns = np.diff(gbpusd_prices) / gbpusd_prices[:-1]\n    >>> te = calculate_transfer_entropy(eurusd_returns, gbpusd_returns, lag=5)\n    >>> print(f\"TE(EUR→GBP) = {te:.3f} bits\")", "source": "core\\information\\transfer_entropy.py", "category": "general"}
{"instruction": "Explain the Calculate Transfer Entropy function", "input": "", "output": "Function: calculate_transfer_entropy\n\nConvenience function to calculate TE.\n\nArgs:\n    X: Source time series\n    Y: Target time series\n    lag: Time lag\n    bins: Number of bins for discretization\n    k: History length\n\nReturns:\n    Transfer entropy in bits\n\nExample:\n    >>> # Does EUR/USD lead GBP/USD?\n    >>> eurusd_returns = np.diff(eurusd_prices) / eurusd_prices[:-1]\n    >>> gbpusd_returns = np.diff(gbpusd_prices) / gbpusd_prices[:-1]\n    >>> te = calculate_transfer_entropy(eurusd_returns, gbpusd_returns, lag=5)\n    >>> print(f\"TE(EUR→GBP) = {te:.3f} bits\")", "source": "core\\information\\transfer_entropy.py", "category": "general"}
{"instruction": "What is the formula for Calculate?", "input": "", "output": "Calculate TE(X→Y) in bits.\n\nArgs:\n    X: Source time series\n    Y: Target time series\n    lag: Time lag (how many steps in past does X affect Y)\n    variable_lag: If True, search for optimal lag\n    max_lag: Maximum lag to search (if variable_lag=True)\n\nReturns:\n    Transfer entropy in bits (or dict with optimal lag if variable_lag)", "source": "core\\information\\transfer_entropy.py", "category": "risk"}
{"instruction": "Explain the Calculate function", "input": "", "output": "Function: calculate\n\nCalculate TE(X→Y) in bits.\n\nArgs:\n    X: Source time series\n    Y: Target time series\n    lag: Time lag (how many steps in past does X affect Y)\n    variable_lag: If True, search for optimal lag\n    max_lag: Maximum lag to search (if variable_lag=True)\n\nReturns:\n    Transfer entropy in bits (or dict with optimal lag if variable_lag)", "source": "core\\information\\transfer_entropy.py", "category": "risk"}
{"instruction": "Explain the Detect Causality function", "input": "", "output": "Function: detect_causality\n\nDetect causal direction between X and Y.\n\nArgs:\n    X: First time series\n    Y: Second time series\n    max_lag: Maximum lag to test\n    significance_threshold: Minimum TE in bits to consider significant\n\nReturns:\n    Dictionary with causality results", "source": "core\\information\\transfer_entropy.py", "category": "general"}
