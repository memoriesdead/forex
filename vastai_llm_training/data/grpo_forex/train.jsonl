{"instruction": "What is the TD_Error formula?", "input": "", "output": "**TD_Error**\n\nTemporal Difference error for value learning\n\n**Formula:**\n```\nδ_t = r_t + γ * V(s_{t+1}) - V(s_t)\n```\n\n**Citation:** Sutton, R.S. (1988). Machine Learning"}
{"instruction": "Explain the components of Avellaneda_Stoikov.", "input": "", "output": "**Avellaneda_Stoikov**\n\nOptimal market making quotes\n\n**Formula:**\n```\nδ = (1/γ) * ln(1 + γ/k), r = s - q*γ*σ²*(T-t)\n```\n\n**Components:**\n- γ (risk aversion)\n- σ (volatility)\n- k (arrival rate)\n- q (inventory)\n\n**Citation:** Avellaneda, M. & Stoikov, S. (2008). Quantitative Finance"}
{"instruction": "When should I use Alpha019 in trading?", "input": "", "output": "**Alpha019** is used for: Long-term momentum reversal\n\n**Formula:**\n```\n((-1 * sign(((close - delay(close, 7)) + delta(close, 7)))) * (1 + rank((1 + sum(returns, 250)))))\n```\n\nUse this when you need to long-term momentum reversal.\n\n**Citation:** Academic source"}
{"instruction": "When should I use VaR in trading?", "input": "", "output": "**VaR** is used for: Value at Risk - maximum loss at confidence level\n\n**Formula:**\n```\nVaR_α = -inf{x : P(L ≤ x) ≥ α} = μ + σ * Φ^{-1}(α)\n```\n\nUse this when you need to value at risk - maximum loss at confidence level.\n\n**Citation:** Jorion, P. (2006). Value at Risk"}
{"instruction": "When should I use Avellaneda_Stoikov in trading?", "input": "", "output": "**Avellaneda_Stoikov** is used for: Optimal market making quotes\n\n**Formula:**\n```\nδ = (1/γ) * ln(1 + γ/k), r = s - q*γ*σ²*(T-t)\n```\n\nUse this when you need to optimal market making quotes.\n\n**Citation:** Avellaneda, M. & Stoikov, S. (2008). Quantitative Finance"}
{"instruction": "What is the PIN formula?", "input": "", "output": "**PIN**\n\nProbability of Informed Trading\n\n**Formula:**\n```\nPIN = αμ / (αμ + ε_b + ε_s)\n```\n\n**Citation:** Easley, D., Kiefer, N., O'Hara, M. (1997). Journal of Finance"}
{"instruction": "When should I use Rogers_Satchell in trading?", "input": "", "output": "**Rogers_Satchell** is used for: Range-based estimator handling drift\n\n**Formula:**\n```\nσ²_RS = ln(H/C)*ln(H/O) + ln(L/C)*ln(L/O)\n```\n\nUse this when you need to range-based estimator handling drift.\n\n**Citation:** Rogers, L.C.G. & Satchell, S.E. (1991). Annals of Applied Probability"}
{"instruction": "When should I use Effective_Spread in trading?", "input": "", "output": "**Effective_Spread** is used for: Actual execution cost relative to midpoint\n\n**Formula:**\n```\nES = 2 * |P_trade - M| / M\n```\n\nUse this when you need to actual execution cost relative to midpoint.\n\n**Citation:** Goyenko, R.Y., Holden, C.W., & Trzcinka, C.A. (2009). Journal of Financial Economics"}
{"instruction": "What is the Alpha007 formula?", "input": "", "output": "**Alpha007**\n\nVolume-conditioned momentum reversal\n\n**Formula:**\n```\n(adv20 < volume) ? ((-1 * ts_rank(abs(delta(close, 7)), 60)) * sign(delta(close, 7))) : -1\n```\n\n**Citation:** Academic source"}
{"instruction": "How do I implement Market_Impact_Linear in Python?", "input": "", "output": "**Market_Impact_Linear** - Linear + square-root market impact model\n\n**Formula:**\n```\nImpact = η * (Q / ADV) + γ * σ * sqrt(Q / ADV)\n```\n\n**Python Implementation:**\n```python\ndef market_impact(quantity, adv, volatility, eta=0.1, gamma=0.3):\n    participation = quantity / adv\n    linear_impact = eta * participation\n    sqrt_impact = gamma * volatility * np.sqrt(participation)\n    return linear_impact + sqrt_impact\n```\n\n**Citation:** Almgren, R. et al. (2005). Risk Magazine"}
{"instruction": "When should I use Realized_Variance in trading?", "input": "", "output": "**Realized_Variance** is used for: Sum of squared intraday returns\n\n**Formula:**\n```\nRV_t = Σ(r_{t,i})² for i = 1 to n intraday returns\n```\n\nUse this when you need to sum of squared intraday returns.\n\n**Citation:** Andersen, T.G. & Bollerslev, T. (1998). International Economic Review"}
{"instruction": "What is the Realized_Variance formula?", "input": "", "output": "**Realized_Variance**\n\nSum of squared intraday returns\n\n**Formula:**\n```\nRV_t = Σ(r_{t,i})² for i = 1 to n intraday returns\n```\n\n**Citation:** Andersen, T.G. & Bollerslev, T. (1998). International Economic Review"}
{"instruction": "What is the GARCH_11 formula?", "input": "", "output": "**GARCH_11**\n\nGeneralized Autoregressive Conditional Heteroskedasticity\n\n**Formula:**\n```\nσ²_t = ω + α * ε²_{t-1} + β * σ²_{t-1}\n```\n\n**Citation:** Bollerslev, T. (1986). Journal of Econometrics"}
{"instruction": "Explain the components of CVaR.", "input": "", "output": "**CVaR**\n\nConditional VaR / Expected Shortfall\n\n**Formula:**\n```\nCVaR_α = E[L | L > VaR_α] = μ + σ * φ(Φ^{-1}(α)) / (1-α)\n```\n\n**Components:**\n- VaR_α\n- φ (normal pdf)\n- Φ^{-1} (inverse normal)\n\n**Citation:** Rockafellar, R.T. & Uryasev, S. (2000). Journal of Risk"}
{"instruction": "What is the Alpha011 formula?", "input": "", "output": "**Alpha011**\n\nVWAP deviation with volume momentum\n\n**Formula:**\n```\n((rank(ts_max((vwap - close), 3)) + rank(ts_min((vwap - close), 3))) * rank(delta(volume, 3)))\n```\n\n**Citation:** Academic source"}
{"instruction": "How do I implement TD_Error in Python?", "input": "", "output": "**TD_Error** - Temporal Difference error for value learning\n\n**Formula:**\n```\nδ_t = r_t + γ * V(s_{t+1}) - V(s_t)\n```\n\n**Python Implementation:**\n```python\ndef td_error(reward, next_value, current_value, gamma=0.99):\n    return reward + gamma * next_value - current_value\n```\n\n**Citation:** Sutton, R.S. (1988). Machine Learning"}
{"instruction": "What is the GAE formula?", "input": "", "output": "**GAE**\n\nGeneralized Advantage Estimation\n\n**Formula:**\n```\nA_t^GAE = Σ_{l=0}^{∞} (γλ)^l * δ_{t+l}\n```\n\n**Citation:** Schulman, J. et al. (2015). arXiv:1506.02438"}
{"instruction": "How do I implement DQN_Loss in Python?", "input": "", "output": "**DQN_Loss** - Deep Q-Network loss with target network\n\n**Formula:**\n```\nL = E[(r + γ * max_a' Q(s', a'; θ⁻) - Q(s, a; θ))²]\n```\n\n**Python Implementation:**\n```python\ndef dqn_loss(q_values, actions, rewards, next_q_values, gamma=0.99):\n    q_selected = q_values.gather(1, actions.unsqueeze(1)).squeeze()\n    q_target = rewards + gamma * next_q_values.max(1)[0]\n    return F.mse_loss(q_selected, q_target.detach())\n```\n\n**Citation:** Mnih, V. et al. (2015). Nature"}
{"instruction": "Explain the components of VWAP.", "input": "", "output": "**VWAP**\n\nVolume-Weighted Average Price execution\n\n**Formula:**\n```\nTarget% = Historical_Volume% at each interval\n```\n\n**Components:**\n- Historical volume profile\n- Target quantity\n\n**Citation:** Madhavan, A. (2002). Financial Analysts Journal"}
{"instruction": "What is the Alpha009 formula?", "input": "", "output": "**Alpha009**\n\nTrend-following with momentum conditions\n\n**Formula:**\n```\n(0 < ts_min(delta(close, 1), 5)) ? delta(close, 1) : ((ts_max(delta(close, 1), 5) < 0) ? delta(close, 1) : (-1 * delta(close, 1)))\n```\n\n**Citation:** Academic source"}
{"instruction": "Explain the components of GAE.", "input": "", "output": "**GAE**\n\nGeneralized Advantage Estimation\n\n**Formula:**\n```\nA_t^GAE = Σ_{l=0}^{∞} (γλ)^l * δ_{t+l}\n```\n\n**Components:**\n- δ (TD error)\n- γ (discount)\n- λ (GAE parameter)\n\n**Citation:** Schulman, J. et al. (2015). arXiv:1506.02438"}
{"instruction": "How do I implement Alpha015 in Python?", "input": "", "output": "**Alpha015** - Rolling sum of high-volume correlation ranks\n\n**Formula:**\n```\n-1 * sum(rank(correlation(rank(high), rank(volume), 3)), 3)\n```\n\n**Python Implementation:**\n```python\ndef alpha015(high, volume):\n    high_rank = high.rank(pct=True)\n    vol_rank = volume.rank(pct=True)\n    corr = high_rank.rolling(3).corr(vol_rank)\n    return -corr.rank(pct=True).rolling(3).sum()\n```\n\n**Citation:** Academic source"}
{"instruction": "How do I implement Kyle_Lambda in Python?", "input": "", "output": "**Kyle_Lambda** - Measure of market depth and price impact\n\n**Formula:**\n```\nλ = ΔP / ΔQ (price impact per unit order flow)\n```\n\n**Python Implementation:**\n```python\ndef kyle_lambda(price_changes, order_imbalance):\n    from sklearn.linear_model import LinearRegression\n    model = LinearRegression(fit_intercept=False)\n    model.fit(order_imbalance.values.reshape(-1,1), price_changes.values)\n    return model.coef_[0]\n```\n\n**Citation:** Kyle, A.S. (1985). Econometrica"}
{"instruction": "When should I use VWAP in trading?", "input": "", "output": "**VWAP** is used for: Volume-Weighted Average Price execution\n\n**Formula:**\n```\nTarget% = Historical_Volume% at each interval\n```\n\nUse this when you need to volume-weighted average price execution.\n\n**Citation:** Madhavan, A. (2002). Financial Analysts Journal"}
{"instruction": "Explain the components of TWAP.", "input": "", "output": "**TWAP**\n\nTime-Weighted Average Price execution\n\n**Formula:**\n```\nTrade_size = Total_quantity / N (equal slices)\n```\n\n**Components:**\n- Total_quantity\n- N (number of time slices)\n\n**Citation:** Berkowitz, S.A., Logue, D.E., & Noser, E.A. (1988). Journal of Finance"}
{"instruction": "How do I implement Sharpe_Ratio in Python?", "input": "", "output": "**Sharpe_Ratio** - Risk-adjusted return per unit of volatility\n\n**Formula:**\n```\nSR = (R_p - R_f) / σ_p\n```\n\n**Python Implementation:**\n```python\ndef sharpe_ratio(returns, risk_free_rate=0, periods_per_year=252):\n    excess_returns = returns - risk_free_rate / periods_per_year\n    return np.sqrt(periods_per_year) * excess_returns.mean() / excess_returns.std()\n```\n\n**Citation:** Sharpe, W.F. (1966). Journal of Business"}
{"instruction": "What is the Almgren_Chriss formula?", "input": "", "output": "**Almgren_Chriss**\n\nOptimal execution trajectory minimizing cost + variance\n\n**Formula:**\n```\nn_j = (X_0/N) * sinh(κ*(T-t_j)) / sinh(κ*T)\n```\n\n**Citation:** Almgren, R. & Chriss, N. (2001). Journal of Risk"}
{"instruction": "Explain the components of Alpha003.", "input": "", "output": "**Alpha003**\n\nNegative correlation between open price rank and volume rank\n\n**Formula:**\n```\n-1 * correlation(rank(open), rank(volume), 10)\n```\n\n**Components:**\n- correlation\n- rank\n- open\n- volume\n\n**Citation:** Academic source"}
{"instruction": "Explain the components of Alpha019.", "input": "", "output": "**Alpha019**\n\nLong-term momentum reversal\n\n**Formula:**\n```\n((-1 * sign(((close - delay(close, 7)) + delta(close, 7)))) * (1 + rank((1 + sum(returns, 250)))))\n```\n\n**Components:**\n- sign\n- delay\n- delta\n- rank\n- sum\n\n**Citation:** Academic source"}
{"instruction": "How do I implement TWAP in Python?", "input": "", "output": "**TWAP** - Time-Weighted Average Price execution\n\n**Formula:**\n```\nTrade_size = Total_quantity / N (equal slices)\n```\n\n**Python Implementation:**\n```python\ndef twap_schedule(total_quantity, n_slices):\n    return np.full(n_slices, total_quantity / n_slices)\n```\n\n**Citation:** Berkowitz, S.A., Logue, D.E., & Noser, E.A. (1988). Journal of Finance"}
{"instruction": "When should I use DQN_Loss in trading?", "input": "", "output": "**DQN_Loss** is used for: Deep Q-Network loss with target network\n\n**Formula:**\n```\nL = E[(r + γ * max_a' Q(s', a'; θ⁻) - Q(s, a; θ))²]\n```\n\nUse this when you need to deep q-network loss with target network.\n\n**Citation:** Mnih, V. et al. (2015). Nature"}
{"instruction": "Explain the components of HAR_RV.", "input": "", "output": "**HAR_RV**\n\nHeterogeneous Autoregressive Realized Volatility model\n\n**Formula:**\n```\nRV_{t+1} = β₀ + β_d * RV_d + β_w * RV_w + β_m * RV_m + ε_{t+1}\n```\n\n**Components:**\n- RV_d (daily)\n- RV_w (weekly, 5d)\n- RV_m (monthly, 22d)\n\n**Citation:** Corsi, F. (2009). Journal of Financial Econometrics"}
{"instruction": "Explain the components of Almgren_Chriss.", "input": "", "output": "**Almgren_Chriss**\n\nOptimal execution trajectory minimizing cost + variance\n\n**Formula:**\n```\nn_j = (X_0/N) * sinh(κ*(T-t_j)) / sinh(κ*T)\n```\n\n**Components:**\n- X_0 (initial position)\n- N (periods)\n- T (total time)\n- κ (urgency)\n\n**Citation:** Almgren, R. & Chriss, N. (2001). Journal of Risk"}
{"instruction": "How does EGARCH compare to other volatility estimators?", "input": "", "output": "**EGARCH**\n\nExponential GARCH capturing asymmetric volatility\n\n**Formula:**\n```\nlog(σ²_t) = ω + α * (|z_{t-1}| - E|z|) + γ * z_{t-1} + β * log(σ²_{t-1})\n```\n\n**Advantages:**\n- Specific use case for exponential garch capturing asymmetric volatility\n- Well-established in academic literature\n\n**Citation:** Nelson, D.B. (1991). Econometrica"}
{"instruction": "What is the Alpha008 formula?", "input": "", "output": "**Alpha008**\n\nMomentum of open-return product\n\n**Formula:**\n```\n-1 * rank(((sum(open, 5) * sum(returns, 5)) - delay((sum(open, 5) * sum(returns, 5)), 10)))\n```\n\n**Citation:** Academic source"}
{"instruction": "What is the PPO formula?", "input": "", "output": "**PPO**\n\nProximal Policy Optimization with clipped objective\n\n**Formula:**\n```\nL_CLIP = E[min(r_t(θ)*A_t, clip(r_t(θ), 1-ε, 1+ε)*A_t)]\n```\n\n**Citation:** Schulman, J. et al. (2017). arXiv:1707.06347"}
{"instruction": "How do I implement Kelly_Criterion in Python?", "input": "", "output": "**Kelly_Criterion** - Optimal fraction of capital to risk\n\n**Formula:**\n```\nf* = (p * b - q) / b = (p * W/L - (1-p)) / (W/L)\n```\n\n**Python Implementation:**\n```python\ndef kelly_criterion(win_prob, win_loss_ratio, fraction=0.25):\n    full_kelly = (win_prob * win_loss_ratio - (1 - win_prob)) / win_loss_ratio\n    return max(0, full_kelly * fraction)  # Fractional Kelly\n```\n\n**Citation:** Kelly, J.L. (1956). Bell System Technical Journal"}
{"instruction": "How do I implement Alpha020 in Python?", "input": "", "output": "**Alpha020** - Gap signal based on open vs previous OHLC\n\n**Formula:**\n```\n(((-1 * rank((open - delay(high, 1)))) * rank((open - delay(close, 1)))) * rank((open - delay(low, 1))))\n```\n\n**Python Implementation:**\n```python\ndef alpha020(open_price, high, low, close):\n    gap_high = -(open_price - high.shift(1)).rank(pct=True)\n    gap_close = (open_price - close.shift(1)).rank(pct=True)\n    gap_low = (open_price - low.shift(1)).rank(pct=True)\n    return gap_high * gap_close * gap_low\n```\n\n**Citation:** Academic source"}
{"instruction": "When should I use Alpha004 in trading?", "input": "", "output": "**Alpha004** is used for: Negative time-series rank of cross-sectional low rank\n\n**Formula:**\n```\n-1 * Ts_Rank(rank(low), 9)\n```\n\nUse this when you need to negative time-series rank of cross-sectional low rank.\n\n**Citation:** Academic source"}
{"instruction": "How do I implement EGARCH in Python?", "input": "", "output": "**EGARCH** - Exponential GARCH capturing asymmetric volatility\n\n**Formula:**\n```\nlog(σ²_t) = ω + α * (|z_{t-1}| - E|z|) + γ * z_{t-1} + β * log(σ²_{t-1})\n```\n\n**Python Implementation:**\n```python\nfrom arch import arch_model\ndef egarch_forecast(returns):\n    model = arch_model(returns, vol='EGARCH', p=1, o=1, q=1)\n    result = model.fit(disp='off')\n    return result.conditional_volatility\n```\n\n**Citation:** Nelson, D.B. (1991). Econometrica"}
{"instruction": "When should I use HAR_RV in trading?", "input": "", "output": "**HAR_RV** is used for: Heterogeneous Autoregressive Realized Volatility model\n\n**Formula:**\n```\nRV_{t+1} = β₀ + β_d * RV_d + β_w * RV_w + β_m * RV_m + ε_{t+1}\n```\n\nUse this when you need to heterogeneous autoregressive realized volatility model.\n\n**Citation:** Corsi, F. (2009). Journal of Financial Econometrics"}
{"instruction": "How do I implement Alpha012 in Python?", "input": "", "output": "**Alpha012** - Volume-price divergence signal\n\n**Formula:**\n```\nsign(delta(volume, 1)) * (-1 * delta(close, 1))\n```\n\n**Python Implementation:**\n```python\ndef alpha012(close, volume):\n    return np.sign(volume.diff(1)) * (-close.diff(1))\n```\n\n**Citation:** Academic source"}
{"instruction": "Explain the components of Alpha010.", "input": "", "output": "**Alpha010**\n\nRanked version of Alpha009 with 4-day window\n\n**Formula:**\n```\nrank((0 < ts_min(delta(close, 1), 4)) ? delta(close, 1) : ((ts_max(delta(close, 1), 4) < 0) ? delta(close, 1) : (-1 * delta(close, 1))))\n```\n\n**Components:**\n- rank\n- ts_min\n- ts_max\n- delta\n\n**Citation:** Academic source"}
{"instruction": "How do I implement GRPO in Python?", "input": "", "output": "**GRPO** - Group Relative Policy Optimization - no critic needed\n\n**Formula:**\n```\nA_i = (r_i - mean(r)) / std(r), L = -E[min(ρ*A, clip(ρ,1-ε,1+ε)*A)]\n```\n\n**Python Implementation:**\n```python\ndef grpo_advantage(rewards):\n    return (rewards - rewards.mean()) / (rewards.std() + 1e-8)\n\ndef grpo_loss(log_probs, advantages, old_log_probs, epsilon=0.2):\n    ratio = torch.exp(log_probs - old_log_probs)\n    clipped = torch.clamp(ratio, 1 - epsilon, 1 + epsilon)\n    return -torch.min(ratio * advantages, clipped * advantages).mean()\n```\n\n**Citation:** DeepSeek-AI (2025). DeepSeek-R1 Technical Report"}
{"instruction": "How do I implement Microprice in Python?", "input": "", "output": "**Microprice** - Size-weighted mid price reflecting order book imbalance\n\n**Formula:**\n```\nP_micro = P_ask * (Q_bid / (Q_bid + Q_ask)) + P_bid * (Q_ask / (Q_bid + Q_ask))\n```\n\n**Python Implementation:**\n```python\ndef microprice(bid_price, ask_price, bid_size, ask_size):\n    total_size = bid_size + ask_size\n    return ask_price * (bid_size / total_size) + bid_price * (ask_size / total_size)\n```\n\n**Citation:** Gatheral, J. & Oomen, R.C.A. (2010). Quantitative Finance"}
{"instruction": "When should I use Alpha001 in trading?", "input": "", "output": "**Alpha001** is used for: Conditional volatility-price signal with time-series argmax\n\n**Formula:**\n```\nrank(Ts_ArgMax(SignedPower(((returns < 0) ? stddev(returns, 20) : close), 2), 5)) - 0.5\n```\n\nUse this when you need to conditional volatility-price signal with time-series argmax.\n\n**Citation:** Academic source"}
{"instruction": "What is the DQN_Loss formula?", "input": "", "output": "**DQN_Loss**\n\nDeep Q-Network loss with target network\n\n**Formula:**\n```\nL = E[(r + γ * max_a' Q(s', a'; θ⁻) - Q(s, a; θ))²]\n```\n\n**Citation:** Mnih, V. et al. (2015). Nature"}
{"instruction": "Explain the components of VPIN.", "input": "", "output": "**VPIN**\n\nVolume-Synchronized Probability of Informed Trading\n\n**Formula:**\n```\nVPIN = Σ|V_buy - V_sell| / (n * V_bucket)\n```\n\n**Components:**\n- V_buy\n- V_sell\n- V_bucket (volume bucket size)\n- n (number of buckets)\n\n**Citation:** Easley, D., López de Prado, M., & O'Hara, M. (2012). Review of Financial Studies"}
{"instruction": "How do I implement HAR_RV in Python?", "input": "", "output": "**HAR_RV** - Heterogeneous Autoregressive Realized Volatility model\n\n**Formula:**\n```\nRV_{t+1} = β₀ + β_d * RV_d + β_w * RV_w + β_m * RV_m + ε_{t+1}\n```\n\n**Python Implementation:**\n```python\ndef har_rv_forecast(rv_daily, rv_weekly, rv_monthly):\n    X = np.column_stack([np.ones(len(rv_daily)), rv_daily, rv_weekly, rv_monthly])\n    y = rv_daily.shift(-1)\n    betas = np.linalg.lstsq(X[:-1], y[:-1], rcond=None)[0]\n    return X @ betas  # Forecast\n```\n\n**Citation:** Corsi, F. (2009). Journal of Financial Econometrics"}
{"instruction": "Explain the components of Alpha013.", "input": "", "output": "**Alpha013**\n\nNegative covariance of price and volume ranks\n\n**Formula:**\n```\n-1 * rank(covariance(rank(close), rank(volume), 5))\n```\n\n**Components:**\n- rank\n- covariance\n\n**Citation:** Academic source"}
{"instruction": "What is the Roll_Spread formula?", "input": "", "output": "**Roll_Spread**\n\nImplied bid-ask spread from price autocovariance\n\n**Formula:**\n```\nSpread = 2 * sqrt(-Cov(Δp_t, Δp_{t-1}))\n```\n\n**Citation:** Roll, R. (1984). Journal of Finance"}
{"instruction": "What is the Rogers_Satchell formula?", "input": "", "output": "**Rogers_Satchell**\n\nRange-based estimator handling drift\n\n**Formula:**\n```\nσ²_RS = ln(H/C)*ln(H/O) + ln(L/C)*ln(L/O)\n```\n\n**Citation:** Rogers, L.C.G. & Satchell, S.E. (1991). Annals of Applied Probability"}
{"instruction": "What is the Kelly_Criterion formula?", "input": "", "output": "**Kelly_Criterion**\n\nOptimal fraction of capital to risk\n\n**Formula:**\n```\nf* = (p * b - q) / b = (p * W/L - (1-p)) / (W/L)\n```\n\n**Citation:** Kelly, J.L. (1956). Bell System Technical Journal"}
{"instruction": "How does Parkinson compare to other volatility estimators?", "input": "", "output": "**Parkinson**\n\nRange-based volatility using high-low range only\n\n**Formula:**\n```\nσ²_P = (ln(H/L))² / (4 * ln(2))\n```\n\n**Advantages:**\n- Specific use case for range-based volatility using high-low range only\n- Well-established in academic literature\n\n**Citation:** Parkinson, M. (1980). Journal of Business"}
{"instruction": "How do I implement Realized_Variance in Python?", "input": "", "output": "**Realized_Variance** - Sum of squared intraday returns\n\n**Formula:**\n```\nRV_t = Σ(r_{t,i})² for i = 1 to n intraday returns\n```\n\n**Python Implementation:**\n```python\ndef realized_variance(intraday_returns):\n    return (intraday_returns ** 2).sum()\n```\n\n**Citation:** Andersen, T.G. & Bollerslev, T. (1998). International Economic Review"}
{"instruction": "When should I use Microprice in trading?", "input": "", "output": "**Microprice** is used for: Size-weighted mid price reflecting order book imbalance\n\n**Formula:**\n```\nP_micro = P_ask * (Q_bid / (Q_bid + Q_ask)) + P_bid * (Q_ask / (Q_bid + Q_ask))\n```\n\nUse this when you need to size-weighted mid price reflecting order book imbalance.\n\n**Citation:** Gatheral, J. & Oomen, R.C.A. (2010). Quantitative Finance"}
{"instruction": "Explain the components of Sortino_Ratio.", "input": "", "output": "**Sortino_Ratio**\n\nSharpe using only downside volatility\n\n**Formula:**\n```\nSortino = (R_p - R_f) / σ_downside\n```\n\n**Components:**\n- R_p\n- R_f\n- σ_downside (std of negative returns only)\n\n**Citation:** Sortino, F.A. & van der Meer, R. (1991). Journal of Portfolio Management"}
{"instruction": "How do I implement Parkinson in Python?", "input": "", "output": "**Parkinson** - Range-based volatility using high-low range only\n\n**Formula:**\n```\nσ²_P = (ln(H/L))² / (4 * ln(2))\n```\n\n**Python Implementation:**\n```python\ndef parkinson_vol(high, low):\n    log_hl = np.log(high / low)\n    return log_hl**2 / (4 * np.log(2))\n```\n\n**Citation:** Parkinson, M. (1980). Journal of Business"}
{"instruction": "Explain the components of Parkinson.", "input": "", "output": "**Parkinson**\n\nRange-based volatility using high-low range only\n\n**Formula:**\n```\nσ²_P = (ln(H/L))² / (4 * ln(2))\n```\n\n**Components:**\n- H (high)\n- L (low)\n\n**Citation:** Parkinson, M. (1980). Journal of Business"}
{"instruction": "How do I implement Effective_Spread in Python?", "input": "", "output": "**Effective_Spread** - Actual execution cost relative to midpoint\n\n**Formula:**\n```\nES = 2 * |P_trade - M| / M\n```\n\n**Python Implementation:**\n```python\ndef effective_spread(trade_price, bid, ask):\n    mid = (bid + ask) / 2\n    return 2 * np.abs(trade_price - mid) / mid\n```\n\n**Citation:** Goyenko, R.Y., Holden, C.W., & Trzcinka, C.A. (2009). Journal of Financial Economics"}
{"instruction": "What is the Alpha016 formula?", "input": "", "output": "**Alpha016**\n\nNegative covariance of high and volume ranks\n\n**Formula:**\n```\n-1 * rank(covariance(rank(high), rank(volume), 5))\n```\n\n**Citation:** Academic source"}
{"instruction": "What is the Alpha010 formula?", "input": "", "output": "**Alpha010**\n\nRanked version of Alpha009 with 4-day window\n\n**Formula:**\n```\nrank((0 < ts_min(delta(close, 1), 4)) ? delta(close, 1) : ((ts_max(delta(close, 1), 4) < 0) ? delta(close, 1) : (-1 * delta(close, 1))))\n```\n\n**Citation:** Academic source"}
{"instruction": "Explain the components of Bipower_Variation.", "input": "", "output": "**Bipower_Variation**\n\nRobust to jumps, uses product of adjacent absolute returns\n\n**Formula:**\n```\nBV_t = (π/2) * Σ|r_{t,i}| * |r_{t,i-1}|\n```\n\n**Components:**\n- r_{t,i} (returns)\n- π/2 (scaling factor)\n\n**Citation:** Barndorff-Nielsen, O.E. & Shephard, N. (2004). Journal of Financial Econometrics"}
{"instruction": "How do I implement Alpha017 in Python?", "input": "", "output": "**Alpha017** - Price momentum with volume relative to average\n\n**Formula:**\n```\n(((-1 * rank(ts_rank(close, 10))) * rank(delta(delta(close, 1), 1))) * rank(ts_rank((volume / adv20), 5)))\n```\n\n**Python Implementation:**\n```python\ndef alpha017(close, volume):\n    adv20 = volume.rolling(20).mean()\n    ts_rank_close = close.rolling(10).apply(lambda x: x.rank(pct=True).iloc[-1])\n    delta2_close = close.diff(1).diff(1)\n    vol_ratio = volume / adv20\n    ts_rank_vol = vol_ratio.rolling(5).apply(lambda x: x.rank(pct=True).iloc[-1])\n    return (-ts_rank_close.rank(pct=True)) * delta2_close.rank(pct=True) * ts_rank_vol.rank(pct=True)\n```\n\n**Citation:** Academic source"}
{"instruction": "When should I use Alpha002 in trading?", "input": "", "output": "**Alpha002** is used for: Negative correlation between volume change and intraday return\n\n**Formula:**\n```\n-1 * correlation(rank(delta(log(volume), 2)), rank((close - open) / open), 6)\n```\n\nUse this when you need to negative correlation between volume change and intraday return.\n\n**Citation:** Academic source"}
{"instruction": "How does Garman_Klass compare to other volatility estimators?", "input": "", "output": "**Garman_Klass**\n\nRange-based volatility estimator using OHLC\n\n**Formula:**\n```\nσ²_GK = 0.5 * (ln(H/L))² - (2*ln(2) - 1) * (ln(C/O))²\n```\n\n**Advantages:**\n- Specific use case for range-based volatility estimator using ohlc\n- Well-established in academic literature\n\n**Citation:** Garman, M.B. & Klass, M.J. (1980). Journal of Business"}
{"instruction": "When should I use Alpha010 in trading?", "input": "", "output": "**Alpha010** is used for: Ranked version of Alpha009 with 4-day window\n\n**Formula:**\n```\nrank((0 < ts_min(delta(close, 1), 4)) ? delta(close, 1) : ((ts_max(delta(close, 1), 4) < 0) ? delta(close, 1) : (-1 * delta(close, 1))))\n```\n\nUse this when you need to ranked version of alpha009 with 4-day window.\n\n**Citation:** Academic source"}
{"instruction": "When should I use VPIN in trading?", "input": "", "output": "**VPIN** is used for: Volume-Synchronized Probability of Informed Trading\n\n**Formula:**\n```\nVPIN = Σ|V_buy - V_sell| / (n * V_bucket)\n```\n\nUse this when you need to volume-synchronized probability of informed trading.\n\n**Citation:** Easley, D., López de Prado, M., & O'Hara, M. (2012). Review of Financial Studies"}
{"instruction": "What is the Effective_Spread formula?", "input": "", "output": "**Effective_Spread**\n\nActual execution cost relative to midpoint\n\n**Formula:**\n```\nES = 2 * |P_trade - M| / M\n```\n\n**Citation:** Goyenko, R.Y., Holden, C.W., & Trzcinka, C.A. (2009). Journal of Financial Economics"}
{"instruction": "Explain the components of Sharpe_Ratio.", "input": "", "output": "**Sharpe_Ratio**\n\nRisk-adjusted return per unit of volatility\n\n**Formula:**\n```\nSR = (R_p - R_f) / σ_p\n```\n\n**Components:**\n- R_p (portfolio return)\n- R_f (risk-free rate)\n- σ_p (portfolio std dev)\n\n**Citation:** Sharpe, W.F. (1966). Journal of Business"}
{"instruction": "Explain the components of DQN_Loss.", "input": "", "output": "**DQN_Loss**\n\nDeep Q-Network loss with target network\n\n**Formula:**\n```\nL = E[(r + γ * max_a' Q(s', a'; θ⁻) - Q(s, a; θ))²]\n```\n\n**Components:**\n- r (reward)\n- γ (discount)\n- Q (action-value)\n- θ⁻ (target params)\n\n**Citation:** Mnih, V. et al. (2015). Nature"}
{"instruction": "How do I implement LOB_Imbalance in Python?", "input": "", "output": "**LOB_Imbalance** - Normalized order book imbalance at best levels\n\n**Formula:**\n```\nImbalance = (Q_bid - Q_ask) / (Q_bid + Q_ask)\n```\n\n**Python Implementation:**\n```python\ndef lob_imbalance(bid_size, ask_size):\n    return (bid_size - ask_size) / (bid_size + ask_size)\n```\n\n**Citation:** Cont, R. et al. (2014). Journal of Financial Econometrics"}
{"instruction": "How do I implement Max_Drawdown in Python?", "input": "", "output": "**Max_Drawdown** - Largest peak-to-trough decline\n\n**Formula:**\n```\nMDD = max_t(max_{s≤t}(P_s) - P_t) / max_{s≤t}(P_s)\n```\n\n**Python Implementation:**\n```python\ndef max_drawdown(prices):\n    cumulative = prices / prices.iloc[0]\n    running_max = cumulative.expanding().max()\n    drawdown = (cumulative - running_max) / running_max\n    return drawdown.min()\n```\n\n**Citation:** Magdon-Ismail, M. & Atiya, A.F. (2004). Journal of Risk"}
{"instruction": "How do I implement VPIN in Python?", "input": "", "output": "**VPIN** - Volume-Synchronized Probability of Informed Trading\n\n**Formula:**\n```\nVPIN = Σ|V_buy - V_sell| / (n * V_bucket)\n```\n\n**Python Implementation:**\n```python\ndef vpin(volume, buy_volume, sell_volume, bucket_size, n_buckets=50):\n    imbalance = np.abs(buy_volume - sell_volume)\n    return imbalance.rolling(n_buckets).sum() / (n_buckets * bucket_size)\n```\n\n**Citation:** Easley, D., López de Prado, M., & O'Hara, M. (2012). Review of Financial Studies"}
{"instruction": "How do I implement Alpha018 in Python?", "input": "", "output": "**Alpha018** - Intraday volatility and correlation signal\n\n**Formula:**\n```\n-1 * rank(((stddev(abs((close - open)), 5) + (close - open)) + correlation(close, open, 10)))\n```\n\n**Python Implementation:**\n```python\ndef alpha018(open_price, close):\n    abs_diff = np.abs(close - open_price)\n    stddev_5 = abs_diff.rolling(5).std()\n    corr = close.rolling(10).corr(open_price)\n    return -(stddev_5 + (close - open_price) + corr).rank(pct=True)\n```\n\n**Citation:** Academic source"}
{"instruction": "How do I implement PIN in Python?", "input": "", "output": "**PIN** - Probability of Informed Trading\n\n**Formula:**\n```\nPIN = αμ / (αμ + ε_b + ε_s)\n```\n\n**Python Implementation:**\n```python\n# PIN requires MLE estimation - simplified proxy:\ndef pin_proxy(buy_volume, sell_volume, window=20):\n    imbalance = np.abs(buy_volume - sell_volume)\n    total = buy_volume + sell_volume\n    return imbalance.rolling(window).mean() / total.rolling(window).mean()\n```\n\n**Citation:** Easley, D., Kiefer, N., O'Hara, M. (1997). Journal of Finance"}
{"instruction": "How does Realized_Variance compare to other volatility estimators?", "input": "", "output": "**Realized_Variance**\n\nSum of squared intraday returns\n\n**Formula:**\n```\nRV_t = Σ(r_{t,i})² for i = 1 to n intraday returns\n```\n\n**Advantages:**\n- Specific use case for sum of squared intraday returns\n- Well-established in academic literature\n\n**Citation:** Andersen, T.G. & Bollerslev, T. (1998). International Economic Review"}
{"instruction": "What is the Max_Drawdown formula?", "input": "", "output": "**Max_Drawdown**\n\nLargest peak-to-trough decline\n\n**Formula:**\n```\nMDD = max_t(max_{s≤t}(P_s) - P_t) / max_{s≤t}(P_s)\n```\n\n**Citation:** Magdon-Ismail, M. & Atiya, A.F. (2004). Journal of Risk"}
{"instruction": "How do I implement Alpha007 in Python?", "input": "", "output": "**Alpha007** - Volume-conditioned momentum reversal\n\n**Formula:**\n```\n(adv20 < volume) ? ((-1 * ts_rank(abs(delta(close, 7)), 60)) * sign(delta(close, 7))) : -1\n```\n\n**Python Implementation:**\n```python\ndef alpha007(close, volume):\n    adv20 = volume.rolling(20).mean()\n    delta_close = close.diff(7)\n    ts_rank_val = np.abs(delta_close).rolling(60).apply(lambda x: x.rank(pct=True).iloc[-1])\n    signal = -ts_rank_val * np.sign(delta_close)\n    return np.where(adv20 < volume, signal, -1)\n```\n\n**Citation:** Academic source"}
{"instruction": "How do I implement VWAP in Python?", "input": "", "output": "**VWAP** - Volume-Weighted Average Price execution\n\n**Formula:**\n```\nTarget% = Historical_Volume% at each interval\n```\n\n**Python Implementation:**\n```python\ndef vwap_schedule(total_quantity, volume_profile):\n    volume_pct = volume_profile / volume_profile.sum()\n    return total_quantity * volume_pct\n```\n\n**Citation:** Madhavan, A. (2002). Financial Analysts Journal"}
{"instruction": "When should I use Information_Ratio in trading?", "input": "", "output": "**Information_Ratio** is used for: Active return per unit of tracking error\n\n**Formula:**\n```\nIR = (R_p - R_b) / σ(R_p - R_b)\n```\n\nUse this when you need to active return per unit of tracking error.\n\n**Citation:** Grinold, R.C. & Kahn, R.N. (2000). Active Portfolio Management"}
{"instruction": "What is the Alpha004 formula?", "input": "", "output": "**Alpha004**\n\nNegative time-series rank of cross-sectional low rank\n\n**Formula:**\n```\n-1 * Ts_Rank(rank(low), 9)\n```\n\n**Citation:** Academic source"}
{"instruction": "Explain the components of Kyle_Lambda.", "input": "", "output": "**Kyle_Lambda**\n\nMeasure of market depth and price impact\n\n**Formula:**\n```\nλ = ΔP / ΔQ (price impact per unit order flow)\n```\n\n**Components:**\n- ΔP (price change)\n- ΔQ (order flow imbalance)\n\n**Citation:** Kyle, A.S. (1985). Econometrica"}
{"instruction": "How does GARCH_11 compare to other volatility estimators?", "input": "", "output": "**GARCH_11**\n\nGeneralized Autoregressive Conditional Heteroskedasticity\n\n**Formula:**\n```\nσ²_t = ω + α * ε²_{t-1} + β * σ²_{t-1}\n```\n\n**Advantages:**\n- Specific use case for generalized autoregressive conditional heteroskedasticity\n- Well-established in academic literature\n\n**Citation:** Bollerslev, T. (1986). Journal of Econometrics"}
{"instruction": "How do I implement GARCH_11 in Python?", "input": "", "output": "**GARCH_11** - Generalized Autoregressive Conditional Heteroskedasticity\n\n**Formula:**\n```\nσ²_t = ω + α * ε²_{t-1} + β * σ²_{t-1}\n```\n\n**Python Implementation:**\n```python\nfrom arch import arch_model\ndef garch_forecast(returns):\n    model = arch_model(returns, vol='Garch', p=1, q=1)\n    result = model.fit(disp='off')\n    return result.conditional_volatility\n```\n\n**Citation:** Bollerslev, T. (1986). Journal of Econometrics"}
{"instruction": "Explain the components of Alpha006.", "input": "", "output": "**Alpha006**\n\nNegative correlation between open price and volume\n\n**Formula:**\n```\n-1 * correlation(open, volume, 10)\n```\n\n**Components:**\n- correlation\n- open\n- volume\n\n**Citation:** Academic source"}
{"instruction": "How do I implement PPO in Python?", "input": "", "output": "**PPO** - Proximal Policy Optimization with clipped objective\n\n**Formula:**\n```\nL_CLIP = E[min(r_t(θ)*A_t, clip(r_t(θ), 1-ε, 1+ε)*A_t)]\n```\n\n**Python Implementation:**\n```python\ndef ppo_loss(ratio, advantage, epsilon=0.2):\n    clipped_ratio = torch.clamp(ratio, 1 - epsilon, 1 + epsilon)\n    return -torch.min(ratio * advantage, clipped_ratio * advantage).mean()\n```\n\n**Citation:** Schulman, J. et al. (2017). arXiv:1707.06347"}
{"instruction": "Explain the components of PIN.", "input": "", "output": "**PIN**\n\nProbability of Informed Trading\n\n**Formula:**\n```\nPIN = αμ / (αμ + ε_b + ε_s)\n```\n\n**Components:**\n- α (prob of info event)\n- μ (arrival rate of informed)\n- ε (uninformed arrival)\n\n**Citation:** Easley, D., Kiefer, N., O'Hara, M. (1997). Journal of Finance"}
{"instruction": "What is the Alpha012 formula?", "input": "", "output": "**Alpha012**\n\nVolume-price divergence signal\n\n**Formula:**\n```\nsign(delta(volume, 1)) * (-1 * delta(close, 1))\n```\n\n**Citation:** Academic source"}
{"instruction": "How do I implement Roll_Spread in Python?", "input": "", "output": "**Roll_Spread** - Implied bid-ask spread from price autocovariance\n\n**Formula:**\n```\nSpread = 2 * sqrt(-Cov(Δp_t, Δp_{t-1}))\n```\n\n**Python Implementation:**\n```python\ndef roll_spread(price_changes, window=20):\n    cov = price_changes.rolling(window).cov(price_changes.shift(1))\n    return 2 * np.sqrt(np.maximum(-cov, 0))\n```\n\n**Citation:** Roll, R. (1984). Journal of Finance"}
{"instruction": "How do I implement Yang_Zhang in Python?", "input": "", "output": "**Yang_Zhang** - Combines overnight, close-to-close, and Rogers-Satchell\n\n**Formula:**\n```\nσ²_YZ = σ²_o + k*σ²_c + (1-k)*σ²_RS\n```\n\n**Python Implementation:**\n```python\ndef yang_zhang(open_price, high, low, close, window=20):\n    log_ho = np.log(high / open_price)\n    log_lo = np.log(low / open_price)\n    log_co = np.log(close / open_price)\n    rs = log_ho * (log_ho - log_co) + log_lo * (log_lo - log_co)\n    overnight = np.log(open_price / close.shift(1))**2\n    k = 0.34 / (1.34 + (window + 1) / (window - 1))\n    return overnight.rolling(window).mean() + k * log_co.rolling(window).var() + (1-k) * rs.rolling(window).mean()\n```\n\n**Citation:** Yang, D. & Zhang, Q. (2000). Journal of Business"}
{"instruction": "When should I use GRPO in trading?", "input": "", "output": "**GRPO** is used for: Group Relative Policy Optimization - no critic needed\n\n**Formula:**\n```\nA_i = (r_i - mean(r)) / std(r), L = -E[min(ρ*A, clip(ρ,1-ε,1+ε)*A)]\n```\n\nUse this when you need to group relative policy optimization - no critic needed.\n\n**Citation:** DeepSeek-AI (2025). DeepSeek-R1 Technical Report"}
{"instruction": "When should I use Alpha020 in trading?", "input": "", "output": "**Alpha020** is used for: Gap signal based on open vs previous OHLC\n\n**Formula:**\n```\n(((-1 * rank((open - delay(high, 1)))) * rank((open - delay(close, 1)))) * rank((open - delay(low, 1))))\n```\n\nUse this when you need to gap signal based on open vs previous ohlc.\n\n**Citation:** Academic source"}
{"instruction": "How does Yang_Zhang compare to other volatility estimators?", "input": "", "output": "**Yang_Zhang**\n\nCombines overnight, close-to-close, and Rogers-Satchell\n\n**Formula:**\n```\nσ²_YZ = σ²_o + k*σ²_c + (1-k)*σ²_RS\n```\n\n**Advantages:**\n- Specific use case for combines overnight, close-to-close, and rogers-satchell\n- Well-established in academic literature\n\n**Citation:** Yang, D. & Zhang, Q. (2000). Journal of Business"}
{"instruction": "What is the Trade_Imbalance formula?", "input": "", "output": "**Trade_Imbalance**\n\nNormalized buy-sell volume imbalance\n\n**Formula:**\n```\nTI = (V_buy - V_sell) / (V_buy + V_sell)\n```\n\n**Citation:** Chordia, T. & Subrahmanyam, A. (2004). Journal of Financial Economics"}
{"instruction": "When should I use LOB_Imbalance in trading?", "input": "", "output": "**LOB_Imbalance** is used for: Normalized order book imbalance at best levels\n\n**Formula:**\n```\nImbalance = (Q_bid - Q_ask) / (Q_bid + Q_ask)\n```\n\nUse this when you need to normalized order book imbalance at best levels.\n\n**Citation:** Cont, R. et al. (2014). Journal of Financial Econometrics"}
{"instruction": "Explain the components of SAC_Objective.", "input": "", "output": "**SAC_Objective**\n\nSoft Actor-Critic with entropy regularization\n\n**Formula:**\n```\nJ(π) = E[Σ_t γ^t (r_t + α * H(π(·|s_t)))]\n```\n\n**Components:**\n- r_t (reward)\n- H (entropy)\n- α (temperature)\n\n**Citation:** Haarnoja, T. et al. (2018). ICML"}
{"instruction": "How do I implement Sortino_Ratio in Python?", "input": "", "output": "**Sortino_Ratio** - Sharpe using only downside volatility\n\n**Formula:**\n```\nSortino = (R_p - R_f) / σ_downside\n```\n\n**Python Implementation:**\n```python\ndef sortino_ratio(returns, risk_free_rate=0, periods_per_year=252):\n    excess_returns = returns - risk_free_rate / periods_per_year\n    downside_returns = excess_returns[excess_returns < 0]\n    downside_std = downside_returns.std()\n    return np.sqrt(periods_per_year) * excess_returns.mean() / downside_std\n```\n\n**Citation:** Sortino, F.A. & van der Meer, R. (1991). Journal of Portfolio Management"}
{"instruction": "How do I implement Amihud_ILLIQ in Python?", "input": "", "output": "**Amihud_ILLIQ** - Price impact per dollar of trading volume\n\n**Formula:**\n```\nILLIQ = (1/D) * Σ|r_d| / V_d\n```\n\n**Python Implementation:**\n```python\ndef amihud_illiq(returns, dollar_volume, window=20):\n    return (np.abs(returns) / dollar_volume).rolling(window).mean()\n```\n\n**Citation:** Amihud, Y. (2002). Journal of Financial Markets"}
{"instruction": "How does Bipower_Variation compare to other volatility estimators?", "input": "", "output": "**Bipower_Variation**\n\nRobust to jumps, uses product of adjacent absolute returns\n\n**Formula:**\n```\nBV_t = (π/2) * Σ|r_{t,i}| * |r_{t,i-1}|\n```\n\n**Advantages:**\n- Specific use case for robust to jumps, uses product of adjacent absolute returns\n- Well-established in academic literature\n\n**Citation:** Barndorff-Nielsen, O.E. & Shephard, N. (2004). Journal of Financial Econometrics"}
{"instruction": "Explain the components of Roll_Spread.", "input": "", "output": "**Roll_Spread**\n\nImplied bid-ask spread from price autocovariance\n\n**Formula:**\n```\nSpread = 2 * sqrt(-Cov(Δp_t, Δp_{t-1}))\n```\n\n**Components:**\n- Δp_t (price change)\n- Cov (autocovariance)\n\n**Citation:** Roll, R. (1984). Journal of Finance"}
{"instruction": "When should I use CVaR in trading?", "input": "", "output": "**CVaR** is used for: Conditional VaR / Expected Shortfall\n\n**Formula:**\n```\nCVaR_α = E[L | L > VaR_α] = μ + σ * φ(Φ^{-1}(α)) / (1-α)\n```\n\nUse this when you need to conditional var / expected shortfall.\n\n**Citation:** Rockafellar, R.T. & Uryasev, S. (2000). Journal of Risk"}
{"instruction": "How does Rogers_Satchell compare to other volatility estimators?", "input": "", "output": "**Rogers_Satchell**\n\nRange-based estimator handling drift\n\n**Formula:**\n```\nσ²_RS = ln(H/C)*ln(H/O) + ln(L/C)*ln(L/O)\n```\n\n**Advantages:**\n- Specific use case for range-based estimator handling drift\n- Well-established in academic literature\n\n**Citation:** Rogers, L.C.G. & Satchell, S.E. (1991). Annals of Applied Probability"}
{"instruction": "How do I implement Alpha001 in Python?", "input": "", "output": "**Alpha001** - Conditional volatility-price signal with time-series argmax\n\n**Formula:**\n```\nrank(Ts_ArgMax(SignedPower(((returns < 0) ? stddev(returns, 20) : close), 2), 5)) - 0.5\n```\n\n**Python Implementation:**\n```python\ndef alpha001(close, returns):\n    condition = returns < 0\n    stddev_20 = returns.rolling(20).std()\n    inner = np.where(condition, stddev_20, close)\n    signed_power = np.sign(inner) * np.abs(inner) ** 2\n    argmax_5 = signed_power.rolling(5).apply(np.argmax)\n    return argmax_5.rank(pct=True) - 0.5\n```\n\n**Citation:** Academic source"}
{"instruction": "Explain the components of Alpha018.", "input": "", "output": "**Alpha018**\n\nIntraday volatility and correlation signal\n\n**Formula:**\n```\n-1 * rank(((stddev(abs((close - open)), 5) + (close - open)) + correlation(close, open, 10)))\n```\n\n**Components:**\n- rank\n- stddev\n- abs\n- correlation\n\n**Citation:** Academic source"}
{"instruction": "Explain the components of Alpha017.", "input": "", "output": "**Alpha017**\n\nPrice momentum with volume relative to average\n\n**Formula:**\n```\n(((-1 * rank(ts_rank(close, 10))) * rank(delta(delta(close, 1), 1))) * rank(ts_rank((volume / adv20), 5)))\n```\n\n**Components:**\n- rank\n- ts_rank\n- delta\n- adv20\n\n**Citation:** Academic source"}
{"instruction": "What is the Kyle_Lambda formula?", "input": "", "output": "**Kyle_Lambda**\n\nMeasure of market depth and price impact\n\n**Formula:**\n```\nλ = ΔP / ΔQ (price impact per unit order flow)\n```\n\n**Citation:** Kyle, A.S. (1985). Econometrica"}
{"instruction": "When should I use TD_Error in trading?", "input": "", "output": "**TD_Error** is used for: Temporal Difference error for value learning\n\n**Formula:**\n```\nδ_t = r_t + γ * V(s_{t+1}) - V(s_t)\n```\n\nUse this when you need to temporal difference error for value learning.\n\n**Citation:** Sutton, R.S. (1988). Machine Learning"}
{"instruction": "What is the Alpha020 formula?", "input": "", "output": "**Alpha020**\n\nGap signal based on open vs previous OHLC\n\n**Formula:**\n```\n(((-1 * rank((open - delay(high, 1)))) * rank((open - delay(close, 1)))) * rank((open - delay(low, 1))))\n```\n\n**Citation:** Academic source"}
{"instruction": "Explain the components of Alpha011.", "input": "", "output": "**Alpha011**\n\nVWAP deviation with volume momentum\n\n**Formula:**\n```\n((rank(ts_max((vwap - close), 3)) + rank(ts_min((vwap - close), 3))) * rank(delta(volume, 3)))\n```\n\n**Components:**\n- rank\n- ts_max\n- ts_min\n- delta\n- vwap\n\n**Citation:** Academic source"}
{"instruction": "How do I implement CVaR in Python?", "input": "", "output": "**CVaR** - Conditional VaR / Expected Shortfall\n\n**Formula:**\n```\nCVaR_α = E[L | L > VaR_α] = μ + σ * φ(Φ^{-1}(α)) / (1-α)\n```\n\n**Python Implementation:**\n```python\nfrom scipy.stats import norm\ndef cvar_parametric(returns, confidence=0.95):\n    mu = returns.mean()\n    sigma = returns.std()\n    var = var_parametric(returns, confidence)\n    return var + sigma * norm.pdf(norm.ppf(1 - confidence)) / (1 - confidence)\n```\n\n**Citation:** Rockafellar, R.T. & Uryasev, S. (2000). Journal of Risk"}
{"instruction": "Explain the components of PPO.", "input": "", "output": "**PPO**\n\nProximal Policy Optimization with clipped objective\n\n**Formula:**\n```\nL_CLIP = E[min(r_t(θ)*A_t, clip(r_t(θ), 1-ε, 1+ε)*A_t)]\n```\n\n**Components:**\n- r_t(θ) (prob ratio)\n- A_t (advantage)\n- ε (clip range, typically 0.2)\n\n**Citation:** Schulman, J. et al. (2017). arXiv:1707.06347"}
{"instruction": "When should I use Alpha012 in trading?", "input": "", "output": "**Alpha012** is used for: Volume-price divergence signal\n\n**Formula:**\n```\nsign(delta(volume, 1)) * (-1 * delta(close, 1))\n```\n\nUse this when you need to volume-price divergence signal.\n\n**Citation:** Academic source"}
{"instruction": "Explain the components of TD_Error.", "input": "", "output": "**TD_Error**\n\nTemporal Difference error for value learning\n\n**Formula:**\n```\nδ_t = r_t + γ * V(s_{t+1}) - V(s_t)\n```\n\n**Components:**\n- r_t (reward)\n- γ (discount)\n- V (value function)\n\n**Citation:** Sutton, R.S. (1988). Machine Learning"}
{"instruction": "What is the TWAP formula?", "input": "", "output": "**TWAP**\n\nTime-Weighted Average Price execution\n\n**Formula:**\n```\nTrade_size = Total_quantity / N (equal slices)\n```\n\n**Citation:** Berkowitz, S.A., Logue, D.E., & Noser, E.A. (1988). Journal of Finance"}
{"instruction": "What is the SAC_Objective formula?", "input": "", "output": "**SAC_Objective**\n\nSoft Actor-Critic with entropy regularization\n\n**Formula:**\n```\nJ(π) = E[Σ_t γ^t (r_t + α * H(π(·|s_t)))]\n```\n\n**Citation:** Haarnoja, T. et al. (2018). ICML"}
{"instruction": "When should I use Kelly_Criterion in trading?", "input": "", "output": "**Kelly_Criterion** is used for: Optimal fraction of capital to risk\n\n**Formula:**\n```\nf* = (p * b - q) / b = (p * W/L - (1-p)) / (W/L)\n```\n\nUse this when you need to optimal fraction of capital to risk.\n\n**Citation:** Kelly, J.L. (1956). Bell System Technical Journal"}
{"instruction": "When should I use Amihud_ILLIQ in trading?", "input": "", "output": "**Amihud_ILLIQ** is used for: Price impact per dollar of trading volume\n\n**Formula:**\n```\nILLIQ = (1/D) * Σ|r_d| / V_d\n```\n\nUse this when you need to price impact per dollar of trading volume.\n\n**Citation:** Amihud, Y. (2002). Journal of Financial Markets"}
{"instruction": "What is the Parkinson formula?", "input": "", "output": "**Parkinson**\n\nRange-based volatility using high-low range only\n\n**Formula:**\n```\nσ²_P = (ln(H/L))² / (4 * ln(2))\n```\n\n**Citation:** Parkinson, M. (1980). Journal of Business"}
{"instruction": "Explain the components of Alpha004.", "input": "", "output": "**Alpha004**\n\nNegative time-series rank of cross-sectional low rank\n\n**Formula:**\n```\n-1 * Ts_Rank(rank(low), 9)\n```\n\n**Components:**\n- Ts_Rank\n- rank\n- low\n\n**Citation:** Academic source"}
{"instruction": "Explain the components of Market_Impact_Linear.", "input": "", "output": "**Market_Impact_Linear**\n\nLinear + square-root market impact model\n\n**Formula:**\n```\nImpact = η * (Q / ADV) + γ * σ * sqrt(Q / ADV)\n```\n\n**Components:**\n- η (linear coef)\n- γ (sqrt coef)\n- Q (quantity)\n- ADV (avg daily vol)\n- σ (volatility)\n\n**Citation:** Almgren, R. et al. (2005). Risk Magazine"}
{"instruction": "How do I implement SAC_Objective in Python?", "input": "", "output": "**SAC_Objective** - Soft Actor-Critic with entropy regularization\n\n**Formula:**\n```\nJ(π) = E[Σ_t γ^t (r_t + α * H(π(·|s_t)))]\n```\n\n**Python Implementation:**\n```python\ndef sac_actor_loss(log_probs, q_values, alpha):\n    return (alpha * log_probs - q_values).mean()\n```\n\n**Citation:** Haarnoja, T. et al. (2018). ICML"}
{"instruction": "How do I implement GJR_GARCH in Python?", "input": "", "output": "**GJR_GARCH** - GJR-GARCH with leverage effect (I=1 if ε<0)\n\n**Formula:**\n```\nσ²_t = ω + (α + γ * I_{t-1}) * ε²_{t-1} + β * σ²_{t-1}\n```\n\n**Python Implementation:**\n```python\nfrom arch import arch_model\ndef gjr_garch_forecast(returns):\n    model = arch_model(returns, vol='Garch', p=1, o=1, q=1)  # o=1 for GJR\n    result = model.fit(disp='off')\n    return result.conditional_volatility\n```\n\n**Citation:** Glosten, Jagannathan, Runkle (1993). Journal of Finance"}
{"instruction": "Explain the components of Calmar_Ratio.", "input": "", "output": "**Calmar_Ratio**\n\nAnnual return divided by maximum drawdown\n\n**Formula:**\n```\nCalmar = R_annual / Max_Drawdown\n```\n\n**Components:**\n- R_annual (annualized return)\n- Max_Drawdown\n\n**Citation:** Young, T.W. (1991). Futures Magazine"}
{"instruction": "When should I use Alpha016 in trading?", "input": "", "output": "**Alpha016** is used for: Negative covariance of high and volume ranks\n\n**Formula:**\n```\n-1 * rank(covariance(rank(high), rank(volume), 5))\n```\n\nUse this when you need to negative covariance of high and volume ranks.\n\n**Citation:** Academic source"}
{"instruction": "Explain the components of Alpha008.", "input": "", "output": "**Alpha008**\n\nMomentum of open-return product\n\n**Formula:**\n```\n-1 * rank(((sum(open, 5) * sum(returns, 5)) - delay((sum(open, 5) * sum(returns, 5)), 10)))\n```\n\n**Components:**\n- rank\n- sum\n- delay\n\n**Citation:** Academic source"}
{"instruction": "What is the CVaR formula?", "input": "", "output": "**CVaR**\n\nConditional VaR / Expected Shortfall\n\n**Formula:**\n```\nCVaR_α = E[L | L > VaR_α] = μ + σ * φ(Φ^{-1}(α)) / (1-α)\n```\n\n**Citation:** Rockafellar, R.T. & Uryasev, S. (2000). Journal of Risk"}
{"instruction": "What is the Microprice formula?", "input": "", "output": "**Microprice**\n\nSize-weighted mid price reflecting order book imbalance\n\n**Formula:**\n```\nP_micro = P_ask * (Q_bid / (Q_bid + Q_ask)) + P_bid * (Q_ask / (Q_bid + Q_ask))\n```\n\n**Citation:** Gatheral, J. & Oomen, R.C.A. (2010). Quantitative Finance"}
{"instruction": "Explain the components of EGARCH.", "input": "", "output": "**EGARCH**\n\nExponential GARCH capturing asymmetric volatility\n\n**Formula:**\n```\nlog(σ²_t) = ω + α * (|z_{t-1}| - E|z|) + γ * z_{t-1} + β * log(σ²_{t-1})\n```\n\n**Components:**\n- ω\n- α (magnitude)\n- γ (leverage)\n- β (persistence)\n- z (standardized residual)\n\n**Citation:** Nelson, D.B. (1991). Econometrica"}
{"instruction": "Explain the components of Garman_Klass.", "input": "", "output": "**Garman_Klass**\n\nRange-based volatility estimator using OHLC\n\n**Formula:**\n```\nσ²_GK = 0.5 * (ln(H/L))² - (2*ln(2) - 1) * (ln(C/O))²\n```\n\n**Components:**\n- H (high)\n- L (low)\n- C (close)\n- O (open)\n\n**Citation:** Garman, M.B. & Klass, M.J. (1980). Journal of Business"}
{"instruction": "What is the Alpha013 formula?", "input": "", "output": "**Alpha013**\n\nNegative covariance of price and volume ranks\n\n**Formula:**\n```\n-1 * rank(covariance(rank(close), rank(volume), 5))\n```\n\n**Citation:** Academic source"}
{"instruction": "When should I use Calmar_Ratio in trading?", "input": "", "output": "**Calmar_Ratio** is used for: Annual return divided by maximum drawdown\n\n**Formula:**\n```\nCalmar = R_annual / Max_Drawdown\n```\n\nUse this when you need to annual return divided by maximum drawdown.\n\n**Citation:** Young, T.W. (1991). Futures Magazine"}
{"instruction": "What is the Bipower_Variation formula?", "input": "", "output": "**Bipower_Variation**\n\nRobust to jumps, uses product of adjacent absolute returns\n\n**Formula:**\n```\nBV_t = (π/2) * Σ|r_{t,i}| * |r_{t,i-1}|\n```\n\n**Citation:** Barndorff-Nielsen, O.E. & Shephard, N. (2004). Journal of Financial Econometrics"}
{"instruction": "When should I use Alpha009 in trading?", "input": "", "output": "**Alpha009** is used for: Trend-following with momentum conditions\n\n**Formula:**\n```\n(0 < ts_min(delta(close, 1), 5)) ? delta(close, 1) : ((ts_max(delta(close, 1), 5) < 0) ? delta(close, 1) : (-1 * delta(close, 1)))\n```\n\nUse this when you need to trend-following with momentum conditions.\n\n**Citation:** Academic source"}
{"instruction": "When should I use Alpha017 in trading?", "input": "", "output": "**Alpha017** is used for: Price momentum with volume relative to average\n\n**Formula:**\n```\n(((-1 * rank(ts_rank(close, 10))) * rank(delta(delta(close, 1), 1))) * rank(ts_rank((volume / adv20), 5)))\n```\n\nUse this when you need to price momentum with volume relative to average.\n\n**Citation:** Academic source"}
{"instruction": "Explain the components of Alpha020.", "input": "", "output": "**Alpha020**\n\nGap signal based on open vs previous OHLC\n\n**Formula:**\n```\n(((-1 * rank((open - delay(high, 1)))) * rank((open - delay(close, 1)))) * rank((open - delay(low, 1))))\n```\n\n**Components:**\n- rank\n- delay\n\n**Citation:** Academic source"}
{"instruction": "Explain the components of Yang_Zhang.", "input": "", "output": "**Yang_Zhang**\n\nCombines overnight, close-to-close, and Rogers-Satchell\n\n**Formula:**\n```\nσ²_YZ = σ²_o + k*σ²_c + (1-k)*σ²_RS\n```\n\n**Components:**\n- σ²_o (overnight)\n- σ²_c (close-to-close)\n- σ²_RS\n- k (weighting)\n\n**Citation:** Yang, D. & Zhang, Q. (2000). Journal of Business"}
{"instruction": "When should I use Bipower_Variation in trading?", "input": "", "output": "**Bipower_Variation** is used for: Robust to jumps, uses product of adjacent absolute returns\n\n**Formula:**\n```\nBV_t = (π/2) * Σ|r_{t,i}| * |r_{t,i-1}|\n```\n\nUse this when you need to robust to jumps, uses product of adjacent absolute returns.\n\n**Citation:** Barndorff-Nielsen, O.E. & Shephard, N. (2004). Journal of Financial Econometrics"}
{"instruction": "How do I implement Implementation_Shortfall in Python?", "input": "", "output": "**Implementation_Shortfall** - Cost of execution vs decision price\n\n**Formula:**\n```\nIS = (P_exec - P_decision) * Q / (P_decision * Q)\n```\n\n**Python Implementation:**\n```python\ndef implementation_shortfall(exec_price, decision_price, quantity):\n    return (exec_price - decision_price) * quantity / (decision_price * quantity)\n```\n\n**Citation:** Perold, A.F. (1988). Financial Analysts Journal"}
{"instruction": "When should I use OFI in trading?", "input": "", "output": "**OFI** is used for: Order Flow Imbalance - measures queue changes\n\n**Formula:**\n```\nOFI_t = ΔB_t * I(P^b_t ≥ P^b_{t-1}) - ΔA_t * I(P^a_t ≤ P^a_{t-1})\n```\n\nUse this when you need to order flow imbalance - measures queue changes.\n\n**Citation:** Cont, R., Kukanov, A., & Stoikov, S. (2014). Journal of Financial Econometrics"}
{"instruction": "What is the HAR_RV formula?", "input": "", "output": "**HAR_RV**\n\nHeterogeneous Autoregressive Realized Volatility model\n\n**Formula:**\n```\nRV_{t+1} = β₀ + β_d * RV_d + β_w * RV_w + β_m * RV_m + ε_{t+1}\n```\n\n**Citation:** Corsi, F. (2009). Journal of Financial Econometrics"}
{"instruction": "What is the Alpha002 formula?", "input": "", "output": "**Alpha002**\n\nNegative correlation between volume change and intraday return\n\n**Formula:**\n```\n-1 * correlation(rank(delta(log(volume), 2)), rank((close - open) / open), 6)\n```\n\n**Citation:** Academic source"}
{"instruction": "What is the Yang_Zhang formula?", "input": "", "output": "**Yang_Zhang**\n\nCombines overnight, close-to-close, and Rogers-Satchell\n\n**Formula:**\n```\nσ²_YZ = σ²_o + k*σ²_c + (1-k)*σ²_RS\n```\n\n**Citation:** Yang, D. & Zhang, Q. (2000). Journal of Business"}
{"instruction": "What is the Alpha018 formula?", "input": "", "output": "**Alpha018**\n\nIntraday volatility and correlation signal\n\n**Formula:**\n```\n-1 * rank(((stddev(abs((close - open)), 5) + (close - open)) + correlation(close, open, 10)))\n```\n\n**Citation:** Academic source"}
{"instruction": "Explain the components of Implementation_Shortfall.", "input": "", "output": "**Implementation_Shortfall**\n\nCost of execution vs decision price\n\n**Formula:**\n```\nIS = (P_exec - P_decision) * Q / (P_decision * Q)\n```\n\n**Components:**\n- P_exec (execution price)\n- P_decision (decision price)\n- Q (quantity)\n\n**Citation:** Perold, A.F. (1988). Financial Analysts Journal"}
{"instruction": "How does HAR_RV compare to other volatility estimators?", "input": "", "output": "**HAR_RV**\n\nHeterogeneous Autoregressive Realized Volatility model\n\n**Formula:**\n```\nRV_{t+1} = β₀ + β_d * RV_d + β_w * RV_w + β_m * RV_m + ε_{t+1}\n```\n\n**Advantages:**\n- Specific use case for heterogeneous autoregressive realized volatility model\n- Well-established in academic literature\n\n**Citation:** Corsi, F. (2009). Journal of Financial Econometrics"}
{"instruction": "What is the Alpha003 formula?", "input": "", "output": "**Alpha003**\n\nNegative correlation between open price rank and volume rank\n\n**Formula:**\n```\n-1 * correlation(rank(open), rank(volume), 10)\n```\n\n**Citation:** Academic source"}
{"instruction": "Explain the components of Alpha015.", "input": "", "output": "**Alpha015**\n\nRolling sum of high-volume correlation ranks\n\n**Formula:**\n```\n-1 * sum(rank(correlation(rank(high), rank(volume), 3)), 3)\n```\n\n**Components:**\n- sum\n- rank\n- correlation\n\n**Citation:** Academic source"}
{"instruction": "When should I use TWAP in trading?", "input": "", "output": "**TWAP** is used for: Time-Weighted Average Price execution\n\n**Formula:**\n```\nTrade_size = Total_quantity / N (equal slices)\n```\n\nUse this when you need to time-weighted average price execution.\n\n**Citation:** Berkowitz, S.A., Logue, D.E., & Noser, E.A. (1988). Journal of Finance"}
{"instruction": "How do I implement Alpha004 in Python?", "input": "", "output": "**Alpha004** - Negative time-series rank of cross-sectional low rank\n\n**Formula:**\n```\n-1 * Ts_Rank(rank(low), 9)\n```\n\n**Python Implementation:**\n```python\ndef alpha004(low):\n    return -low.rank(pct=True).rolling(9).apply(lambda x: x.rank(pct=True).iloc[-1])\n```\n\n**Citation:** Academic source"}
{"instruction": "What is the Alpha015 formula?", "input": "", "output": "**Alpha015**\n\nRolling sum of high-volume correlation ranks\n\n**Formula:**\n```\n-1 * sum(rank(correlation(rank(high), rank(volume), 3)), 3)\n```\n\n**Citation:** Academic source"}
{"instruction": "What is the Alpha005 formula?", "input": "", "output": "**Alpha005**\n\nOpen vs VWAP deviation signal\n\n**Formula:**\n```\nrank(open - (sum(vwap, 10) / 10)) * (-1 * abs(rank(close - vwap)))\n```\n\n**Citation:** Academic source"}
{"instruction": "Explain the components of Alpha001.", "input": "", "output": "**Alpha001**\n\nConditional volatility-price signal with time-series argmax\n\n**Formula:**\n```\nrank(Ts_ArgMax(SignedPower(((returns < 0) ? stddev(returns, 20) : close), 2), 5)) - 0.5\n```\n\n**Components:**\n- returns\n- stddev(returns, 20)\n- close\n- SignedPower\n- Ts_ArgMax\n- rank\n\n**Citation:** Academic source"}
{"instruction": "What is the Information_Ratio formula?", "input": "", "output": "**Information_Ratio**\n\nActive return per unit of tracking error\n\n**Formula:**\n```\nIR = (R_p - R_b) / σ(R_p - R_b)\n```\n\n**Citation:** Grinold, R.C. & Kahn, R.N. (2000). Active Portfolio Management"}
{"instruction": "When should I use Alpha005 in trading?", "input": "", "output": "**Alpha005** is used for: Open vs VWAP deviation signal\n\n**Formula:**\n```\nrank(open - (sum(vwap, 10) / 10)) * (-1 * abs(rank(close - vwap)))\n```\n\nUse this when you need to open vs vwap deviation signal.\n\n**Citation:** Academic source"}
{"instruction": "How do I implement Alpha011 in Python?", "input": "", "output": "**Alpha011** - VWAP deviation with volume momentum\n\n**Formula:**\n```\n((rank(ts_max((vwap - close), 3)) + rank(ts_min((vwap - close), 3))) * rank(delta(volume, 3)))\n```\n\n**Python Implementation:**\n```python\ndef alpha011(close, volume, vwap):\n    vwap_diff = vwap - close\n    ts_max_3 = vwap_diff.rolling(3).max().rank(pct=True)\n    ts_min_3 = vwap_diff.rolling(3).min().rank(pct=True)\n    vol_delta = volume.diff(3).rank(pct=True)\n    return (ts_max_3 + ts_min_3) * vol_delta\n```\n\n**Citation:** Academic source"}
{"instruction": "Explain the components of Alpha016.", "input": "", "output": "**Alpha016**\n\nNegative covariance of high and volume ranks\n\n**Formula:**\n```\n-1 * rank(covariance(rank(high), rank(volume), 5))\n```\n\n**Components:**\n- rank\n- covariance\n\n**Citation:** Academic source"}
{"instruction": "What is the Calmar_Ratio formula?", "input": "", "output": "**Calmar_Ratio**\n\nAnnual return divided by maximum drawdown\n\n**Formula:**\n```\nCalmar = R_annual / Max_Drawdown\n```\n\n**Citation:** Young, T.W. (1991). Futures Magazine"}
{"instruction": "How does GJR_GARCH compare to other volatility estimators?", "input": "", "output": "**GJR_GARCH**\n\nGJR-GARCH with leverage effect (I=1 if ε<0)\n\n**Formula:**\n```\nσ²_t = ω + (α + γ * I_{t-1}) * ε²_{t-1} + β * σ²_{t-1}\n```\n\n**Advantages:**\n- Specific use case for gjr-garch with leverage effect (i=1 if ε<0)\n- Well-established in academic literature\n\n**Citation:** Glosten, Jagannathan, Runkle (1993). Journal of Finance"}
{"instruction": "When should I use PIN in trading?", "input": "", "output": "**PIN** is used for: Probability of Informed Trading\n\n**Formula:**\n```\nPIN = αμ / (αμ + ε_b + ε_s)\n```\n\nUse this when you need to probability of informed trading.\n\n**Citation:** Easley, D., Kiefer, N., O'Hara, M. (1997). Journal of Finance"}
{"instruction": "When should I use Garman_Klass in trading?", "input": "", "output": "**Garman_Klass** is used for: Range-based volatility estimator using OHLC\n\n**Formula:**\n```\nσ²_GK = 0.5 * (ln(H/L))² - (2*ln(2) - 1) * (ln(C/O))²\n```\n\nUse this when you need to range-based volatility estimator using ohlc.\n\n**Citation:** Garman, M.B. & Klass, M.J. (1980). Journal of Business"}
{"instruction": "When should I use Market_Impact_Linear in trading?", "input": "", "output": "**Market_Impact_Linear** is used for: Linear + square-root market impact model\n\n**Formula:**\n```\nImpact = η * (Q / ADV) + γ * σ * sqrt(Q / ADV)\n```\n\nUse this when you need to linear + square-root market impact model.\n\n**Citation:** Almgren, R. et al. (2005). Risk Magazine"}
{"instruction": "What is the VPIN formula?", "input": "", "output": "**VPIN**\n\nVolume-Synchronized Probability of Informed Trading\n\n**Formula:**\n```\nVPIN = Σ|V_buy - V_sell| / (n * V_bucket)\n```\n\n**Citation:** Easley, D., López de Prado, M., & O'Hara, M. (2012). Review of Financial Studies"}
{"instruction": "Explain the components of Effective_Spread.", "input": "", "output": "**Effective_Spread**\n\nActual execution cost relative to midpoint\n\n**Formula:**\n```\nES = 2 * |P_trade - M| / M\n```\n\n**Components:**\n- P_trade (trade price)\n- M (midpoint price)\n\n**Citation:** Goyenko, R.Y., Holden, C.W., & Trzcinka, C.A. (2009). Journal of Financial Economics"}
{"instruction": "What is the Sharpe_Ratio formula?", "input": "", "output": "**Sharpe_Ratio**\n\nRisk-adjusted return per unit of volatility\n\n**Formula:**\n```\nSR = (R_p - R_f) / σ_p\n```\n\n**Citation:** Sharpe, W.F. (1966). Journal of Business"}
{"instruction": "When should I use Alpha007 in trading?", "input": "", "output": "**Alpha007** is used for: Volume-conditioned momentum reversal\n\n**Formula:**\n```\n(adv20 < volume) ? ((-1 * ts_rank(abs(delta(close, 7)), 60)) * sign(delta(close, 7))) : -1\n```\n\nUse this when you need to volume-conditioned momentum reversal.\n\n**Citation:** Academic source"}
{"instruction": "What is the Garman_Klass formula?", "input": "", "output": "**Garman_Klass**\n\nRange-based volatility estimator using OHLC\n\n**Formula:**\n```\nσ²_GK = 0.5 * (ln(H/L))² - (2*ln(2) - 1) * (ln(C/O))²\n```\n\n**Citation:** Garman, M.B. & Klass, M.J. (1980). Journal of Business"}
{"instruction": "How do I implement Alpha014 in Python?", "input": "", "output": "**Alpha014** - Return momentum with open-volume correlation\n\n**Formula:**\n```\n((-1 * rank(delta(returns, 3))) * correlation(open, volume, 10))\n```\n\n**Python Implementation:**\n```python\ndef alpha014(open_price, returns, volume):\n    ret_delta = -returns.diff(3).rank(pct=True)\n    corr = open_price.rolling(10).corr(volume)\n    return ret_delta * corr\n```\n\n**Citation:** Academic source"}
{"instruction": "How do I implement GAE in Python?", "input": "", "output": "**GAE** - Generalized Advantage Estimation\n\n**Formula:**\n```\nA_t^GAE = Σ_{l=0}^{∞} (γλ)^l * δ_{t+l}\n```\n\n**Python Implementation:**\n```python\ndef compute_gae(rewards, values, gamma=0.99, lam=0.95):\n    advantages = []\n    gae = 0\n    for t in reversed(range(len(rewards) - 1)):\n        delta = rewards[t] + gamma * values[t+1] - values[t]\n        gae = delta + gamma * lam * gae\n        advantages.insert(0, gae)\n    return advantages\n```\n\n**Citation:** Schulman, J. et al. (2015). arXiv:1506.02438"}
{"instruction": "What is the Implementation_Shortfall formula?", "input": "", "output": "**Implementation_Shortfall**\n\nCost of execution vs decision price\n\n**Formula:**\n```\nIS = (P_exec - P_decision) * Q / (P_decision * Q)\n```\n\n**Citation:** Perold, A.F. (1988). Financial Analysts Journal"}
{"instruction": "Explain the components of GJR_GARCH.", "input": "", "output": "**GJR_GARCH**\n\nGJR-GARCH with leverage effect (I=1 if ε<0)\n\n**Formula:**\n```\nσ²_t = ω + (α + γ * I_{t-1}) * ε²_{t-1} + β * σ²_{t-1}\n```\n\n**Components:**\n- ω\n- α\n- γ (leverage)\n- β\n- I (indicator for negative shock)\n\n**Citation:** Glosten, Jagannathan, Runkle (1993). Journal of Finance"}
{"instruction": "What is the Avellaneda_Stoikov formula?", "input": "", "output": "**Avellaneda_Stoikov**\n\nOptimal market making quotes\n\n**Formula:**\n```\nδ = (1/γ) * ln(1 + γ/k), r = s - q*γ*σ²*(T-t)\n```\n\n**Citation:** Avellaneda, M. & Stoikov, S. (2008). Quantitative Finance"}
{"instruction": "Explain the components of GRPO.", "input": "", "output": "**GRPO**\n\nGroup Relative Policy Optimization - no critic needed\n\n**Formula:**\n```\nA_i = (r_i - mean(r)) / std(r), L = -E[min(ρ*A, clip(ρ,1-ε,1+ε)*A)]\n```\n\n**Components:**\n- r_i (reward)\n- ρ (importance ratio)\n- A (advantage)\n- ε (clip param)\n\n**Citation:** DeepSeek-AI (2025). DeepSeek-R1 Technical Report"}
{"instruction": "What is the Sortino_Ratio formula?", "input": "", "output": "**Sortino_Ratio**\n\nSharpe using only downside volatility\n\n**Formula:**\n```\nSortino = (R_p - R_f) / σ_downside\n```\n\n**Citation:** Sortino, F.A. & van der Meer, R. (1991). Journal of Portfolio Management"}
{"instruction": "Explain the components of Microprice.", "input": "", "output": "**Microprice**\n\nSize-weighted mid price reflecting order book imbalance\n\n**Formula:**\n```\nP_micro = P_ask * (Q_bid / (Q_bid + Q_ask)) + P_bid * (Q_ask / (Q_bid + Q_ask))\n```\n\n**Components:**\n- P_ask\n- P_bid\n- Q_bid (bid size)\n- Q_ask (ask size)\n\n**Citation:** Gatheral, J. & Oomen, R.C.A. (2010). Quantitative Finance"}
{"instruction": "What is the Market_Impact_Linear formula?", "input": "", "output": "**Market_Impact_Linear**\n\nLinear + square-root market impact model\n\n**Formula:**\n```\nImpact = η * (Q / ADV) + γ * σ * sqrt(Q / ADV)\n```\n\n**Citation:** Almgren, R. et al. (2005). Risk Magazine"}
{"instruction": "When should I use Almgren_Chriss in trading?", "input": "", "output": "**Almgren_Chriss** is used for: Optimal execution trajectory minimizing cost + variance\n\n**Formula:**\n```\nn_j = (X_0/N) * sinh(κ*(T-t_j)) / sinh(κ*T)\n```\n\nUse this when you need to optimal execution trajectory minimizing cost + variance.\n\n**Citation:** Almgren, R. & Chriss, N. (2001). Journal of Risk"}
{"instruction": "When should I use Alpha003 in trading?", "input": "", "output": "**Alpha003** is used for: Negative correlation between open price rank and volume rank\n\n**Formula:**\n```\n-1 * correlation(rank(open), rank(volume), 10)\n```\n\nUse this when you need to negative correlation between open price rank and volume rank.\n\n**Citation:** Academic source"}
{"instruction": "How do I implement Alpha006 in Python?", "input": "", "output": "**Alpha006** - Negative correlation between open price and volume\n\n**Formula:**\n```\n-1 * correlation(open, volume, 10)\n```\n\n**Python Implementation:**\n```python\ndef alpha006(open_price, volume):\n    return -open_price.rolling(10).corr(volume)\n```\n\n**Citation:** Academic source"}
{"instruction": "How do I implement Avellaneda_Stoikov in Python?", "input": "", "output": "**Avellaneda_Stoikov** - Optimal market making quotes\n\n**Formula:**\n```\nδ = (1/γ) * ln(1 + γ/k), r = s - q*γ*σ²*(T-t)\n```\n\n**Python Implementation:**\n```python\ndef avellaneda_stoikov(mid_price, inventory, volatility, gamma, k, T_remaining):\n    reservation = mid_price - inventory * gamma * volatility**2 * T_remaining\n    spread = (2 / gamma) * np.log(1 + gamma / k)\n    bid = reservation - spread / 2\n    ask = reservation + spread / 2\n    return bid, ask\n```\n\n**Citation:** Avellaneda, M. & Stoikov, S. (2008). Quantitative Finance"}
{"instruction": "How do I implement VaR in Python?", "input": "", "output": "**VaR** - Value at Risk - maximum loss at confidence level\n\n**Formula:**\n```\nVaR_α = -inf{x : P(L ≤ x) ≥ α} = μ + σ * Φ^{-1}(α)\n```\n\n**Python Implementation:**\n```python\nfrom scipy.stats import norm\ndef var_parametric(returns, confidence=0.95):\n    mu = returns.mean()\n    sigma = returns.std()\n    return -(mu + sigma * norm.ppf(1 - confidence))\n```\n\n**Citation:** Jorion, P. (2006). Value at Risk"}
{"instruction": "How do I implement Alpha010 in Python?", "input": "", "output": "**Alpha010** - Ranked version of Alpha009 with 4-day window\n\n**Formula:**\n```\nrank((0 < ts_min(delta(close, 1), 4)) ? delta(close, 1) : ((ts_max(delta(close, 1), 4) < 0) ? delta(close, 1) : (-1 * delta(close, 1))))\n```\n\n**Python Implementation:**\n```python\ndef alpha010(close):\n    delta_close = close.diff(1)\n    ts_min_4 = delta_close.rolling(4).min()\n    ts_max_4 = delta_close.rolling(4).max()\n    inner = np.where(ts_min_4 > 0, delta_close,\n            np.where(ts_max_4 < 0, delta_close, -delta_close))\n    return pd.Series(inner).rank(pct=True)\n```\n\n**Citation:** Academic source"}
{"instruction": "When should I use Alpha011 in trading?", "input": "", "output": "**Alpha011** is used for: VWAP deviation with volume momentum\n\n**Formula:**\n```\n((rank(ts_max((vwap - close), 3)) + rank(ts_min((vwap - close), 3))) * rank(delta(volume, 3)))\n```\n\nUse this when you need to vwap deviation with volume momentum.\n\n**Citation:** Academic source"}
{"instruction": "Explain the components of Alpha005.", "input": "", "output": "**Alpha005**\n\nOpen vs VWAP deviation signal\n\n**Formula:**\n```\nrank(open - (sum(vwap, 10) / 10)) * (-1 * abs(rank(close - vwap)))\n```\n\n**Components:**\n- rank\n- sum\n- vwap\n- abs\n\n**Citation:** Academic source"}
{"instruction": "When should I use SAC_Objective in trading?", "input": "", "output": "**SAC_Objective** is used for: Soft Actor-Critic with entropy regularization\n\n**Formula:**\n```\nJ(π) = E[Σ_t γ^t (r_t + α * H(π(·|s_t)))]\n```\n\nUse this when you need to soft actor-critic with entropy regularization.\n\n**Citation:** Haarnoja, T. et al. (2018). ICML"}
{"instruction": "Explain the components of Alpha014.", "input": "", "output": "**Alpha014**\n\nReturn momentum with open-volume correlation\n\n**Formula:**\n```\n((-1 * rank(delta(returns, 3))) * correlation(open, volume, 10))\n```\n\n**Components:**\n- rank\n- delta\n- correlation\n\n**Citation:** Academic source"}
{"instruction": "Explain the components of Information_Ratio.", "input": "", "output": "**Information_Ratio**\n\nActive return per unit of tracking error\n\n**Formula:**\n```\nIR = (R_p - R_b) / σ(R_p - R_b)\n```\n\n**Components:**\n- R_p (portfolio)\n- R_b (benchmark)\n- σ (tracking error)\n\n**Citation:** Grinold, R.C. & Kahn, R.N. (2000). Active Portfolio Management"}
{"instruction": "Explain the components of Alpha009.", "input": "", "output": "**Alpha009**\n\nTrend-following with momentum conditions\n\n**Formula:**\n```\n(0 < ts_min(delta(close, 1), 5)) ? delta(close, 1) : ((ts_max(delta(close, 1), 5) < 0) ? delta(close, 1) : (-1 * delta(close, 1)))\n```\n\n**Components:**\n- ts_min\n- ts_max\n- delta\n\n**Citation:** Academic source"}
{"instruction": "What is the GJR_GARCH formula?", "input": "", "output": "**GJR_GARCH**\n\nGJR-GARCH with leverage effect (I=1 if ε<0)\n\n**Formula:**\n```\nσ²_t = ω + (α + γ * I_{t-1}) * ε²_{t-1} + β * σ²_{t-1}\n```\n\n**Citation:** Glosten, Jagannathan, Runkle (1993). Journal of Finance"}
{"instruction": "How do I implement Garman_Klass in Python?", "input": "", "output": "**Garman_Klass** - Range-based volatility estimator using OHLC\n\n**Formula:**\n```\nσ²_GK = 0.5 * (ln(H/L))² - (2*ln(2) - 1) * (ln(C/O))²\n```\n\n**Python Implementation:**\n```python\ndef garman_klass(high, low, close, open_price):\n    log_hl = np.log(high / low)\n    log_co = np.log(close / open_price)\n    return 0.5 * log_hl**2 - (2*np.log(2) - 1) * log_co**2\n```\n\n**Citation:** Garman, M.B. & Klass, M.J. (1980). Journal of Business"}
{"instruction": "Explain the components of OFI.", "input": "", "output": "**OFI**\n\nOrder Flow Imbalance - measures queue changes\n\n**Formula:**\n```\nOFI_t = ΔB_t * I(P^b_t ≥ P^b_{t-1}) - ΔA_t * I(P^a_t ≤ P^a_{t-1})\n```\n\n**Components:**\n- ΔB (bid size change)\n- ΔA (ask size change)\n- I (indicator function)\n\n**Citation:** Cont, R., Kukanov, A., & Stoikov, S. (2014). Journal of Financial Econometrics"}
{"instruction": "What is the Alpha006 formula?", "input": "", "output": "**Alpha006**\n\nNegative correlation between open price and volume\n\n**Formula:**\n```\n-1 * correlation(open, volume, 10)\n```\n\n**Citation:** Academic source"}
{"instruction": "When should I use Alpha013 in trading?", "input": "", "output": "**Alpha013** is used for: Negative covariance of price and volume ranks\n\n**Formula:**\n```\n-1 * rank(covariance(rank(close), rank(volume), 5))\n```\n\nUse this when you need to negative covariance of price and volume ranks.\n\n**Citation:** Academic source"}
{"instruction": "Explain the components of Alpha012.", "input": "", "output": "**Alpha012**\n\nVolume-price divergence signal\n\n**Formula:**\n```\nsign(delta(volume, 1)) * (-1 * delta(close, 1))\n```\n\n**Components:**\n- sign\n- delta\n\n**Citation:** Academic source"}
{"instruction": "What is the LOB_Imbalance formula?", "input": "", "output": "**LOB_Imbalance**\n\nNormalized order book imbalance at best levels\n\n**Formula:**\n```\nImbalance = (Q_bid - Q_ask) / (Q_bid + Q_ask)\n```\n\n**Citation:** Cont, R. et al. (2014). Journal of Financial Econometrics"}
{"instruction": "What is the Alpha001 formula?", "input": "", "output": "**Alpha001**\n\nConditional volatility-price signal with time-series argmax\n\n**Formula:**\n```\nrank(Ts_ArgMax(SignedPower(((returns < 0) ? stddev(returns, 20) : close), 2), 5)) - 0.5\n```\n\n**Citation:** Academic source"}
{"instruction": "How do I implement Almgren_Chriss in Python?", "input": "", "output": "**Almgren_Chriss** - Optimal execution trajectory minimizing cost + variance\n\n**Formula:**\n```\nn_j = (X_0/N) * sinh(κ*(T-t_j)) / sinh(κ*T)\n```\n\n**Python Implementation:**\n```python\ndef almgren_chriss_schedule(position, n_periods, kappa):\n    schedule = []\n    T = n_periods\n    for j in range(n_periods):\n        trade = position * np.sinh(kappa * (T - j)) / np.sinh(kappa * T)\n        schedule.append(trade)\n    return np.array(schedule)\n```\n\n**Citation:** Almgren, R. & Chriss, N. (2001). Journal of Risk"}
{"instruction": "How do I implement Bipower_Variation in Python?", "input": "", "output": "**Bipower_Variation** - Robust to jumps, uses product of adjacent absolute returns\n\n**Formula:**\n```\nBV_t = (π/2) * Σ|r_{t,i}| * |r_{t,i-1}|\n```\n\n**Python Implementation:**\n```python\ndef bipower_variation(returns):\n    abs_ret = np.abs(returns)\n    return (np.pi / 2) * (abs_ret * abs_ret.shift(1)).sum()\n```\n\n**Citation:** Barndorff-Nielsen, O.E. & Shephard, N. (2004). Journal of Financial Econometrics"}
{"instruction": "Explain the components of Realized_Variance.", "input": "", "output": "**Realized_Variance**\n\nSum of squared intraday returns\n\n**Formula:**\n```\nRV_t = Σ(r_{t,i})² for i = 1 to n intraday returns\n```\n\n**Components:**\n- r_{t,i} (intraday returns)\n- n (number of observations)\n\n**Citation:** Andersen, T.G. & Bollerslev, T. (1998). International Economic Review"}
{"instruction": "When should I use Alpha006 in trading?", "input": "", "output": "**Alpha006** is used for: Negative correlation between open price and volume\n\n**Formula:**\n```\n-1 * correlation(open, volume, 10)\n```\n\nUse this when you need to negative correlation between open price and volume.\n\n**Citation:** Academic source"}
