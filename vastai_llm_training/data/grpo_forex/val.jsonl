{"instruction": "Explain the components of Alpha007.", "input": "", "output": "**Alpha007**\n\nVolume-conditioned momentum reversal\n\n**Formula:**\n```\n(adv20 < volume) ? ((-1 * ts_rank(abs(delta(close, 7)), 60)) * sign(delta(close, 7))) : -1\n```\n\n**Components:**\n- adv20\n- ts_rank\n- abs\n- delta\n- sign\n\n**Citation:** Academic source"}
{"instruction": "What is the Alpha017 formula?", "input": "", "output": "**Alpha017**\n\nPrice momentum with volume relative to average\n\n**Formula:**\n```\n(((-1 * rank(ts_rank(close, 10))) * rank(delta(delta(close, 1), 1))) * rank(ts_rank((volume / adv20), 5)))\n```\n\n**Citation:** Academic source"}
{"instruction": "When should I use GARCH_11 in trading?", "input": "", "output": "**GARCH_11** is used for: Generalized Autoregressive Conditional Heteroskedasticity\n\n**Formula:**\n```\nσ²_t = ω + α * ε²_{t-1} + β * σ²_{t-1}\n```\n\nUse this when you need to generalized autoregressive conditional heteroskedasticity.\n\n**Citation:** Bollerslev, T. (1986). Journal of Econometrics"}
{"instruction": "When should I use Alpha014 in trading?", "input": "", "output": "**Alpha014** is used for: Return momentum with open-volume correlation\n\n**Formula:**\n```\n((-1 * rank(delta(returns, 3))) * correlation(open, volume, 10))\n```\n\nUse this when you need to return momentum with open-volume correlation.\n\n**Citation:** Academic source"}
{"instruction": "Explain the components of Max_Drawdown.", "input": "", "output": "**Max_Drawdown**\n\nLargest peak-to-trough decline\n\n**Formula:**\n```\nMDD = max_t(max_{s≤t}(P_s) - P_t) / max_{s≤t}(P_s)\n```\n\n**Components:**\n- P_t (price at time t)\n- max (running maximum)\n\n**Citation:** Magdon-Ismail, M. & Atiya, A.F. (2004). Journal of Risk"}
{"instruction": "When should I use Alpha018 in trading?", "input": "", "output": "**Alpha018** is used for: Intraday volatility and correlation signal\n\n**Formula:**\n```\n-1 * rank(((stddev(abs((close - open)), 5) + (close - open)) + correlation(close, open, 10)))\n```\n\nUse this when you need to intraday volatility and correlation signal.\n\n**Citation:** Academic source"}
{"instruction": "How do I implement Alpha009 in Python?", "input": "", "output": "**Alpha009** - Trend-following with momentum conditions\n\n**Formula:**\n```\n(0 < ts_min(delta(close, 1), 5)) ? delta(close, 1) : ((ts_max(delta(close, 1), 5) < 0) ? delta(close, 1) : (-1 * delta(close, 1)))\n```\n\n**Python Implementation:**\n```python\ndef alpha009(close):\n    delta_close = close.diff(1)\n    ts_min_5 = delta_close.rolling(5).min()\n    ts_max_5 = delta_close.rolling(5).max()\n    return np.where(ts_min_5 > 0, delta_close,\n           np.where(ts_max_5 < 0, delta_close, -delta_close))\n```\n\n**Citation:** Academic source"}
{"instruction": "When should I use Parkinson in trading?", "input": "", "output": "**Parkinson** is used for: Range-based volatility using high-low range only\n\n**Formula:**\n```\nσ²_P = (ln(H/L))² / (4 * ln(2))\n```\n\nUse this when you need to range-based volatility using high-low range only.\n\n**Citation:** Parkinson, M. (1980). Journal of Business"}
{"instruction": "How do I implement Alpha005 in Python?", "input": "", "output": "**Alpha005** - Open vs VWAP deviation signal\n\n**Formula:**\n```\nrank(open - (sum(vwap, 10) / 10)) * (-1 * abs(rank(close - vwap)))\n```\n\n**Python Implementation:**\n```python\ndef alpha005(open_price, close, vwap):\n    vwap_ma = vwap.rolling(10).mean()\n    part1 = (open_price - vwap_ma).rank(pct=True)\n    part2 = -np.abs((close - vwap).rank(pct=True))\n    return part1 * part2\n```\n\n**Citation:** Academic source"}
{"instruction": "When should I use Roll_Spread in trading?", "input": "", "output": "**Roll_Spread** is used for: Implied bid-ask spread from price autocovariance\n\n**Formula:**\n```\nSpread = 2 * sqrt(-Cov(Δp_t, Δp_{t-1}))\n```\n\nUse this when you need to implied bid-ask spread from price autocovariance.\n\n**Citation:** Roll, R. (1984). Journal of Finance"}
{"instruction": "Explain the components of GARCH_11.", "input": "", "output": "**GARCH_11**\n\nGeneralized Autoregressive Conditional Heteroskedasticity\n\n**Formula:**\n```\nσ²_t = ω + α * ε²_{t-1} + β * σ²_{t-1}\n```\n\n**Components:**\n- ω (omega)\n- α (alpha)\n- β (beta)\n- ε² (squared residual)\n\n**Citation:** Bollerslev, T. (1986). Journal of Econometrics"}
{"instruction": "What is the GRPO formula?", "input": "", "output": "**GRPO**\n\nGroup Relative Policy Optimization - no critic needed\n\n**Formula:**\n```\nA_i = (r_i - mean(r)) / std(r), L = -E[min(ρ*A, clip(ρ,1-ε,1+ε)*A)]\n```\n\n**Citation:** DeepSeek-AI (2025). DeepSeek-R1 Technical Report"}
{"instruction": "When should I use GJR_GARCH in trading?", "input": "", "output": "**GJR_GARCH** is used for: GJR-GARCH with leverage effect (I=1 if ε<0)\n\n**Formula:**\n```\nσ²_t = ω + (α + γ * I_{t-1}) * ε²_{t-1} + β * σ²_{t-1}\n```\n\nUse this when you need to gjr-garch with leverage effect (i=1 if ε<0).\n\n**Citation:** Glosten, Jagannathan, Runkle (1993). Journal of Finance"}
{"instruction": "When should I use PPO in trading?", "input": "", "output": "**PPO** is used for: Proximal Policy Optimization with clipped objective\n\n**Formula:**\n```\nL_CLIP = E[min(r_t(θ)*A_t, clip(r_t(θ), 1-ε, 1+ε)*A_t)]\n```\n\nUse this when you need to proximal policy optimization with clipped objective.\n\n**Citation:** Schulman, J. et al. (2017). arXiv:1707.06347"}
{"instruction": "How do I implement Trade_Imbalance in Python?", "input": "", "output": "**Trade_Imbalance** - Normalized buy-sell volume imbalance\n\n**Formula:**\n```\nTI = (V_buy - V_sell) / (V_buy + V_sell)\n```\n\n**Python Implementation:**\n```python\ndef trade_imbalance(buy_volume, sell_volume):\n    return (buy_volume - sell_volume) / (buy_volume + sell_volume)\n```\n\n**Citation:** Chordia, T. & Subrahmanyam, A. (2004). Journal of Financial Economics"}
{"instruction": "When should I use Implementation_Shortfall in trading?", "input": "", "output": "**Implementation_Shortfall** is used for: Cost of execution vs decision price\n\n**Formula:**\n```\nIS = (P_exec - P_decision) * Q / (P_decision * Q)\n```\n\nUse this when you need to cost of execution vs decision price.\n\n**Citation:** Perold, A.F. (1988). Financial Analysts Journal"}
{"instruction": "What is the VWAP formula?", "input": "", "output": "**VWAP**\n\nVolume-Weighted Average Price execution\n\n**Formula:**\n```\nTarget% = Historical_Volume% at each interval\n```\n\n**Citation:** Madhavan, A. (2002). Financial Analysts Journal"}
{"instruction": "When should I use GAE in trading?", "input": "", "output": "**GAE** is used for: Generalized Advantage Estimation\n\n**Formula:**\n```\nA_t^GAE = Σ_{l=0}^{∞} (γλ)^l * δ_{t+l}\n```\n\nUse this when you need to generalized advantage estimation.\n\n**Citation:** Schulman, J. et al. (2015). arXiv:1506.02438"}
{"instruction": "Explain the components of Kelly_Criterion.", "input": "", "output": "**Kelly_Criterion**\n\nOptimal fraction of capital to risk\n\n**Formula:**\n```\nf* = (p * b - q) / b = (p * W/L - (1-p)) / (W/L)\n```\n\n**Components:**\n- p (win probability)\n- q (loss probability)\n- b (win/loss ratio)\n\n**Citation:** Kelly, J.L. (1956). Bell System Technical Journal"}
{"instruction": "How do I implement OFI in Python?", "input": "", "output": "**OFI** - Order Flow Imbalance - measures queue changes\n\n**Formula:**\n```\nOFI_t = ΔB_t * I(P^b_t ≥ P^b_{t-1}) - ΔA_t * I(P^a_t ≤ P^a_{t-1})\n```\n\n**Python Implementation:**\n```python\ndef ofi(bid_price, ask_price, bid_size, ask_size):\n    bid_up = bid_price >= bid_price.shift(1)\n    ask_down = ask_price <= ask_price.shift(1)\n    delta_bid = bid_size - bid_size.shift(1)\n    delta_ask = ask_size - ask_size.shift(1)\n    return delta_bid * bid_up - delta_ask * ask_down\n```\n\n**Citation:** Cont, R., Kukanov, A., & Stoikov, S. (2014). Journal of Financial Econometrics"}
{"instruction": "How do I implement Alpha013 in Python?", "input": "", "output": "**Alpha013** - Negative covariance of price and volume ranks\n\n**Formula:**\n```\n-1 * rank(covariance(rank(close), rank(volume), 5))\n```\n\n**Python Implementation:**\n```python\ndef alpha013(close, volume):\n    close_rank = close.rank(pct=True)\n    vol_rank = volume.rank(pct=True)\n    return -close_rank.rolling(5).cov(vol_rank).rank(pct=True)\n```\n\n**Citation:** Academic source"}
{"instruction": "When should I use EGARCH in trading?", "input": "", "output": "**EGARCH** is used for: Exponential GARCH capturing asymmetric volatility\n\n**Formula:**\n```\nlog(σ²_t) = ω + α * (|z_{t-1}| - E|z|) + γ * z_{t-1} + β * log(σ²_{t-1})\n```\n\nUse this when you need to exponential garch capturing asymmetric volatility.\n\n**Citation:** Nelson, D.B. (1991). Econometrica"}
{"instruction": "Explain the components of Trade_Imbalance.", "input": "", "output": "**Trade_Imbalance**\n\nNormalized buy-sell volume imbalance\n\n**Formula:**\n```\nTI = (V_buy - V_sell) / (V_buy + V_sell)\n```\n\n**Components:**\n- V_buy (buy volume)\n- V_sell (sell volume)\n\n**Citation:** Chordia, T. & Subrahmanyam, A. (2004). Journal of Financial Economics"}
{"instruction": "How do I implement Rogers_Satchell in Python?", "input": "", "output": "**Rogers_Satchell** - Range-based estimator handling drift\n\n**Formula:**\n```\nσ²_RS = ln(H/C)*ln(H/O) + ln(L/C)*ln(L/O)\n```\n\n**Python Implementation:**\n```python\ndef rogers_satchell(high, low, close, open_price):\n    return (np.log(high/close) * np.log(high/open_price) +\n            np.log(low/close) * np.log(low/open_price))\n```\n\n**Citation:** Rogers, L.C.G. & Satchell, S.E. (1991). Annals of Applied Probability"}
{"instruction": "When should I use Trade_Imbalance in trading?", "input": "", "output": "**Trade_Imbalance** is used for: Normalized buy-sell volume imbalance\n\n**Formula:**\n```\nTI = (V_buy - V_sell) / (V_buy + V_sell)\n```\n\nUse this when you need to normalized buy-sell volume imbalance.\n\n**Citation:** Chordia, T. & Subrahmanyam, A. (2004). Journal of Financial Economics"}
{"instruction": "Explain the components of Alpha002.", "input": "", "output": "**Alpha002**\n\nNegative correlation between volume change and intraday return\n\n**Formula:**\n```\n-1 * correlation(rank(delta(log(volume), 2)), rank((close - open) / open), 6)\n```\n\n**Components:**\n- delta\n- log(volume)\n- correlation\n- rank\n\n**Citation:** Academic source"}
{"instruction": "When should I use Yang_Zhang in trading?", "input": "", "output": "**Yang_Zhang** is used for: Combines overnight, close-to-close, and Rogers-Satchell\n\n**Formula:**\n```\nσ²_YZ = σ²_o + k*σ²_c + (1-k)*σ²_RS\n```\n\nUse this when you need to combines overnight, close-to-close, and rogers-satchell.\n\n**Citation:** Yang, D. & Zhang, Q. (2000). Journal of Business"}
{"instruction": "Explain the components of Amihud_ILLIQ.", "input": "", "output": "**Amihud_ILLIQ**\n\nPrice impact per dollar of trading volume\n\n**Formula:**\n```\nILLIQ = (1/D) * Σ|r_d| / V_d\n```\n\n**Components:**\n- |r_d| (absolute return)\n- V_d (dollar volume)\n- D (days)\n\n**Citation:** Amihud, Y. (2002). Journal of Financial Markets"}
{"instruction": "How do I implement Alpha002 in Python?", "input": "", "output": "**Alpha002** - Negative correlation between volume change and intraday return\n\n**Formula:**\n```\n-1 * correlation(rank(delta(log(volume), 2)), rank((close - open) / open), 6)\n```\n\n**Python Implementation:**\n```python\ndef alpha002(open_price, close, volume):\n    delta_log_vol = np.log(volume).diff(2)\n    intraday_ret = (close - open_price) / open_price\n    return -delta_log_vol.rolling(6).corr(intraday_ret)\n```\n\n**Citation:** Academic source"}
{"instruction": "What is the Alpha014 formula?", "input": "", "output": "**Alpha014**\n\nReturn momentum with open-volume correlation\n\n**Formula:**\n```\n((-1 * rank(delta(returns, 3))) * correlation(open, volume, 10))\n```\n\n**Citation:** Academic source"}
{"instruction": "How do I implement Alpha008 in Python?", "input": "", "output": "**Alpha008** - Momentum of open-return product\n\n**Formula:**\n```\n-1 * rank(((sum(open, 5) * sum(returns, 5)) - delay((sum(open, 5) * sum(returns, 5)), 10)))\n```\n\n**Python Implementation:**\n```python\ndef alpha008(open_price, returns):\n    open_sum = open_price.rolling(5).sum()\n    ret_sum = returns.rolling(5).sum()\n    product = open_sum * ret_sum\n    return -(product - product.shift(10)).rank(pct=True)\n```\n\n**Citation:** Academic source"}
{"instruction": "Explain the components of VaR.", "input": "", "output": "**VaR**\n\nValue at Risk - maximum loss at confidence level\n\n**Formula:**\n```\nVaR_α = -inf{x : P(L ≤ x) ≥ α} = μ + σ * Φ^{-1}(α)\n```\n\n**Components:**\n- α (confidence level)\n- μ (mean)\n- σ (std dev)\n- Φ^{-1} (inverse normal)\n\n**Citation:** Jorion, P. (2006). Value at Risk"}
{"instruction": "When should I use Max_Drawdown in trading?", "input": "", "output": "**Max_Drawdown** is used for: Largest peak-to-trough decline\n\n**Formula:**\n```\nMDD = max_t(max_{s≤t}(P_s) - P_t) / max_{s≤t}(P_s)\n```\n\nUse this when you need to largest peak-to-trough decline.\n\n**Citation:** Magdon-Ismail, M. & Atiya, A.F. (2004). Journal of Risk"}
{"instruction": "Explain the components of Rogers_Satchell.", "input": "", "output": "**Rogers_Satchell**\n\nRange-based estimator handling drift\n\n**Formula:**\n```\nσ²_RS = ln(H/C)*ln(H/O) + ln(L/C)*ln(L/O)\n```\n\n**Components:**\n- H\n- L\n- C\n- O\n\n**Citation:** Rogers, L.C.G. & Satchell, S.E. (1991). Annals of Applied Probability"}
{"instruction": "What is the Amihud_ILLIQ formula?", "input": "", "output": "**Amihud_ILLIQ**\n\nPrice impact per dollar of trading volume\n\n**Formula:**\n```\nILLIQ = (1/D) * Σ|r_d| / V_d\n```\n\n**Citation:** Amihud, Y. (2002). Journal of Financial Markets"}
{"instruction": "How do I implement Alpha016 in Python?", "input": "", "output": "**Alpha016** - Negative covariance of high and volume ranks\n\n**Formula:**\n```\n-1 * rank(covariance(rank(high), rank(volume), 5))\n```\n\n**Python Implementation:**\n```python\ndef alpha016(high, volume):\n    high_rank = high.rank(pct=True)\n    vol_rank = volume.rank(pct=True)\n    return -high_rank.rolling(5).cov(vol_rank).rank(pct=True)\n```\n\n**Citation:** Academic source"}
{"instruction": "When should I use Sharpe_Ratio in trading?", "input": "", "output": "**Sharpe_Ratio** is used for: Risk-adjusted return per unit of volatility\n\n**Formula:**\n```\nSR = (R_p - R_f) / σ_p\n```\n\nUse this when you need to risk-adjusted return per unit of volatility.\n\n**Citation:** Sharpe, W.F. (1966). Journal of Business"}
{"instruction": "When should I use Alpha015 in trading?", "input": "", "output": "**Alpha015** is used for: Rolling sum of high-volume correlation ranks\n\n**Formula:**\n```\n-1 * sum(rank(correlation(rank(high), rank(volume), 3)), 3)\n```\n\nUse this when you need to rolling sum of high-volume correlation ranks.\n\n**Citation:** Academic source"}
{"instruction": "When should I use Sortino_Ratio in trading?", "input": "", "output": "**Sortino_Ratio** is used for: Sharpe using only downside volatility\n\n**Formula:**\n```\nSortino = (R_p - R_f) / σ_downside\n```\n\nUse this when you need to sharpe using only downside volatility.\n\n**Citation:** Sortino, F.A. & van der Meer, R. (1991). Journal of Portfolio Management"}
{"instruction": "How do I implement Calmar_Ratio in Python?", "input": "", "output": "**Calmar_Ratio** - Annual return divided by maximum drawdown\n\n**Formula:**\n```\nCalmar = R_annual / Max_Drawdown\n```\n\n**Python Implementation:**\n```python\ndef calmar_ratio(returns, periods_per_year=252):\n    annual_return = (1 + returns).prod() ** (periods_per_year / len(returns)) - 1\n    cumulative = (1 + returns).cumprod()\n    running_max = cumulative.expanding().max()\n    drawdown = (cumulative - running_max) / running_max\n    max_dd = drawdown.min()\n    return annual_return / abs(max_dd)\n```\n\n**Citation:** Young, T.W. (1991). Futures Magazine"}
{"instruction": "What is the Alpha019 formula?", "input": "", "output": "**Alpha019**\n\nLong-term momentum reversal\n\n**Formula:**\n```\n((-1 * sign(((close - delay(close, 7)) + delta(close, 7)))) * (1 + rank((1 + sum(returns, 250)))))\n```\n\n**Citation:** Academic source"}
{"instruction": "When should I use Alpha008 in trading?", "input": "", "output": "**Alpha008** is used for: Momentum of open-return product\n\n**Formula:**\n```\n-1 * rank(((sum(open, 5) * sum(returns, 5)) - delay((sum(open, 5) * sum(returns, 5)), 10)))\n```\n\nUse this when you need to momentum of open-return product.\n\n**Citation:** Academic source"}
{"instruction": "How do I implement Information_Ratio in Python?", "input": "", "output": "**Information_Ratio** - Active return per unit of tracking error\n\n**Formula:**\n```\nIR = (R_p - R_b) / σ(R_p - R_b)\n```\n\n**Python Implementation:**\n```python\ndef information_ratio(returns, benchmark_returns):\n    active_returns = returns - benchmark_returns\n    return active_returns.mean() / active_returns.std() * np.sqrt(252)\n```\n\n**Citation:** Grinold, R.C. & Kahn, R.N. (2000). Active Portfolio Management"}
{"instruction": "How do I implement Alpha019 in Python?", "input": "", "output": "**Alpha019** - Long-term momentum reversal\n\n**Formula:**\n```\n((-1 * sign(((close - delay(close, 7)) + delta(close, 7)))) * (1 + rank((1 + sum(returns, 250)))))\n```\n\n**Python Implementation:**\n```python\ndef alpha019(close, returns):\n    momentum = (close - close.shift(7)) + close.diff(7)\n    long_ret = (1 + returns.rolling(250).sum()).rank(pct=True)\n    return -np.sign(momentum) * (1 + long_ret)\n```\n\n**Citation:** Academic source"}
{"instruction": "What is the OFI formula?", "input": "", "output": "**OFI**\n\nOrder Flow Imbalance - measures queue changes\n\n**Formula:**\n```\nOFI_t = ΔB_t * I(P^b_t ≥ P^b_{t-1}) - ΔA_t * I(P^a_t ≤ P^a_{t-1})\n```\n\n**Citation:** Cont, R., Kukanov, A., & Stoikov, S. (2014). Journal of Financial Econometrics"}
{"instruction": "Explain the components of LOB_Imbalance.", "input": "", "output": "**LOB_Imbalance**\n\nNormalized order book imbalance at best levels\n\n**Formula:**\n```\nImbalance = (Q_bid - Q_ask) / (Q_bid + Q_ask)\n```\n\n**Components:**\n- Q_bid (bid quantity)\n- Q_ask (ask quantity)\n\n**Citation:** Cont, R. et al. (2014). Journal of Financial Econometrics"}
{"instruction": "When should I use Kyle_Lambda in trading?", "input": "", "output": "**Kyle_Lambda** is used for: Measure of market depth and price impact\n\n**Formula:**\n```\nλ = ΔP / ΔQ (price impact per unit order flow)\n```\n\nUse this when you need to measure of market depth and price impact.\n\n**Citation:** Kyle, A.S. (1985). Econometrica"}
{"instruction": "How do I implement Alpha003 in Python?", "input": "", "output": "**Alpha003** - Negative correlation between open price rank and volume rank\n\n**Formula:**\n```\n-1 * correlation(rank(open), rank(volume), 10)\n```\n\n**Python Implementation:**\n```python\ndef alpha003(open_price, volume):\n    return -open_price.rank(pct=True).rolling(10).corr(volume.rank(pct=True))\n```\n\n**Citation:** Academic source"}
{"instruction": "What is the VaR formula?", "input": "", "output": "**VaR**\n\nValue at Risk - maximum loss at confidence level\n\n**Formula:**\n```\nVaR_α = -inf{x : P(L ≤ x) ≥ α} = μ + σ * Φ^{-1}(α)\n```\n\n**Citation:** Jorion, P. (2006). Value at Risk"}
{"instruction": "What is the EGARCH formula?", "input": "", "output": "**EGARCH**\n\nExponential GARCH capturing asymmetric volatility\n\n**Formula:**\n```\nlog(σ²_t) = ω + α * (|z_{t-1}| - E|z|) + γ * z_{t-1} + β * log(σ²_{t-1})\n```\n\n**Citation:** Nelson, D.B. (1991). Econometrica"}
